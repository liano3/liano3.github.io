<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liano-blog</title>
  
  <subtitle>永不停步</subtitle>
  <link href="https://liano.top/atom.xml" rel="self"/>
  
  <link href="https://liano.top/"/>
  <updated>2022-08-23T13:31:15.835Z</updated>
  <id>https://liano.top/</id>
  
  <author>
    <name>Liano</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>巧解数学问题</title>
    <link href="https://liano.top/posts/4621e56e/"/>
    <id>https://liano.top/posts/4621e56e/</id>
    <published>2022-08-23T11:37:06.439Z</published>
    <updated>2022-08-23T13:31:15.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公倍数与公因数"><a href="#公倍数与公因数" class="headerlink" title="公倍数与公因数"></a>公倍数与公因数</h2><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>利用辗转相除法，我们可以很方便地求得两个数的最大公因数（greatest common divisor，gcd）；将两个数相乘再除以最大公因数即可得到最小公倍数（least common multiple, lcm）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a% b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>进一步地，我们也可以通过扩展欧几里得算法（extended gcd）在求得 a 和 b 最大公因数的同时，也得到它们的系数 x 和 y，从而使 ax + by = gcd(a, b)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">xGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1, gcd = <span class="built_in">xGCD</span>(b, a % b, x1, y1);</span><br><span class="line">    x = y1;</span><br><span class="line">    y = x1 - (a / b) * y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p>质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，由质因子分解定理，每一个数都可以分解成质数的乘积，且分解后形式唯一。</p><h3 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a><a href="https://leetcode.cn/problems/count-primes/">计数质数</a></h3><p><strong>题目描述：</strong></p><p>给定整数 n，返回所有小于非负整数 n 的质数的数量。（n &gt;= 0）</p><p><strong>题解：</strong></p><p>埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法）是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数 n 时，同时判断所有小于 n 的整数，因此非常适合这道题。其原理也十分易懂：从 1 到 n 遍历，假设当前遍历到 m，则把所有小于 n 的、且是 m 的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = n - <span class="number">2</span>; <span class="comment">// 去掉不是质数的1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i]) &#123;<span class="comment">//若一个数已经标记过，则他的倍数肯定也被标记过了，可以跳过</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prime[j]) &#123;</span><br><span class="line">                    prime[j] = <span class="literal">false</span>;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用质数的一些性质，我们可以进一步优化该算法。对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。另外，偶数倍的 x 一定被 2 标记过了，所以 j 增量为 2*i；另外，若一个数有偶数因子，则这个数一定已经被 2 标记过了，所以 i 增量为 2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>, sqrtn = <span class="built_in">sqrt</span>(n), count = n / <span class="number">2</span>; <span class="comment">// 偶数一定不是质数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= sqrtn) &#123; <span class="comment">// 最小质因子一定小于等于开方数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += <span class="number">2</span> * i) &#123; <span class="comment">// 避免偶数和重复遍历</span></span><br><span class="line">            <span class="keyword">if</span> (prime[j]) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt;= sqrtn &amp;&amp; !prime[i]); <span class="comment">// 避免偶数和重复遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字处理"><a href="#数字处理" class="headerlink" title="数字处理"></a>数字处理</h2><h3 id="七进制数"><a href="#七进制数" class="headerlink" title="七进制数"></a><a href="https://leetcode.cn/problems/base-7/">七进制数</a></h3><p><strong>题目描述：</strong></p><p>给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。</p><p><strong>题解：</strong></p><p>进制转换类型的题，通常是利用除法和取模（mod）来进行计算，同时也要注意一些细节，如负数和零。如果输出是数字类型而非字符串，则也需要考虑是否会超出整数上下界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToBase7</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> is_negative = (num &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (is_negative) </span><br><span class="line">        num = -num;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        <span class="type">int</span> a = num / <span class="number">7</span>, b = num % <span class="number">7</span>;</span><br><span class="line">        ans = <span class="built_in">to_string</span>(b) + ans;</span><br><span class="line">        num = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_negative ? <span class="string">&quot;-&quot;</span> + ans: ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">阶乘后的零</a></h3><p><strong>题目描述：</strong></p><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。（n &gt;= 0)</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：n = 3<br>输出：0</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 5<br>输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：n = 0<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>每个尾部的 0 由 2 × 5 = 10 而来，因此我们可以把阶乘的每一个元素拆成质数相乘，统计有多少个 2 和 5，取最小值即可，明显的，质因子 2 的数量远多于质因子 5 的数量，因此我们可以只统计阶乘结果里有多少个质因子 5，即 1~n 的质因子中 5 的个数和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= n; i += <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = i;</span><br><span class="line">        <span class="keyword">while</span>(temp % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            temp /= <span class="number">5</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用数学方法再优化，换个角度考虑 1~n 的质因子 p 的个数，首先 p 的倍数的个数为$n_1=[\frac{n}{p}]$，贡献了 $n_1$ 个 p，然后 $p^2$ 的倍数个数为 $n_2=[\frac{n}{p^2}]$，因为在 $n_1$ 中已经算过了一半，所以只多贡献了 $n_2$ 个 p，以此类推，</p><script type="math/tex; mode=display">ans=\sum_{k=1}[\frac{n}{p^k}]=\sum_{k=1}[\frac{\frac{n}{p^{k-1}}}{p}]</script><p>因此我们可以通过不断将 n 除以 5，并累加每次除后的 n，来得到答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n / <span class="number">5</span> + <span class="built_in">trailingZeroes</span>(n / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多么简洁，优雅，美妙！数学真伟大！</p><h3 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">字符串相加</a></h3><p><strong>题目描述：</strong></p><p>给定两个字符串形式的非负整数 num1 和 num2，num1 和num2 都不包含任何前导零，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger），也不能直接将输入的字符串转换为整数形式。num1 和num2 都不包含任何前导零</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：num1 = “11”, num2 = “123”<br>输出：”134”</p></blockquote><p>示例 2：</p><blockquote><p>输入：num1 = “456”, num2 = “77”<br>输出：”533”</p></blockquote><p>示例 3：</p><blockquote><p>输入：num1 = “0”, num2 = “0”<br>输出：”0”</p></blockquote><p><strong>题解：</strong></p><p>因为相加运算是从后往前进行的，所以可以先翻转字符串，再逐位计算。模拟人工手算法即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">output</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">reverse</span>(num1.<span class="built_in">begin</span>(), num1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(num2.<span class="built_in">begin</span>(), num2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> onelen = num1.<span class="built_in">length</span>(), twolen = num2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (onelen &lt;= twolen)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(num1, num2);</span><br><span class="line">        <span class="built_in">swap</span>(onelen, twolen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> addbit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; twolen; i++)&#123;</span><br><span class="line">        <span class="type">int</span> cur_sum = (num1[i]-<span class="string">&#x27;0&#x27;</span>) + (num2[i]-<span class="string">&#x27;0&#x27;</span>) + addbit;</span><br><span class="line">        output += <span class="built_in">to_string</span>((cur_sum) % <span class="number">10</span>);</span><br><span class="line">        addbit = cur_sum &lt; <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = twolen; i &lt; onelen; i++)&#123;</span><br><span class="line">        <span class="type">int</span> cur_sum = (num1[i]-<span class="string">&#x27;0&#x27;</span>) + addbit;</span><br><span class="line">        output += <span class="built_in">to_string</span>((cur_sum) % <span class="number">10</span>);</span><br><span class="line">        addbit = cur_sum &lt; <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addbit)</span><br><span class="line">        output += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(output.<span class="built_in">begin</span>(), output.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="‘3’的幂次方"><a href="#‘3’的幂次方" class="headerlink" title="‘3’的幂次方"></a><a href="https://leetcode.cn/problems/power-of-three/">‘3’的幂次方</a></h3><p><strong>题目描述：</strong></p><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true；否则，返回 false。(n为int类型)</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：n = 27<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 0<br>输出：false</p></blockquote><p>示例 3：</p><blockquote><p>输入：n = 45<br>输出：false</p></blockquote><p><strong>题解：</strong></p><p>有两种方法，一种是利用对数。设 $log_3(n) = m$，如果 n 是 3 的整数次方，那么 m 一定是整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fmod</span>(<span class="built_in">log10</span>(n) / <span class="built_in">log10</span>(<span class="number">3</span>), <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是，因为在 int 范围内 3 的最大次方是 $3^{19} = 1162261467$，如果 n 是 3 的整数次方，那么 1162261467 除以 n 的余数一定是零；反之亦然。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool isPowerOfThree(int n) &#123;</span><br><span class="line">return n &gt; 0 &amp;&amp; 1162261467 % n == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机与取样"><a href="#随机与取样" class="headerlink" title="随机与取样"></a>随机与取样</h2><h3 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a><a href="https://leetcode.cn/problems/shuffle-an-array/">打乱数组</a></h3><p><strong>题目描述：</strong></p><p>给定一个数组，要求在类中实现两个指令函数。第一个函数“shuffle”可以随机打乱这个数组，第二个函数“reset”可以恢复原来的顺序。</p><p><strong>测试样例：</strong></p><p>输入是一个存有整数数字的数组，和一个包含指令函数名称的数组。输出是一个二维数组，表示每个指令生成的数组。</p><blockquote><p>Input: nums = [1,2,3], actions: [“shuffle”,”shuffle”,”reset”]<br>Output: [[2,1,3],[3,2,1],[1,2,3]]<br>在这个样例中，前两次打乱的结果只要是随机生成即可。</p></blockquote><p><strong>题解：</strong></p><p>我们采用经典的 Fisher-Yates 洗牌算法，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法，且实现非常方便。注意这里“reset”函数以及类的构造函数的实现细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; origin;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums): <span class="built_in">origin</span>(nums) &#123;&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffled</span><span class="params">(origin)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = origin.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 反向洗牌：（正向效果相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">swap</span>(shuffled[i], shuffled[<span class="built_in">rand</span>() % (i + <span class="number">1</span>)]);</span><br><span class="line">        <span class="keyword">return</span> shuffled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者直接使用random_shuffle()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; shuffled = origin;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(shuffled.<span class="built_in">begin</span>(), shuffled.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> shuffled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按权重随机选择"><a href="#按权重随机选择" class="headerlink" title="按权重随机选择"></a><a href="https://leetcode.cn/problems/random-pick-with-weight/">按权重随机选择</a></h3><p><strong>题目描述：</strong></p><p>给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。</p><p><strong>测试样例：</strong></p><blockquote><p>Input: weights = [1,3], actions: [“pickIndex”,”pickIndex”,”pickIndex”]<br>Output: [0,1,1]</p></blockquote><p><strong>题解：</strong></p><p>设数组 w 的权重之和为 total。根据题目的要求，我们可以看成将 [1,total] 范围内的所有整数分成 n 个部分（其中 n 是数组 w 的长度），第 i 个部分恰好包含 w[i] 个整数，并且这 n 个部分两两的交集为空。随后我们在 [1,total] 范围内随机选择一个整数 x，如果整数 x 被包含在第 i 个部分内，我们就返回 i。</p><p>一种较为简单的划分方法是按照从小到大的顺序依次划分每个部分。例如 w=[3,1,2,4] 时，权重之和 total=10，那么我们按照 [1,3],[4,4],[5,6],[7,10] 对 [1,10] 进行划分，使得它们的长度恰好依次为 3,1,2,4。可以发现，每个区间的左边界是在它之前出现的所有元素的和加上 1，右边界是到它为止的所有元素的和。因此，如果我们用 pre[i] 表示数组 w 的前缀和：</p><script type="math/tex; mode=display">pre[i]=\sum_{k=0}^{i}w[k]\\第 i 个区间的左边界就是 pre[i]−w[i]+1，右边界为 pre[i]。</script><p>当划分完成后，假设我们随机到了整数 x，我们希望找到满足：$pre[i]−w[i]+1≤x≤pre[i]$ 的 i 并将其作为答案返回。由于 pre[i] 是单调递增的，因此我们可以使用二分查找快速找到 i，即找出最小的满足 x≤pre[i] 的下标 i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt; weights): <span class="built_in">sums</span>(std::<span class="built_in">move</span>(weights)) &#123;</span><br><span class="line">        <span class="built_in">partial_sum</span>(sums.<span class="built_in">begin</span>(), sums.<span class="built_in">end</span>(), sums.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = (<span class="built_in">rand</span>() % sums.<span class="built_in">back</span>()) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(sums.<span class="built_in">begin</span>(), sums.<span class="built_in">end</span>(), pos) - sums.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>partial_sum用于计算局部和（start, end, storage)</p><p>lower_bound用于找出范围内不小于num的第一个元素（start, end, storage)</p></blockquote><h3 id="链表随机节点"><a href="#链表随机节点" class="headerlink" title="链表随机节点"></a><a href="https://leetcode.cn/problems/linked-list-random-node/">链表随机节点</a></h3><p><strong>题目描述：</strong></p><p>给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。</p><p><strong>测试样例：</strong></p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5<br>Output: 3</p></blockquote><p><strong>题解：</strong></p><p>不同于数组，在未遍历完链表前，我们无法知道链表的总长度。这里我们就可以使用水库采样：遍历一次链表，在遍历到第 m 个节点时，有 1/m 的概率选择这个节点覆盖掉之前的节点选择。</p><p>我们提供一个简单的，对于水库算法随机性的证明。对于长度为 n 的链表的第 m 个节点，最后被采样的充要条件是它被选择，且之后的节点都没有被选择。这种情况发生的概率为 $\frac{1}{m}\times\frac{m}{m+1}\times\frac{m+1}{m+2}…=\frac{1}{n}$ 因此每个点都有均等的概率被选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode* head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* n): <span class="built_in">head</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = head-&gt;val;</span><br><span class="line">        ListNode* node = head-&gt;next;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">rand</span>() % i) == <span class="number">0</span>)</span><br><span class="line">                ans = node-&gt;val;</span><br><span class="line">            i++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="Excel表列名称"><a href="#Excel表列名称" class="headerlink" title="Excel表列名称"></a><a href="https://leetcode.cn/problems/excel-sheet-column-title/">Excel表列名称</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数 columnNumber，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><blockquote><p>A -&gt; 1<br>B -&gt; 2<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…</p></blockquote><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：columnNumber = 1<br>输出：”A”</p></blockquote><p>示例 2：</p><blockquote><p>输入：columnNumber = 28<br>输出：”AB”</p></blockquote><p><strong>题解：</strong></p><p>和正常 0~25 的 26 进制相比，本质上就是每一位多加了 1。假设 A = 0，B = 1，那么 AB = 26 * 0 + 1 * 1，而现在 AB = 26 * (0 + 1) + 1 * (1 + 1)，所以只要在处理每一位的时候减 1，就可以按照正常的 26 进制来处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span>(columnNumber) &#123;</span><br><span class="line">        columnNumber--;</span><br><span class="line">        <span class="type">int</span> re = columnNumber % <span class="number">26</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="string">&#x27;A&#x27;</span> + re);</span><br><span class="line">        columnNumber /= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a><a href="https://leetcode.cn/problems/add-binary/">二进制求和</a></h3><p><strong>题目描述：</strong></p><p>给你两个二进制字符串，返回它们的和（用二进制表示）。输入为非空字符串且只包含数字 1 和 0。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: a = “11”, b = “1”<br>输出: “100”</p></blockquote><p>示例 2:</p><blockquote><p>输入: a = “1010”, b = “1011”<br>输出: “10101”</p></blockquote><p><strong>题解：</strong></p><p>翻转，进位计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        carry += i &lt; a.<span class="built_in">size</span>() ? (a.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">        carry += i &lt; b.<span class="built_in">size</span>() ? (b.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(carry % <span class="number">2</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry)</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数数组 nums，返回数组 answer，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><p>题目数据保证数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: nums = [1,2,3,4]<br>输出: [24,12,8,6]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [-1,1,0,-3,3]<br>输出: [0,0,9,0,0]</p></blockquote><p><strong>题解：</strong></p><p>L[i] 表示 nums[i] 左侧所有数字的乘积，R[i] 表示右侧，初始化后遍历数组即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(length, <span class="number">0</span>)</span>, <span class="title">R</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answer</span><span class="params">(length)</span></span>;</span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">    R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        answer[i] = L[i] * R[i];</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最少移动次数使数组相等II"><a href="#最少移动次数使数组相等II" class="headerlink" title="最少移动次数使数组相等II"></a><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">最少移动次数使数组相等II</a></h3><p><strong>题目描述：</strong></p><p>给你一个长度为 n 的整数数组 nums，返回使所有数组元素相等需要的最少移动数。在一步操作中，你可以使数组中的一个元素加 1 或者减 1。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,10,2,9]<br>输出：16</p></blockquote><p><strong>题解：</strong></p><p>很容易想到，都变成中位数所需移动次数较少，证明为什么用中位数，其实很简单，如果target往两侧偏移，如果一侧数字少一侧数字多，往多的一侧移动必然使得结果减少。直到target两侧的数字数量完全相等时，取得最小值。这里使用快速选择找到 target</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minMoves2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">nth_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + nums.<span class="built_in">size</span>() / <span class="number">2</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> target = nums[nums.<span class="built_in">size</span>()/<span class="number">2</span>], ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; x: nums) </span><br><span class="line">        ans += <span class="built_in">abs</span>(x - target);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">多数元素</a></h3><p><strong>题目描述：</strong></p><p>给定一个大小为 n 的数组 nums，返回其中的多数元素。多数元素是指在数组中出现次数大于 n/2 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [3,2,3]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,2,1,1,1,2,2]<br>输出：2</p></blockquote><p><strong>题解：</strong></p><h4 id="Boyer-Moore-投票算法："><a href="#Boyer-Moore-投票算法：" class="headerlink" title="Boyer-Moore 投票算法："></a>Boyer-Moore 投票算法：</h4><ol><li>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</li><li>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：<ul><li>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</li><li>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</li></ul></li><li>在遍历完成后，candidate 即为整个数组的众数（这里众数指个数 &gt; n/2)。</li></ol><p>这里提供一个比较好理解的证明：</p><p>首先遍历数组时，遍历到的人将有一次投票权，相同的数字代表同一个人，在投票中，所有人都是利己的，即只会给自己投支持票，给不是自己的候选人投反对票。对于第一个候选人来说，如果他不是 maj，count迟早会变为 0，因为他自己最多给自己投的票数不超过一半，而其他人都会投反对票；即使反对票全部是 maj 投的（这里是极端情况），那么以 count=0 为分界，前面一段数组中 maj 也只占了一半，所以后面一段数组中众数还是 maj。如果第一个候选人是 maj，若 count 到最后都没有变为 0，当然选出来的就是 maj，若 count 在中间变为 0 了，那么前面一段数组中 maj 没占到一半票数，所以后面一段众数还是 maj。把前面一段丢掉不考虑，继续在后面一段中投票，可以看出是重复上述过程，所以最终候选人一定是是 maj。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == candidate)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用rand7-实现rand10"><a href="#用rand7-实现rand10" class="headerlink" title="用rand7()实现rand10()"></a><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/">用rand7()实现rand10()</a></h3><p><strong>题目描述：</strong></p><p>给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。</p><p>每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。</p><p><strong>测试样例：</strong></p><blockquote><p>输入: 3<br>输出: [3,8,10]</p></blockquote><p><strong>题解：</strong></p><p>两个rand7()相乘，选择概率相等的一些数，映射到 [1,10] 即可；</p><p><img src="https://s2.loli.net/2022/08/23/zdyiqb6BoaK5wVL.jpg" alt="20210905012406.jpg" style="zoom: 50%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row, col, idx;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        row = <span class="built_in">rand7</span>();</span><br><span class="line">        col = <span class="built_in">rand7</span>();</span><br><span class="line">        idx = col + (row - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (idx &gt; <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (idx - <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">快乐数</a></h3><p><strong>题目描述：</strong></p><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><blockquote><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环但始终变不到 1。<br>如果这个过程结果为 1，那么这个数就是快乐数。</p></blockquote><p>如果 n 是快乐数就返回 true；不是，则返回 false。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：n = 19<br>输出：true<br>解释：<br>1^1^ + 9^2^ = 82<br>8^2^ + 2^2^ = 68<br>6^2^ + 8^2^ = 100<br>1^2^ + 0^2^ + 0^2^ = 1</p></blockquote><p><strong>题解：</strong></p><p>对于 3 位数的数字，它不可能大于 $243(3×9^2)$。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以只有两种情况，一是进入循环，二是得到 1。把每个中间数字作为一个节点，可以使用前面章节讲过的快慢指针进行环路检测。如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitSquareSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> bit = n % <span class="number">10</span>;</span><br><span class="line">        sum += bit * bit;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slow = n, fast = n;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = <span class="built_in">bitSquareSum</span>(slow);</span><br><span class="line">        fast = <span class="built_in">bitSquareSum</span>(fast);</span><br><span class="line">        fast = <span class="built_in">bitSquareSum</span>(fast);</span><br><span class="line">    &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">    <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;公倍数与公因数&quot;&gt;&lt;a href=&quot;#公倍数与公因数&quot; class=&quot;headerlink&quot; title=&quot;公倍数与公因数&quot;&gt;&lt;/a&gt;公倍数与公因数&lt;/h2&gt;&lt;h3 id=&quot;辗转相除法&quot;&gt;&lt;a href=&quot;#辗转相除法&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数学问题" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
    <category term="算法" scheme="https://liano.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法</title>
    <link href="https://liano.top/posts/7f3bcd7f/"/>
    <id>https://liano.top/posts/7f3bcd7f/</id>
    <published>2022-08-22T09:07:35.139Z</published>
    <updated>2022-08-22T10:18:24.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>顾名思义，分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。我们在排序章节展示的归并排序就是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终我们会得到多个长度为 1 的子数组;“治”即为把已经排好序的两个小数组合成为一个排好序的大数组，从长度为 1 的子数组开始，最终合成一个大数组。</p><p>另外，自上而下的分治可以和 memoization 结合，避免重复遍历相同的子问题。如果方便推导，也可以换用自下而上的动态规划方法求解。</p><h2 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题"></a>表达式问题</h2><h3 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">为运算表达式设计优先级</a></h3><p><strong>题目描述：</strong></p><p>给你一个由数字和运算符（只包含+，-，*）组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以按任意顺序返回答案。</p><p>生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：expression = “2-1-1”<br>输出：[0,2]</p></blockquote><p>示例 2：</p><blockquote><p>输入：expression = “2*3-4*5”<br>输出：[-34,-14,-10,-10,10]<br>解释：<br>(2*(3-(4*5))) = -34<br>((2*3)-(4*5)) = -14<br>((2*(3-4))*5) = -10<br>(2*((3-4)*5)) = -10<br>(((2*3)-4)*5) = 10</p></blockquote><p><strong>题解：</strong></p><p>利用分治思想，我们可以把加括号转化为，对于每个运算符号，先执行处理两侧的数学表达式，再处理此运算符号。注意特殊情况，即字符串内无运算符号，只有数字。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ways;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> c = input[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//分</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(<span class="number">0</span>, i));</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(i + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//治</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; l: left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; r: right) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: ways.<span class="built_in">push_back</span>(l + r); <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: ways.<span class="built_in">push_back</span>(l - r); <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: ways.<span class="built_in">push_back</span>(l * r); <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ways.<span class="built_in">empty</span>()) </span><br><span class="line">        ways.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input));<span class="comment">//stoi()函数将string类型转为int</span></span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，某些被 divide 的子字符串可能重复出现多次，因此我们可以用 memoization 来去重。或者与其我们从上到下用分治处理 + memoization，不如直接从下到上用动态规划处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; ops;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> op = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="comment">// 将 input 划分成数据（data）和运算符（ops），后面加一个 &quot;+&quot; 方便处理</span></span><br><span class="line">    <span class="function">istringstream <span class="title">ss</span><span class="params">(input + <span class="string">&quot;+&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(num);</span><br><span class="line">        ops.<span class="built_in">push_back</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 三维 vector 数组</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dp[i][j] 是一个一维 vector 数组，里面存储着：从第 i+1 个数字到第 j+1 个数字组成的算式的所有可能的运算结果，</span></span><br><span class="line"><span class="comment">    所以最后要输出的就是 dp[0][n-1]。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 如果 i == j，显然只有一种可能</span></span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                dp[j][i].<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* k 在 i 和 j 之间形成了一个 divide</span></span><br><span class="line"><span class="comment">                 举一个例子，有算式：1-2+3*4</span></span><br><span class="line"><span class="comment">                 当 i = 0, j = 3, k = 1 时，实际上就相当于计算这样一个算式的值：(1-2)+(3*4)，然后 push_back 到 dp[0][3] 里面</span></span><br><span class="line"><span class="comment">                 这样计数可以保证不重不漏</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; i; k += <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> left : dp[j][k]) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span> right : dp[k+<span class="number">1</span>][i]) &#123;</span><br><span class="line">                            <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">switch</span> (ops[k]) &#123;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: val = left + right; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: val = left - right; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: val = left * right; <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            dp[j][i].<span class="built_in">push_back</span>(val);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="漂亮数组"><a href="#漂亮数组" class="headerlink" title="漂亮数组"></a><a href="https://leetcode.cn/problems/beautiful-array/">漂亮数组</a></h3><p><strong>题目描述：</strong></p><p>对于某些固定的 N，如果数组 A 是整数 1, 2, …, N 组成的排列，使得：对于每个 i &lt; j，都不存在 k 满足 i &lt; k &lt; j 使得 A[k] * 2 = A[i] + A[j]。那么数组 A 是漂亮数组。</p><p>给定 N，返回任意漂亮数组 A（保证存在一个）。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：4<br>输出：[2,1,4,3]</p></blockquote><p>示例 2：</p><blockquote><p>输入：5<br>输出：[3,1,2,5,4]</p></blockquote><p><strong>题解：</strong></p><p>观察表达式，发现左边恒为偶数，则要不满足，只需右边一奇一偶即可，所以可以把数组一分为二，奇数放左边，偶数放右边，现在只要左右两边分别是漂亮数组即可，则 1~N 的奇数或偶数分别可以双射到 1~(N+1)/2 和 1~N/2 的整数，容易证明，映射不影响漂亮数组的性质，所以问题被分解为两个更小规模的子问题，递归处理即可</p><p><strong>代码：</strong></p><p>带 memoization 的分治法，自上而下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; memo;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memo.<span class="built_in">count</span>(n))</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)  </span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x : <span class="built_in">beautifulArray</span>((n + <span class="number">1</span>) / <span class="number">2</span>))</span><br><span class="line">            res[t++] = <span class="number">2</span> * x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x : <span class="built_in">beautifulArray</span>(n / <span class="number">2</span>))</span><br><span class="line">            res[t++] = <span class="number">2</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以动态规划，自下而上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    dp[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    dp[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i + <span class="number">1</span>) / <span class="number">2</span>; j++)</span><br><span class="line">            dp[i].<span class="built_in">push_back</span>(dp[(i+<span class="number">1</span>)/<span class="number">2</span>][j] * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i / <span class="number">2</span>; j++)</span><br><span class="line">            dp[i].<span class="built_in">push_back</span>(dp[i/<span class="number">2</span>][j] * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode.cn/problems/burst-balloons/">戳气球</a></h3><p><strong>题目描述：</strong></p><p>有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] <em> nums[i] </em> nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [3,1,5,8]<br>输出：167</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,5]<br>输出：10</p></blockquote><p><strong>题解：</strong></p><p>为方便处理，把数组两端加上 nums[-1] 和 nums[n]，都等于 1，并保存在 rec 中，即 rec[i] = nums[i-1]，戳气球会导致原本不相邻的气球变成相邻的，所以我们反向考虑，添加气球，定义 solve(i, j) 表示在区间 (i, j) 内可获得的最大硬币数，则可以取一个中间的点 mid（这个mid必须放在最后戳破，因为只有这样可以消除两个子问题的相关性）分别求 solve(i, mid) 和 solve(mid, j)，然后相加即可，于是把原问题分解为了一个个子问题。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp; <span class="comment">//记忆化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rec; <span class="comment">//记录气球值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    rec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        rec.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    rec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    dp.<span class="built_in">resize</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">0</span>, n + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (dp[l][r] != <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mid = l + <span class="number">1</span>; mid &lt; r; mid++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = rec[mid] * rec[l] * rec[r];</span><br><span class="line">        sum += <span class="built_in">solve</span>(l, mid) + <span class="built_in">solve</span>(mid, r);</span><br><span class="line">        dp[l][r] = <span class="built_in">max</span>(sum, dp[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l][r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以使用自下而上的动态规划（dp[i][j] 表示 (i, j) 范围内最大硬币数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="type">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                sum += dp[i][k] + dp[k][j];</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法解释&quot;&gt;&lt;a href=&quot;#算法解释&quot; class=&quot;headerlink&quot; title=&quot;算法解释&quot;&gt;&lt;/a&gt;算法解释&lt;/h2&gt;&lt;p&gt;顾名思义，分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合</summary>
      
    
    
    
    <category term="算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="分治法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
    <category term="分治法" scheme="https://liano.top/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://liano.top/posts/a80d0031/"/>
    <id>https://liano.top/posts/a80d0031/</id>
    <published>2022-08-22T08:59:10.858Z</published>
    <updated>2022-08-23T08:59:07.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>动态规划（Dynamic Programming, DP）在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间</p><p>通俗一点来讲，动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规划问题的关键是找到状态转移方程，这样我们可以通过计算和储存子问题的解来求解最终问题。同时，我们也可以对动态规划进行空间压缩，起到节省空间消耗的效果。这一技巧笔者将在之后的题目中介绍。</p><p>在一些情况下，动态规划可以看成是带有状态记录（memoization）的优先搜索。状态记录的意思为，如果一个子问题在优先搜索时已经计算过一次，我们可以把它的结果储存下来，之后遍历到该子问题的时候可以直接返回储存的结果。动态规划是自下而上的，即先解决子问题，再解决父问题；而用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索到同一个子问题则进行状态记录，防止重复计算。如果题目需求的是最终状态，那么使用动态规划比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。</p><h2 id="一维dp"><a href="#一维dp" class="headerlink" title="一维dp"></a>一维dp</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h3><p><strong>题目描述：</strong></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：n = 2<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 3<br>输出：3</p></blockquote><p><strong>题解：</strong></p><p>问题可以分解为两大类，第一类，最后一步爬了两个台阶，第二类，最后一步爬了一个台阶。设 $f(k)$ 为上到 k 阶台阶的总方案数，则状态转移方程为 $f(k)=f(k-1)+f(k-2)$</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，就是斐波那契数列问题，可以进行空间压缩，重复利用存储空间，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur = pre1 + pre2;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h3><p><strong>题目描述：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p><p><strong>测试样例：</strong> </p><p>示例 1：</p><blockquote><p>输入：[1,2,3,1]<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：[2,7,9,3,1]<br>输出：12</p></blockquote><p><strong>题解：</strong></p><p>设共有 k 个房间，有两种获得最高总金额的可能。</p><p>一是偷了第 k 个房间，总金额为前 k-2 个房间的最高总金额加上第 k 个房间的金额；二是没偷第 k 个房间，总金额为前 k-1 个房间的最高总金额，取两者中的较大者。设最高总金额为 $f(k)$，则状态转移方程为 $f(k)=max(f(k-2)+value[k],\quad f(k-1))$.</p><p>边界条件为 $f(1)=value[1] ,\quad f(2)=max(value[1],\quad value[2]).$</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; size; i++)</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以进行空间压缩，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur = <span class="built_in">max</span>(pre2 + nums[i], pre1);</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等差数列划分"><a href="#等差数列划分" class="headerlink" title="等差数列划分"></a><a href="https://leetcode.cn/problems/arithmetic-slices/">等差数列划分</a></h3><p><strong>题目描述：</strong></p><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。给你一个整数数组 nums，返回数组 nums 中所有为等差数组的子数组个数。</p><p>子数组是数组中的一个连续序列。</p><p><strong>测试样例</strong>：</p><p>示例 1：</p><blockquote><p>输入：nums = [1,2,3,4]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1]<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i]-num[i-1] = num[i-1]-num[i-2]。定义以数字 nums[i] 结尾的等差子数组个数为 dp[i]，最后对 dp 数组求和即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">3</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] - nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>] - nums[i<span class="number">-2</span>])</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h2><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h3><p><strong>题目描述：</strong></p><p>给定一个包含非负整数的 m x n 网格 grid，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7</p></blockquote><p>示例 2：</p><blockquote><p>输入：grid = [[1,2,3],[4,5,6]]<br>输出：12</p></blockquote><p><strong>题解：</strong></p><p>二维dp就建立二维数组，dp[i][j] 表示从左上角到位置 [i,j] 的最小路径和，</p><p>状态转移方程为 $dp[i][j]=min(dp[i-1][j],\quad dp[i][j-1])+grid[i][j]$，注意边界。</p><p>边界条件为 $dp[0][0]=grid[0][0]$.</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = grid[i][j]; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j]; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以进行空间压缩至一维，因为 dp 矩阵的每一个值只和左边和上面的值相关，当我们遍历到第 i 行第 j 列时，第 j-1 列已经更新过了，现在的 dp[j-1] 代表 dp[i][j-1] 的值；d[j] 待更新，现在的 dp[j] 代表 dp[i-1][j] 的值。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[j] = grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[j] = dp[j] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“01”矩阵"><a href="#“01”矩阵" class="headerlink" title="“01”矩阵"></a><a href="https://leetcode.cn/problems/01-matrix/">“01”矩阵</a></h3><p><strong>题目描述：</strong></p><p>给定一个由 0 和 1 组成的矩阵 mat，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。两个相邻元素间的距离为 1。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：mat = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：[[0,0,0],[0,1,0],[0,0,0]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：mat = [[0,0,0],[0,1,0],[1,1,1]]<br>输出：[[0,0,0],[0,1,0],[1,2,1]]</p></blockquote><p><strong>题解：</strong></p><p>dp[i][j] 表示位置 [i,j] 的元素到最近的 0 的距离，如果限制只能向右下搜索，则状态转移方程为：</p><script type="math/tex; mode=display">dp[i][j]=\begin{cases} 1+min(dp[i-1][j], \quad dp[i][j-1]),  & mat[i][j]=1 \\0, & mat[i][j]=0\end{cases}</script><p>左上同理，取最小值即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, INT_MAX - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//这样写就不用单独写特例了</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i<span class="number">-1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; m - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i+<span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">最大正方形</a></h3><p><strong>题目描述：</strong></p><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：matrix = [[“0”,”1”],[“1”,”0”]]<br>输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：matrix = [[“0”]]<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>dp[i][j] 为以 [i,j] 为右下角的正方形的最大边长，若 matrix[i][j] = 0，则 dp[i][j] = 0；否则我们假设 dp[i][j] = k，其充分条件为 dp[i-1][j-1]、dp[i][j-1] 和 dp[i-1][j] 的值必须都不小于 k−1，否则 [i,j] 位置不可以构成一个面积为 $k^2$ 的正方形。同理，如果这三个值中的最小值为 k−1，则 [i,j] 位置一定且最大可以构成一个面积为 $k^2$ 的正方形。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), max_side = <span class="number">0</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">max_side = <span class="built_in">max</span>(max_side, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_side * max_side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割类型题"><a href="#分割类型题" class="headerlink" title="分割类型题"></a>分割类型题</h2><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h3><p><strong>题目描述：</strong></p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>给你一个整数 n，返回和为 n 的完全平方数的最少数量。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：n = 12<br>输出：3 </p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 13<br>输出：2</p></blockquote><p><strong>题解：</strong></p><p>对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。我们定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 最少可以由几个完全平方数相加构成。在本题中，位置 i 只依赖 $i - k^2$ 的位置，如 i - 1、i - 4、i - 9 等等，才能满足完全平方分割的条件。因此，状态转移方程为：</p><script type="math/tex; mode=display">dp[i]=1+min(dp[i-1],dp[i-4],dp[i-9]······)</script><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++)</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/">解码方法</a></h3><p><strong>题目描述：</strong></p><p>一条包含字母 A-Z 的消息通过以下映射进行了编码：</p><blockquote><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”</p></blockquote><p>要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><blockquote><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)</p></blockquote><p>注意，消息不能分组为 (1 11 06)，因为 “06” 不能映射为 “F”，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的非空字符串 s，请计算并返回解码方法的总数 。</p><p>题目数据保证答案肯定是一个 32 位的整数。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：s = “12”<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “226”<br>输出：3</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = “0”<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>就是要把一个大数字分割为一堆 1-26 的数字，设 dp[i] 表示字符串前 i 个字符的解码方法数，则状态转移方程为：</p><script type="math/tex; mode=display">dp[i]=\begin{cases}dp[i-1], & s[i] \neq 0 \\dp[i-2], & s[i-1] \neq 0 \quad\&\quad s[i-1]*10+s[i]<=26\end{cases}</script><p>重叠部分叠加即可，注意数组下标从 0 开始。边界条件为 dp[0] = 1。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i<span class="number">-1</span>] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            dp[i] += dp[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s[i<span class="number">-2</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; (s[i<span class="number">-2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)</span><br><span class="line">            dp[i] += dp[i<span class="number">-2</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">单词拆分</a></h3><p><strong>题目描述：</strong></p><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s。s 和 wordDict[i] 仅有小写英文字母组成，wordDict 中的所有字符串互不相同。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true</p></blockquote><p>示例 2：</p><blockquote><p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true</p></blockquote><p>示例 3：</p><blockquote><p>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p></blockquote><p><strong>题解：</strong></p><p>能否拼接，可以转化为能否拆分，类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。注意对于位置 0，需要初始化值为真。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string &amp; word: wordDict) &#123;</span><br><span class="line">            <span class="type">int</span> len = word.<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len &amp;&amp; s.<span class="built_in">substr</span>(i - len, len) == word)</span><br><span class="line">                dp[i] = dp[i] || dp[i - len];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数数组 nums，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [0,1,0,3,2,3]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p></blockquote><p><strong>题解：</strong></p><p>对于子序列问题，第一种动态规划方法是，定义一个 dp 数组，其中 dp[i] 表示以 i 结尾的符合某性质的子序列的个数。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。</p><p>在本题中，dp[i] 可以表示以 i 结尾的、最长递增子序列长度。对于每一个位置 i，如果其之前的某个位置 j 所对应的数字小于位置 i 所对应的数字，则我们可以获得一个以 i 结尾的、长度为 dp[j]+1 的子序列。为了遍历所有情况，我们需要 i 和 j 进行两层循环，其时间复杂度为 O($n^2$)。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_length = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题还可以使用二分查找将时间复杂度降低为 O(n log n)。我们定义一个 dp 数组，其中 dp[k] 存储长度为 k+1 的最长递增子序列的最后一个数字。我们遍历每一个位置 i，如果其对应的数字大于 dp 数组中所有数字的值，那么我们把它放在 dp 数组尾部，表示最长递增子序列长度加 1；如果我们发现这个数字在 dp 数组中比数字 a 大、比数字 b 小，则我们将 b 更新为此数字，使得之后构成递增序列的可能性增大。以这种方式维护的 dp 数组永远是递增的，因此可以用二分查找加速搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">    dp.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp.<span class="built_in">back</span>() &lt; nums[i])</span><br><span class="line">            dp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> itr = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[i]);</span><br><span class="line">            *itr = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></h3><p><strong>题目描述：</strong></p><p>给定两个仅由小写英文字母组成的字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。</p><p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p><p>两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3  </p></blockquote><p>示例 2：</p><blockquote><p>输入：text1 = “abc”, text2 = “abc”<br>输出：3</p></blockquote><p>示例 3：</p><blockquote><p>输入：text1 = “abc”, text2 = “def”<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>对于子序列问题，第二种动态规划方法是，定义一个 dp 数组，其中 dp[i] 表示到位置 i 为止的子序列的性质，并不必须以 i 结尾。这样 dp 数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。</p><p>在本题中，我们可以建立一个二维数组 dp，其中 dp[i][j] 表示到第一个字符串位置 i 为止、到第二个字符串位置 j 为止、最长的公共子序列长度。这样一来我们就可以很方便地分情况讨论这两个位置对应的字母相同与不同的情况了。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包问题是一种组合优化的 NP 完全问题：有 N 个物品和容量为 W 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为无界背包问题或完全背包问题。</p><h3 id="1-“0-1”背包问题"><a href="#1-“0-1”背包问题" class="headerlink" title="1.“0-1”背包问题"></a>1.“0-1”背包问题</h3><p>我们可以用动态规划来解决背包问题。以 0-1 背包问题为例。我们可以定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，如果我们不将物品 i 放入背包，那么 dp[i][j] = dp[i-1][j]，即前 i 个物品的最大价值等于只取前 i-1 个物品时的最大价值；如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 dp[i][j] = dp[i-1][j-w] + v。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为 O(NW)。</p><p><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)</code></p><p>转化为代码语言如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w] + v);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以进一步对 0-1 背包进行空间优化，将空间复杂度降低为 O(W)。从状态转移方程可以看出，考虑第 i 个物品时，只与上一行有关，因此我们可以去掉 dp 矩阵的第一个维度，在考虑物品 i 时变成 dp[j] = max(dp[j], dp[j-w] + v)。这里要注意我们在遍历每一行的时候必须<strong>逆向遍历</strong>，这样才能够调用上一行物品 i-1 时 dp[j-w] 的值；若按照从左往右的顺序进行正向遍历，则 dp[j-w] 的值在遍历到 j 之前就已经被更新成物品 i 的值了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = W; j &gt;= w; j--)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h3><p>在完全背包问题中，一个物品可以拿多次。假设物品体积均为 2，假设我们遍历到物品 i = 2 且其体积为 w = 2，价值为 v = 3；对于背包容量 j = 5，最多只能装下 2 个该物品。那么我们的状态转移方程就变成了 dp[2][5] = max(dp[1][5], dp[1][3] + 3, dp[1][1] + 6)。如果采用这种方法，假设背包容量无穷大而物体的体积无穷小，我们这里的比较次数也会趋近于无穷大，远超 O(NW) 的时间复杂度。</p><p>怎么解决这个问题呢？我们发现在 dp[2][3] 的时候我们其实已经考虑了 dp[1][3] 和 dp[2][1] 的情况，而在 dp[2][1] 也已经考虑了 dp[1][1] 的情况。因此，对于拿多个物品的情况，我们只需考虑 dp[2][3] 即可，即 dp[2][5] = max(dp[1][5], dp[2][3] + 3)。这样，我们就得到了完全背包问题的状态转移方程：</p><p><code>dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)</code></p><p>其与 0-1 背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j-w] + v);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以利用空间压缩将时间复杂度降低为 O(W)。这里要注意我们在遍历每一行的时候必须<strong>正向遍历</strong>，因为我们需要利用当前物品在第 j-w 列的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = w; j &lt;= W; j++)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h3><p><strong>题目描述：</strong></p><p>给你一个只包含正整数的非空数组 nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [1,5,11,5]<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,2,3,5]<br>输出：false</p></blockquote><p><strong>题解：</strong></p><p>等价于“0-1”背包问题，输出是否可以取出总和正好为 sum/2 的数字，把数字大小看做体积，不用考虑价值，dp[i][j] 表示是否能正好取出体积为 j 的物品</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(target + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j - nums[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= nums[i<span class="number">-1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></h3><p><strong>题目描述：</strong></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n。请你找出并返回 strs 的最大子集的长度，该子集最多有 m 个 0 和 n 个 1。如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的子集 。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：strs = [“10”, “0”, “1”], m = 1, n = 1<br>输出：2</p></blockquote><p><strong>题解：</strong></p><p>这里有两个不同维度的体积，dp[i][j][k] 表示在遍历到第 i 个物品时，在 0 的个数小于等于 m，1 的个数小于等于 n 时，所能取到的最大子集长度，则状态转移方程为：</p><script type="math/tex; mode=display">dp[i][j][k]=\begin{cases}dp[i-1][j][k] \\dp[i-1][j-num0][k-num1] + 1\end{cases}</script><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="type">const</span> string &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count0 = s.<span class="built_in">length</span>(), count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; c: s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">            count0--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(count0, count1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = strs.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(length + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [zeros, ones] = <span class="built_in">count</span>(strs[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; zeros || k &lt; ones)</span><br><span class="line">                    dp[i][j][k] = dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j][k] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k], dp[i<span class="number">-1</span>][j-zeros][k-ones] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length][m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数数组 coins，表示不同面额的硬币；以及一个整数 amount，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：coins = [1, 2, 5], amount = 11<br>输出：3 </p></blockquote><p>示例 2：</p><blockquote><p>输入：coins = [2], amount = 3<br>输出：-1</p></blockquote><p>示例 3：</p><blockquote><p>输入：coins = [1], amount = 0<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>完全背包问题，dp[i] 表示总金额为 i 时的最少硬币个数，则状态转移方程为：</p><script type="math/tex; mode=display">dp[i] = \mathop{min}\limits_{j=0,1,···}dp[i-c_j]+1</script><p>因为遍历 j 时会实时更新 dp[i] 的值，所以方程变为：</p><script type="math/tex; mode=display">dp[i]=min(dp[i], dp[i-current\_coin]+1)</script><p>为了避免dp[i]刚开始就被取到，初始值取为amount + 1，同时也可以判断最后是否输出 -1。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coin.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin)</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h2><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h3><p><strong>题目描述：</strong></p><p>给你两个单词 word1 和 word2，请返回将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行三种操作：插入一个字符，删除一个字符，替换一个字符。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：word1 = “horse”, word2 = “ros”<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：word1 = “intention”, word2 = “execution”<br>输出：5</p></blockquote><p><strong>题解：</strong></p><p>类似于题目 1143，我们使用一个二维数组 dp[i][j]，表示将第一个字符串到位置 i 为止，和第二个字符串到位置 j 为止，最多需要几步编辑。当第 i 位和第 j 位对应的字符相同时，dp[i][j] 等于 dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是 dp[i-1][j-1] + 1，插入 i 位置/删除 j 位置的消耗是 dp[i][j-1] + 1，插入 j 位置/删除 i 位置的消耗是 dp[i-1][j] + 1。边界条件为 dp[0][j] = j，dp[i][0] = i</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + ((word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) ? <span class="number">0</span> : <span class="number">1</span>), <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>] + <span class="number">1</span>, dp[i<span class="number">-1</span>][j] + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a><a href="https://leetcode.cn/problems/2-keys-keyboard/">只有两个键的键盘</a></h3><p><strong>题目描述：</strong></p><p>最初记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p><blockquote><p>Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br>Paste（粘贴）：粘贴上一次复制的字符。</p></blockquote><p>给你一个数字 n，你需要使用最少的操作次数，在记事本上输出恰好 n 个 ‘A’。返回能够打印出 n 个 ‘A’ 的最少操作次数。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：3<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：1<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。设 dp[i] 表示得到 i 个 ‘A’ 的最少操作数，要得到 i 个，对于 i 的因子 j，从 j 个到 i 个最少操作次数等价于 1 到 i/j，即 dp[i/j]，从 1 到 j 最少操作次数为 dp[j]，所以状态转移方程为：</p><script type="math/tex; mode=display">dp[i]=dp[j]+dp[i/j]</script><p>若 i 为素数，则只能通过一次复制，若干次粘贴得到，故边界条件为 dp[i] = i。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSteps</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[j] + dp[i/j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a></h3><p><strong>题目描述：</strong></p><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><blockquote><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素</p></blockquote><p>所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。</p><p>示例 1：</p><blockquote><p>输入：s = “aa”, p = “a”<br>输出：false</p></blockquote><p>示例 2:</p><blockquote><p>Input: s = “aab”, p = “c*a*b”<br>Output: true<br>我们可以重复 c 零次，重复 a 两次。</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = “ab”, p = “.*“<br>输出：true</p></blockquote><p>提示：</p><ul><li>s 只包含从 a-z 的小写字母。</li><li>p 只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><p><strong>题解：</strong></p><p>我们可以使用一个二维数组 dp，其中 dp[i][j] 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。根据正则表达式的不同情况，即字符、星号，点号，我们可以分情况讨论来更新 dp 数组。状态转移方程如下：</p><script type="math/tex; mode=display">dp[i][j]=\begin{cases}    p[j]为小写字母\begin{cases}        dp[i-1][j-1], & s[i] = p[j] \\        false, & s[i] \neq p[j]    \end{cases} \\    p[j]='.', \quad dp[i-1][j-1] \\    p[j]='*'\begin{cases}    dp[i][j-2], & s[i] \neq p[j-1] \\    dp[i-1][j] \quad or \quad dp[i][j-2], & s[i]=p[j-1],(包含p[j-1]='.')    \end{cases}\end{cases}</script><p>其中 p[j] = ‘*’ 时的情况比较复杂，本质上只有两种操作方式：</p><ul><li>匹配一次后继续向前匹配，即 dp[i-1][j]，s[i]=s[i-1]=···=p[j-1]的情况。</li><li>匹配0次，扔掉p[j-1]和’*’，继续比较，即 dp[i][j-2]。</li></ul><p>代码如下，注意数组下标。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>(), i, j;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">//空串能够匹配</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[i][j] |= dp[i][j<span class="number">-2</span>];<span class="comment">//*匹配0次前面的字符</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">match</span>(s,p,i,j<span class="number">-1</span>)) <span class="comment">//s第i个和p的第j-1个可以匹配, *匹配再多匹配一次i字符</span></span><br><span class="line">                    dp[i][j] |= dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">match</span>(s,p,i,j))<span class="comment">//必须是i、j能够匹配</span></span><br><span class="line">                    dp[i][j] |= dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string &amp;s, string &amp;p, <span class="type">int</span> i, <span class="type">int</span> j)</span>  </span>&#123;   <span class="comment">//第i,j个字符能匹配</span></span><br><span class="line">    <span class="keyword">return</span> i&gt;<span class="number">0</span> &amp;&amp; (p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span> || p[j<span class="number">-1</span>] == s[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h2><h3 id="买卖股票的最佳时期"><a href="#买卖股票的最佳时期" class="headerlink" title="买卖股票的最佳时期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时期</a></h3><p><strong>题目描述：</strong></p><p>给定一个数组 prices，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：[7,1,5,3,6,4]<br>输出：5</p></blockquote><p>示例 2：</p><blockquote><p>输入：prices = [7,6,4,3,1]<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>我们可以遍历一遍数组，在每一个位置 i 时，记录 i 位置之前所有价格中的最低价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; dp[i])</span><br><span class="line">            dp[i+<span class="number">1</span>] = prices[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - dp[i+<span class="number">1</span>] &gt; max)</span><br><span class="line">                max = prices[i] - dp[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上记录最低价用一个变量即可，这里只是为了DP而DP</p></blockquote><h3 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机IV</a></h3><p><strong>题目描述：</strong></p><p>给定一个整数数组 prices，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：k = 2, prices = [2,4,1]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：k = 2, prices = [3,2,6,5,0,3]<br>输出：7</p></blockquote><p><strong>题解：</strong></p><p>如果 k 大于总天数的一半，那么我们一旦发现可以赚钱就可以进行买卖；这里一半的原因是因为当天股价是不变的，因此一次买卖需要两天。如果 k 小于总天数，我们用 buy[i][j] 表示对于数组 prices[0..i] 中的价格而言，进行恰好 j 笔交易，并且当前手上持有一支股票，这种情况下的最大利润；用 sell[i][j] 表示恰好进行 j 笔交易，并且当前手上不持有股票，这种情况下的最大利润。</p><blockquote><p>为了方便分析，买入不算交易，卖出才算一次交易</p></blockquote><p>那么我们可以对状态转移方程进行推导。对于 buy[i][j]，我们考虑当前手上持有的股票是否是在第 i 天买入的。可以得到状态转移方程：</p><script type="math/tex; mode=display">buy[i][j]=max(buy[i−1][j],sell[i−1][j]−price[i])</script><p>同理对于 sell[i][j]，我们可以得到状态转移方程：</p><script type="math/tex; mode=display">sell[i][j]=max(sell[i−1][j],buy[i−1][j−1]+price[i])</script><p>在上述的状态转移方程中，确定边界条件是非常重要的步骤。我们可以考虑将所有的 buy[0][0..k] 以及 sell[0][0..k] 设置为边界。</p><p>对于 buy[0][0..k]，由于只有 prices[0] 唯一的股价，因此我们不可能进行过任何交易，那么我们可以将所有的 buy[0][1..k] 设置为一个非常小的值，表示不合法的状态。而对于 buy[0][0]，它的值为 −prices[0]，即「我们在第 0 天以 prices[0] 的价格买入股票」是唯一满足手上持有股票的方法。</p><p>同理我们可以将所有的 sell[0][1..k] 设置为一个非常小的值，表示不合法的状态。而对于 sell[0][0]，它的值为 0，即「我们在第 0 天不做任何事」是唯一满足手上不持有股票的方法。</p><p>在设置完边界之后，我们就可以使用二重循环，在 i∈[1,n),j∈[0,k] 的范围内进行状态转移。需要注意的是，sell[i][j] 的状态转移方程中包含 buy[i−1][j−1]，在 j=0 时其表示不合法的状态，因此在 j=0 时，我们无需对 sell[i][j] 进行转移，让其保持值为 0 即可。</p><blockquote><p>注意，不一定交易次数多了就利润高</p></blockquote><p><strong>题解：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> days = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (days &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k * <span class="number">2</span> &gt;= days)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxProfitUnlimited</span>(prices);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(k + <span class="number">1</span>, INT_MIN)</span>, <span class="title">sell</span><span class="params">(k + <span class="number">1</span>, INT_MIN/<span class="number">2</span>)</span></span>;</span><br><span class="line">    buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            buy[j] = <span class="built_in">max</span>(buy[j], sell[j] - prices[i]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                sell[j] = <span class="built_in">max</span>(sell[j], buy[j<span class="number">-1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(sell.<span class="built_in">begin</span>(), sell.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfitUnlimited</span><span class="params">(vector&lt;<span class="type">int</span>&gt; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i<span class="number">-1</span>])</span><br><span class="line">            maxProfit += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票之含冷冻期"><a href="#买卖股票之含冷冻期" class="headerlink" title="买卖股票之含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">买卖股票之含冷冻期</a></h3><p><strong>题目描述：</strong></p><p>给定一个整数数组 prices，其中第 prices[i] 表示第 i 天的股票价格。设计一个算法计算出最大利润。</p><p>在满足以下约束条件下，你可以尽可能地完成更多的交易：卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: prices = [1,2,3,0,2]<br>输出: 3 </p></blockquote><p>示例 2:</p><blockquote><p>输入: prices = [1]<br>输出: 0</p></blockquote><p><strong>题解：</strong></p><p>考虑第 i 天结束后的情况，有三种状态：</p><ul><li>手里有一支股票，最大收益用 dp[i][0] 表示</li><li>手里没有股票，今天刚卖掉，明天处于冷冻期，最大收益用 dp[i][1] 表示</li><li>手里没有股票，早就卖掉了，明天不是冷冻期，最大收益用 dp[i][2] 表示</li></ul><p>则状态转移方程为：</p><script type="math/tex; mode=display">\begin{align*}dp[i][0]&=max(dp[i-1][0], dp[i-1][2]-prices[i]) \\dp[i][1]&=dp[i-1][0]+prices[i] \\dp[i][2]&=max(dp[i-1][1], dp[i-1][2])\end{align*}</script><p>因为最后一天持有股票显然不是最大收益，所以最终答案为 max(dp[n][1], dp[n][2]);</p><p>考虑边界条件:</p><script type="math/tex; mode=display">\begin{align}dp[1][0]&=-prices[0] \\dp[1][1]&=0 \\dp[1][2]&=0\end{align}</script><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] - prices[i<span class="number">-1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i<span class="number">-1</span>];</span><br><span class="line">        dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用状态机来解决这类复杂的状态转移问题，通过建立多个状态以及它们的转移方式，我们可以很容易地推导出各个状态的转移方程。如图所示，我们可以建立四个状态来表示带有冷却的股票交易，以及它们的之间的转移方式。</p><p><img src="https://s2.loli.net/2022/08/05/nrGIsifHb49WAM7.png" alt="image-20220805103940231.png" style="zoom:33%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(n)</span>, <span class="title">sell</span><span class="params">(n)</span>, <span class="title">s1</span><span class="params">(n)</span>, <span class="title">s2</span><span class="params">(n)</span></span>;</span><br><span class="line">    s1[<span class="number">0</span>] = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        buy[i] = s2[i<span class="number">-1</span>] - prices[i];</span><br><span class="line">        s1[i] = <span class="built_in">max</span>(buy[i<span class="number">-1</span>], s1[i<span class="number">-1</span>]);</span><br><span class="line">        sell[i] = <span class="built_in">max</span>(buy[i<span class="number">-1</span>], s1[i<span class="number">-1</span>]) + prices[i];</span><br><span class="line">        s2[i] = <span class="built_in">max</span>(s2[i<span class="number">-1</span>], sell[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(sell[n<span class="number">-1</span>], s2[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍II</a></h3><p><strong>题目描述：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，今晚能够偷窃到的最高金额。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [2,3,2]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,2,3,1]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：3</p></blockquote><p><strong>题解：</strong></p><p>与之前的区别在于若偷了第一间，则偷窃范围为1 ~ n-1，若没偷第一间，则偷窃范围为2 ~ n</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp1</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">dp2</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp1[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp2[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp1[i] = <span class="built_in">max</span>(dp1[i<span class="number">-2</span>] + nums[i<span class="number">-1</span>], dp1[i<span class="number">-1</span>]);</span><br><span class="line">        dp2[i] = <span class="built_in">max</span>(dp2[i<span class="number">-2</span>] + nums[i], dp2[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp1[n<span class="number">-1</span>], dp2[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1]<br>输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [5,4,-1,7,8]<br>输出：23</p></blockquote><p><strong>题解：</strong></p><p>dp[i] 表示以 nums[i] 结尾的连续子数组的最大和，则 <script type="math/tex">dp[i] = max(dp[i-1] + nums[i], nums[i])</script></p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>] + nums[i], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将一维空间压缩为常量，考虑到 dp[i] 只和 dp[i-1] 相关，于是我们可以只用一个变量 pre 来维护对于当前 dp[i] 的 dp[i-1] 的值是多少，从而让空间复杂度降低到 O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> pre = nums[<span class="number">0</span>], cur, Max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur = <span class="built_in">max</span>(pre + nums[i], nums[i]);</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; Max)</span><br><span class="line">            Max = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">整数拆分</a></h3><p><strong>题目描述：</strong></p><p>给定一个正整数 n，将其拆分为 k 个正整数的和（k &gt;= 2），并使这些整数的乘积最大化。返回你可以获得的最大乘积。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: n = 2<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: n = 10<br>输出: 36</p></blockquote><p><strong>题解：</strong></p><p>设 dp[i] 表示将 i 拆分后的最大乘积，假设将 i 拆分为 j 和 i-j，或者继续拆分，取较大值即可，即 <script type="math/tex">dp[i]=\mathop{max}\limits_{0<j<i}(j\times (i-j), j\times dp[i-j])</script></p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            Max = <span class="built_in">max</span>(Max, <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">        dp[i] = Max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></h3><p><strong>题目描述：</strong></p><p>给定两个单词 word1 和 word2，返回使得 word1 和  word2 相同所需的最小步数。每步可以删除任意一个字符串中的一个字符。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2</p></blockquote><p>示例  2:</p><blockquote><p>输入：word1 = “leetcode”, word2 = “etco”<br>输出：4</p></blockquote><p><strong>题解：</strong></p><p>dp[i][j] 表示使 word1[0:i] 和 word2[0:j] 相同的最少删除操作次数。</p><script type="math/tex; mode=display">\begin{align*}dp[i][j]&=\begin{cases}dp[i-1][j-1], & word1[i]=word2[j]\\min(dp[i-1][j], dp[i][j-1])+1, & word1[i]\neq word2[j]\end{cases}\\dp[0][j]&=j; \\ dp[i][0]&=i;\end{align*}</script><blockquote><p>上述表示中，word[0:i]表示前 i 个元素</p></blockquote><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">size</span>(), n = word2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩到一维，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">size</span>(), n = word2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        dp[j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> last = dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> old = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[j] = last;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            last = old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里用last记录dp[i-1][j-1]，因为在正向遍历中它会先被更新为dp[i][j-1]</p></blockquote><h3 id="最长数对链"><a href="#最长数对链" class="headerlink" title="最长数对链"></a><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/">最长数对链</a></h3><p><strong>题目描述：</strong></p><p>给出 n 个数对。在每一个数对中，第一个数字总是比第二个数字小。现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p><p>给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p><p><strong>测试样例：</strong></p><p>示例：</p><blockquote><p>输入：[[1,2], [2,3], [3,4]]<br>输出：2<br>解释：最长的数对链是 [1,2] -&gt; [3,4]</p></blockquote><p><strong>题解：</strong></p><p>dp[i] 表示以数对 i 结尾的最长数对链长度，则当 j &gt; i 且 pairs[i][1] &lt; pairs[j][0] 时有 <script type="math/tex">dp[j]=max(dp[j], dp[i]+1)</script></p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestChain</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> n = pairs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs[i][<span class="number">1</span>] &lt; pairs[j][<span class="number">0</span>])</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a></h3><p><strong>题目描述：</strong></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如，[1, 7, 4, 9, 2, 5] 是一个摆动序列，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums，返回 nums 中作为摆动序列的最长子序列的长度。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [1,7,4,9,2,5]<br>输出：6</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1,2,3,4,5,6,7,8,9]<br>输出：2</p></blockquote><p><strong>题解：</strong></p><p>up[i] 表示范围 0~i 最长摆动子序列长度，末尾向上摆，down[i] 表示末尾向下摆，则</p><script type="math/tex; mode=display">\begin{align*}up[i]&=\begin{cases}up[i-1] & nums[i]≤nums[i-1] \\max(up[i-1], down[i-1]+1) & nums[i]>nums[i-1]\end{cases}\\down[i]&=\begin{cases}down[i-1] & nums[i]≥nums[i-1] \\max(down[i-1], up[i-1]+1) & nums[i]<nums[i-1]\end{cases}\\up[0]&=down[0]=1\end{align*}</script><p>这里的状态转移方程可能很难理解，下面证明一下 up[i] 的式子，down同理：</p><p>当 nums[i]&lt;=nums[i-1] 时，找不到比 up[i-1] 更长的了，因为任意以 nums[i] 结尾的末尾向上摆的都可以把 nums[i] 换成 nums[i-1]，且若不以 nums[i] 结尾，就等价于 up[i-1]，所以 up[i] = up[i-1]；</p><p>当 nums[i]&gt;nums[i-1]，如果不取 nums[i]，则 up[i]=up[i-1]，如果取 nums[i]，则分别考虑如何从 up[i-1] 和 down[i-1] 转移过来，如果从 up[i-1] 转移过来，那么必须经过 down[i-1]，所以只考虑 down[i-1] 即可，设末尾元素为 nums[j]，若nums[j]&gt;=nums[i-1]，则可以替换为nums[i-1]，后面接上 nums[i]，若 nums[j]&lt;nums[i-1]，则可以直接在后面加上 nums[i]，总之就是 up[i] = down[i-1] + 1；</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span> &amp;&amp; nums[<span class="number">0</span>] != nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">down</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            up[i] = <span class="built_in">max</span>(down[i<span class="number">-1</span>] + <span class="number">1</span>, up[i<span class="number">-1</span>]);</span><br><span class="line">            down[i] = down[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            down[i] = <span class="built_in">max</span>(up[i<span class="number">-1</span>] + <span class="number">1</span>, down[i<span class="number">-1</span>]);</span><br><span class="line">            up[i] = up[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            up[i] = up[i<span class="number">-1</span>];</span><br><span class="line">            down[i] = down[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(up[n<span class="number">-1</span>], down[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然可以压缩为常量空间，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span> &amp;&amp; nums[<span class="number">0</span>] != nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">            up = <span class="built_in">max</span>(down + <span class="number">1</span>, up);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">            down = <span class="built_in">max</span>(up + <span class="number">1</span>, down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(up, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode.cn/problems/target-sum/">目标和</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数数组 nums 和一个整数 target。向数组中的每个整数前添加 ‘+’ 或 ‘-‘，然后串联起所有整数，可以构造一个表达式：</p><p>例如，nums = [2, 1]，可以在 2 之前添加 ‘+’，在 1 之前添加 ‘-‘，然后串联起来得到表达式 “+2-1”。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同表达式的数目。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1], target = 1<br>输出：1</p></blockquote><p><strong>题解：</strong></p><p>一个比较巧妙的方法，只考虑加法，剩下的全部做减法，设总和为 sum，则加法目标和为<script type="math/tex">(sum + target) /2</script>，然后就转化为了“0-1”背包问题。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        n = -n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= nums[i<span class="number">-1</span>]; j--)</span><br><span class="line">            dp[j] += dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票之含手续费"><a href="#买卖股票之含手续费" class="headerlink" title="买卖股票之含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票之含手续费</a></h3><p><strong>题目描述：</strong></p><p>给定一个整数数组 prices，其中 prices[i] 表示第 i 天的股票价格；整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出：8</p></blockquote><p>示例 2：</p><blockquote><p>输入：prices = [1,3,7,5,10,3], fee = 3<br>输出：6</p></blockquote><p><strong>题解：</strong></p><p>第 i 天结束时，dp[i][0] 表示手里没有股票的最大利润，dp[i][1] 表示手里有股票的最大利润，则</p><script type="math/tex; mode=display">\begin{align*}dp[i][0]&=max(dp[i-1][0], dp[i-1][1]+prices[i-1]-fee)\\dp[i][1]&=max(dp[i-1][1], dp[i-1][0]-prices[i-1])\\dp[1][0]&=0 \\dp[1][1] &= -prices[0]\end{align*}</script><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i<span class="number">-1</span>] - fee);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩大法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sell = <span class="number">0</span>, buy = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, buy + prices[i<span class="number">-1</span>] - fee);</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, sell - prices[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法解释&quot;&gt;&lt;a href=&quot;#算法解释&quot; class=&quot;headerlink&quot; title=&quot;算法解释&quot;&gt;&lt;/a&gt;算法解释&lt;/h2&gt;&lt;p&gt;动态规划（Dynamic Programming, DP）在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问</summary>
      
    
    
    
    <category term="算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="DP" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/DP/"/>
    
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
    <category term="DP" scheme="https://liano.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>一切皆可搜索</title>
    <link href="https://liano.top/posts/1b2b09bd/"/>
    <id>https://liano.top/posts/1b2b09bd/</id>
    <published>2022-08-22T08:47:43.167Z</published>
    <updated>2022-08-22T09:53:03.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。</p><p>在大规模实验环境中，通常通过在搜索前，根据条件降低搜索规模；根据问题的约束条件进行剪枝；利用搜索过程中的中间解，避免重复计算这几种方法进行优化。</p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。</p><p>考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“深”的方向前进的策略，假如我们使用递归实现，我们的遍历过程为 1（起始节点）-&gt;2（遍历更深一层的左子节点）-&gt;4（遍历更深一层的左子节点）-&gt;2（无子节点，返回父结点）-&gt;1（子节点均已完成遍历，返回父结点）-&gt;3（遍历更深一层的右子节点）-&gt;1（无子节点，返回父结点）-&gt;结束程序（子节点均已完成遍历）。如果我们使用栈实现，我们的栈顶元素的变化过程为 1-&gt;2-&gt;4-&gt;3。</p><p><img src="https://s2.loli.net/2022/08/04/HjNsDCer1JM5nI3.png" alt="image-20220716220303591.png"></p><p>深度优先搜索也可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存在入度不为零的点，则说明有环。</p><p>有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这种做法叫做状态记录或记忆化（memoization)。</p><h3 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积</a></h3><p><strong>题目描述：</strong></p><p>给你一个大小为 m x n 的二进制矩阵 grid。</p><p>岛屿是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直的四个方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入:<br>[[1,0,1,1,0,1,0,1],<br>[1,0,1,1,0,1,1,1],<br>[0,0,0,0,0,0,0,1]]<br>输出: 6</p></blockquote><p>示例 2：</p><blockquote><p>输入：grid = [[0,0,0,0,0,0,0,0]]<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>此题是十分标准的搜索题，我们可以拿来练手深度优先搜索。一般来说，深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否可以开始搜索，如果可以即在辅函数进行搜索。辅函数则负责深度优先搜索的递归调用。</p><p>当然，我们也可以使用栈（stack）实现深度优先搜索，但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时笔者推荐使用递归式写法，同时也方便进行回溯（见下节）。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。</p><p><strong>代码：</strong></p><h4 id="1-使用栈："><a href="#1-使用栈：" class="headerlink" title="1.使用栈："></a>1.使用栈：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = m ? grid[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> local_area, area = <span class="number">0</span>, x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                local_area = <span class="number">1</span>;</span><br><span class="line">                grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; island;</span><br><span class="line">                island.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                <span class="keyword">while</span> (!island.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [r, c] = island.<span class="built_in">top</span>();</span><br><span class="line">                    island.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        x = r + direction[k];</span><br><span class="line">                        y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m</span><br><span class="line">                            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                            grid[x][y] = <span class="number">0</span>;</span><br><span class="line">                            local_area++;</span><br><span class="line">                            island.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                area = <span class="built_in">max</span>(area, local_area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里我们使用了一个小技巧，对于四个方向的遍历，可以创造一个数组 [-1, 0, 1, 0, -1]，每相邻两位即为上下左右四个方向之一。</p></blockquote><h4 id="2-使用递归："><a href="#2-使用递归：" class="headerlink" title="2.使用递归："></a>2.使用递归：</h4><p>在辅函数里，一个一定要注意的点是辅函数内递归搜索时，边界条件的判定。边界判定一般有两种写法，一种是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。</p><p>第一种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x, y, area = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        x = r + direction[i];</span><br><span class="line">        y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()) </span><br><span class="line">            area += <span class="built_in">dfs</span>(grid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>()</span><br><span class="line">        || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[r][c] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a><a href="https://leetcode.cn/problems/number-of-provinces/">省份数量</a></h3><p><strong>题目描述：</strong></p><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中省份的数量。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：isConnected =<br>[[1,1,0],<br>[1,1,0],<br>[0,0,1]]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：isConnected =<br>[[1,0,0],<br>[0,1,0],<br>[0,0,1]]<br>输出：3</p></blockquote><p><strong>题解：</strong></p><p>实际上与上一题是一样的，上题中矩阵每个元素都可看做一个结点，上下左右相邻即有关系；本题中每一行或列为一个结点，元素为 1 即有关系。这里我们采用第一种递归写法。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; friends)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = friends.<span class="built_in">size</span>(), count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(friends, i, visited);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; friends, <span class="type">int</span> i, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; friends.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (friends[i][k] == <span class="number">1</span> &amp;&amp; !visited[k])</span><br><span class="line">            <span class="built_in">dfs</span>(friends, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="太平洋大西洋水流问题"><a href="#太平洋大西洋水流问题" class="headerlink" title="太平洋大西洋水流问题"></a><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">太平洋大西洋水流问题</a></h3><p><strong>题目描述：</strong></p><p>有一个 m × n 的矩形岛屿，与太平洋和大西洋相邻。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights，heights[r][c] 表示坐标 (r, c) 上单元格高于海平面的高度。</p><p>岛上雨水较多，如果相邻单元格的高度小于或等于当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p><p>返回网格坐标 result 的 2D 列表，其中 result[i] = [ri, ci] 表示雨水从单元格 (ri, ci) 流动既可流向太平洋也可流向大西洋。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入: heights =<br>[[1,2,2,3,5],<br>[3,2,3,4,4],<br>[2,4,5,3,1],<br>[6,7,1,4,5],<br>[5,1,1,2,4]]<br>输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]</p></blockquote><p>示例 2：</p><blockquote><p>输入: heights =<br>[[2,1],<br>[1,2]]<br>输出: [[0,0],[0,1],[1,0],[1,1]]</p></blockquote><p><strong>题解：</strong></p><p>虽然题目要求的是满足向下流能到达两个大洋的位置，如果我们对所有的位置进行搜索，那么在不剪枝的情况下复杂度会很高。因此我们可以反过来想，从两个大洋开始向上流，这样我们只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋向上流都能到达的位置。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">can_reach_p</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">can_reach_a</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, m - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_reach_p[i][j] &amp;&amp; can_reach_a[i][j])</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; can_reach,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (can_reach[r][c])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    can_reach[r][c] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        x = r + direction[i];</span><br><span class="line">        y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>() </span><br><span class="line">            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; matrix[r][c] &lt;= matrix[x][y])</span><br><span class="line">            <span class="built_in">dfs</span>(matrix, can_reach, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便。</p><p>顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。在具体的写法上，它与普通的深度优先搜索一样，都有 [修改当前节点状态]→[递归子节点]的步骤，只是多了回溯的步骤，变成[修改当前节点状态]→[递归子节点]→[回改当前节点状态]。</p><p>两个小诀窍，一是按引用传状态，二是所有的状态修改在递归完成后回改。</p><p>回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标<br>记，比如矩阵里搜字符串。</p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode.cn/problems/permutations/">全排列</a></h3><p><strong>题目描述：</strong></p><p>给定一个不含重复数字的数组 nums ，返回其所有可能的全排列。你可以按任意顺序返回答案。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1]<br>输出：[[1]]</p></blockquote><p><strong>题解：</strong></p><p>按数组序穷举所有可能的排列，已经取过的标记一下，找到一组后向前回溯，取消标记，继续按此方法搜索。                          </p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isIn</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">retSeq</span>(result, temp, nums, <span class="number">0</span>, isIn);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">retSeq</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;result, vector&lt;<span class="type">int</span>&gt; temp, vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> len, vector&lt;<span class="type">int</span>&gt; isIn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == nums.<span class="built_in">size</span>())</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isIn[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                isIn[i] = <span class="number">1</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                len++;</span><br><span class="line">                <span class="built_in">retSeq</span>(result, temp, nums, len, isIn);</span><br><span class="line">                len--;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">                isIn[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里提供一份更简洁优雅的代码，因为数字互不重复，所以穷举所有交换即可。代码框架和上面还是一样的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> level, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, level+<span class="number">1</span>, ans); <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不难看出回溯算法代码框架如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">主函数 &#123;</span><br><span class="line">       定义结果数组;</span><br><span class="line">       调用辅函数(目标数组，结果数组，递归层数);</span><br><span class="line">       返回结果数组;</span><br><span class="line">&#125;</span><br><span class="line">辅函数 &#123;</span><br><span class="line">       递归出口;</span><br><span class="line">       循环 &#123;</span><br><span class="line">           完成当前层的操作;</span><br><span class="line">           递归调用下一层的辅函数;</span><br><span class="line">           回溯当前层的改变量;   </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a><a href="https://leetcode.cn/problems/combinations/">组合</a></h3><p><strong>题目描述：</strong></p><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按任何顺序返回答案。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：n = 4, k = 2<br>输出：<br>[[2,4],<br> [3,4],<br> [2,3],<br> [1,2],<br> [1,3],<br> [1,4]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 1, k = 1<br>输出：[[1]]</p></blockquote><p><strong>题解：</strong></p><p>和上一题区别在于取的数字个数和不考虑取出顺序，第一点只是影响了结果数组大小，第二点可以这样解决：向后取数字，控制取出的组合升序，这样就避免了重复。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">comb</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, comb, count, <span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; comb, <span class="type">int</span>&amp; count, <span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= n; i++) &#123;</span><br><span class="line">        comb[count++] = i;</span><br><span class="line">        <span class="built_in">backtracking</span>(ans, comb, count, i + <span class="number">1</span>, n, k);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">单词搜索</a></h3><p><strong>题目描述：</strong></p><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word。如果 word 存在于网格中，返回 true；否则，返回 false。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：board =<br>[[“A”,”B”,”C”,”E”],<br>[“S”,”F”,”C”,”S”],<br>[“A”,”D”,”E”,”E”]],<br>word = “ABCCED”<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：board =<br>[[“A”,”B”,”C”,”E”],<br>[“S”,”F”,”C”,”S”],<br>[“A”,”D”,”E”,”E”]],<br>word = “ABCB”<br>输出：false</p></blockquote><p><strong>题解：</strong></p><p>在我们对任意位置进行深度优先搜索时，我们先标记当前位置为已访问，以避免重复遍历（如防止向右搜索后又向左返回）；在所有的可能都搜索完成后，再回改当前位置为未访问，防止干扰其它位置搜索到当前位置。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="type">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">backtracking</span>(i, j, board, word, find, visited, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="type">bool</span>&amp; find, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j] || find || board[i][j] != word[pos])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(i + <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i - <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j + <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j - <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><a href="https://leetcode.cn/problems/n-queens/">N皇后</a></h3><p><strong>题目描述：</strong></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 1<br>输出：[[“Q”]]</p></blockquote><p><strong>题解：</strong></p><p>和上一题是类似的，本题也是通过修改状态矩阵来进行回溯。不同的是，我们需要对每一行、列、左斜、右斜建立访问数组，来记录它们是否存在皇后。另外，本题中限制了每一行只有一个皇后，所以不用遍历矩阵中每一个位置，只需遍历每一行即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">column</span><span class="params">(n, <span class="literal">false</span>)</span>, <span class="title">ldiag</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>)</span>, <span class="title">rdiag</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, board, column, ldiag, rdiag, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; &amp;board, vector&lt;<span class="type">bool</span>&gt; &amp;column, vector&lt;<span class="type">bool</span>&gt; &amp;ldiag, vector&lt;<span class="type">bool</span>&gt; &amp;rdiag, <span class="type">int</span> row, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (column[i] || ldiag[n-row+i<span class="number">-1</span>] || rdiag[row+i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        board[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        column[i] = ldiag[n-row+i<span class="number">-1</span>] = rdiag[row+i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(ans, board, column, ldiag, rdiag, row+<span class="number">1</span>, n);</span><br><span class="line">        board[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        column[i] = ldiag[n-row+i<span class="number">-1</span>] = rdiag[row+i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索（breadth-first search，BFS）不同与深度优先搜索，它是一层层进行遍历的，因此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。</p><p>考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“广”的方向前进的策略，队列顶端的元素变化过程为 [1]-&gt;[2-&gt;3]-&gt;[4]，其中方括号代表每一层的元素。</p><p><img src="https://s2.loli.net/2022/08/04/HjNsDCer1JM5nI3.png" alt="image-20220716220303591.png"></p><p>这里要注意，深度优先搜索和广度优先搜索都可以处理可达性问题，即从一个节点开始是否能达到另一个节点。</p><h3 id="最短的桥"><a href="#最短的桥" class="headerlink" title="最短的桥"></a><a href="https://leetcode.cn/problems/shortest-bridge/">最短的桥</a></h3><p><strong>题目描述：</strong></p><p>在给定的二维二进制数组 A 中，存在两座岛（岛是由四面相连的 1 形成的一个最大组）现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。</p><p>返回必须翻转的 0 的最小数目（可以保证答案至少是 1）</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：A = [[0,1],[1,0]]<br>输出：1</p></blockquote><p>示例 2：</p><blockquote><p>输入：A = [[0,1,0],[0,0,0],[0,0,1]]<br>输出：2</p></blockquote><p>示例 3：</p><blockquote><p>输入：A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1</p></blockquote><p><strong>题解：</strong></p><p>本题实际上是求两个岛屿间的最短距离，因此我们可以先通过任意搜索方法找到其中一个岛屿，然后利用广度优先搜索，查找其与另一个岛屿的最短距离。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="type">bool</span> flipped = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//DFS找到第一个岛屿，标记为2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flipped) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(points, grid, m, n, i, j);</span><br><span class="line">                flipped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BFS，一层层向外扩展至找到第二个岛屿</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!points.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="comment">//n_points每减一，队列里就排除一个，减到0说明往外扩一层还没有找到，层数加一，继续扩</span></span><br><span class="line">        <span class="type">int</span> n_points = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (n_points--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = points.<span class="built_in">front</span>();</span><br><span class="line">            points.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                x = r + direction[k];</span><br><span class="line">                y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    points.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == m || j == n || grid[i][j] == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将边界一圈一个个压入队列</span></span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        points.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单词接龙II"><a href="#单词接龙II" class="headerlink" title="单词接龙II"></a><a href="https://leetcode.cn/problems/word-ladder-ii/">单词接龙II</a></h3><p><strong>题目描述：</strong></p><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的转换序列是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p><ul><li>每对相邻的单词之间仅有单个字母不同。</li><li>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</li><li>sk == endWord</li></ul><p>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的最短转换序列，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出：[[“hit”,”hot”,”dot”,”dog”,”cog”],[“hit”,”hot”,”lot”,”log”,”cog”]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出：[]</p></blockquote><p><strong>题解：</strong></p><p>双向BFS构建节点树，再用DFS找出所有通路。</p><p>我们可以把起始字符串、终止字符串、以及单词表里所有的字符串想象成节点。若两个字符串只有一个字符不同，那么它们相连。因为题目需要输出修改次数最少的所有修改方式，因此我们可以使用广度优先搜索，求得起始节点到终止节点的最短距离。</p><p>我们同时还使用了一个小技巧：我们并不是直接从起始节点进行广度优先搜索，直到找到终止节点为止；而是从起始节点和终止节点分别进行广度优先搜索，每次只延展当前层节点数最少的那一端，这样我们可以减少搜索的总结点数。</p><p>在搜索结束后，我们还需要通过回溯法来重建所有可能的路径。</p><p><img src="https://s2.loli.net/2022/08/04/YVpAd2MhqDryFEt.jpg" alt="3df75feb64b7fcf06e76de68a4f4f3aad334b5a586cfbdbd3c4a961ffceba894.jpg" style="zoom:67%;" /></p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, vector&lt;string&gt;&gt; tree;<span class="comment">//节点图，把所有符合只差一个字符的单词联系起来</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; ans;<span class="comment">//存储结果</span></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt; &amp; wordList) &#123;</span><br><span class="line">    <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(wordList.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="built_in">find</span>(wordList.<span class="built_in">begin</span>(), wordList.<span class="built_in">end</span>(), endWord) == wordList.<span class="built_in">end</span>()) </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//双向BFS</span></span><br><span class="line">    <span class="built_in">swap</span>(beginWord, endWord);<span class="comment">//这里交换是为了建立从尾到头的树</span></span><br><span class="line">    unordered_set&lt;string&gt; bfsFromBegin&#123;beginWord&#125;;<span class="comment">//从上到下BFS</span></span><br><span class="line">    unordered_set&lt;string&gt; bfsFromEnd&#123;endWord&#125;;<span class="comment">//从下到上</span></span><br><span class="line">    <span class="function">unordered_set&lt;string&gt; <span class="title">dirc</span><span class="params">(wordList.begin(), wordList.end())</span></span>;<span class="comment">//从单词目录中取出所有单词，用于标记是否搜索过</span></span><br><span class="line">    <span class="type">bool</span> findFlag = <span class="literal">false</span>, reverseFlag = <span class="literal">false</span>;<span class="comment">//上下是否相交，是否转换搜索方向</span></span><br><span class="line">    <span class="keyword">while</span>(!bfsFromBegin.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        unordered_set&lt;string&gt; next;<span class="comment">//存放下一层的搜索对象</span></span><br><span class="line">        <span class="keyword">for</span>(string s : bfsFromBegin)</span><br><span class="line">            dirc.<span class="built_in">erase</span>(s);<span class="comment">//擦除已经搜索过的</span></span><br><span class="line">        <span class="keyword">for</span>(string s1 : bfsFromBegin)&#123;</span><br><span class="line">            <span class="comment">//寻找只相差一个字符的单词</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                string s2 = s1;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)&#123;</span><br><span class="line">                    s2[i] = c;</span><br><span class="line">                    <span class="keyword">if</span>(dirc.<span class="built_in">count</span>(s2) == <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(bfsFromEnd.<span class="built_in">count</span>(s2))</span><br><span class="line">                        findFlag = <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                        next.<span class="built_in">insert</span>(s2);</span><br><span class="line">                    reverseFlag ? tree[s2].<span class="built_in">push_back</span>(s1) : tree[s1].<span class="built_in">push_back</span>(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfsFromBegin = next;</span><br><span class="line">        <span class="comment">//每次只搜索节点次数少的那端</span></span><br><span class="line">        <span class="keyword">if</span>(bfsFromBegin.<span class="built_in">size</span>() &gt; bfsFromEnd.<span class="built_in">size</span>())&#123;</span><br><span class="line">            reverseFlag = !reverseFlag;</span><br><span class="line">            <span class="built_in">swap</span>(bfsFromBegin, bfsFromEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(findFlag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS寻找所有通路</span></span><br><span class="line">    vector&lt;string&gt; cur = &#123;beginWord&#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(cur, beginWord, endWord);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; cur, string curWord, string endWord)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curWord == endWord)&#123;</span><br><span class="line">        <span class="comment">//搜索方向是反着的，要翻转</span></span><br><span class="line">        <span class="built_in">reverse</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">reverse</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(string s : tree[curWord])&#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">dfs</span>(cur, s, endWord);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：从前向后DFS会超时，所以从后向前DFS，面向数据编程了属于是（</p></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a><a href="https://leetcode.cn/problems/surrounded-regions/">被围绕的区域</a></h3><p><strong>题目描述：</strong></p><p>给你一个 m x n 的矩阵 board，由若干字符 ‘X’ 和 ‘O’，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：board =<br>[[“X”,”X”,”X”,”X”],<br>[“X”,”O”,”O”,”X”],<br>[“X”,”X”,”O”,”X”],<br>[“X”,”O”,”X”,”X”]]<br>输出：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：board = [[“X”]]<br>输出：[[“X”]]</p></blockquote><p><strong>题解：</strong></p><p>主要问题在于如何判断是否是被包围的，可以dfs每一个边界元素，把与之相连的标记为 ‘A’，然后遍历矩阵赋值即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(board, x + <span class="number">1</span>, y);</span><br><span class="line">    <span class="built_in">dfs</span>(board, x - <span class="number">1</span>, y);</span><br><span class="line">    <span class="built_in">dfs</span>(board, x, y + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(board, x, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    n = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(board, i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(board, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">dfs</span>(board, n - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">二叉树的所有路径</a></h3><p><strong>题目描述：</strong></p><p>给你一个二叉树的根节点 root，按任意顺序返回所有从根节点到叶子节点的路径。</p><p>叶子节点是指没有子节点的节点。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：<img src="https://s2.loli.net/2022/08/04/4XAMDCpZckfrn1U.jpg" alt="paths-tree.jpg" style="zoom:33%;" /></p><p>root = [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：root = [1]<br>输出：[“1”]</p></blockquote><p><strong>题解：</strong></p><p>DFS</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct_paths</span><span class="params">(TreeNode* root, string path, vector&lt;string&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            paths.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">construct_paths</span>(root-&gt;left, path, paths);</span><br><span class="line">            <span class="built_in">construct_paths</span>(root-&gt;right, path, paths);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; paths;</span><br><span class="line">    <span class="built_in">construct_paths</span>(root, <span class="string">&quot;&quot;</span>, paths);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a><a href="https://leetcode.cn/problems/permutations-ii/">全排列II</a></h3><p><strong>题目描述：</strong></p><p>给定一个可包含重复数字的序列 nums，按任意顺序返回所有不重复的全排列。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],[1,2,1],[2,1,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><p><strong>题解：</strong></p><p>重复的来源是相同数字的位置可交换，所以只需限制相同数字的相对位置为固定的即可，可以对数组排序，按照数组下标的相对位置。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, <span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//不能取的两种情况，一是取过了，二是相同数字但位置在前的还未被取</span></span><br><span class="line">        <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perm.<span class="built_in">emplace_back</span>(nums[i]);<span class="comment">//比push_back效率高</span></span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">        perm.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; perm;</span><br><span class="line">    vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和II</a></h3><p><strong>题目描述：</strong></p><p>给定一个候选人编号的集合 candidates 和一个目标数 target，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。</p><p>注意：解集不能包含重复的组合。 </p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>输出:<br>[[1,1,6],[1,2,5],[1,7],[2,6]]</p></blockquote><p>示例 2:</p><blockquote><p>输入: candidates = [2,5,2,1,2], target = 5,<br>输出:<br>[[1,2,2],[5]]</p></blockquote><p><strong>题解：</strong></p><p>带重复的回溯 = 排序 + 判断。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; target-candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//避免重复，只需要避免取的数和上一层回溯拿掉的数相等即可</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; index &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">解数独</a></h3><p><strong>题目描述：</strong></p><p>编写一个程序，通过填充空格来解决数独问题。数独的解法需遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</li></ul><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：<img src="https://s2.loli.net/2022/08/04/XJcAKxvzhyM7r4Z.png" alt="250px-sudoku-by-l2g-20050714svg.png" style="zoom:50%;" /></p><p>输出：<img src="https://s2.loli.net/2022/08/04/5DTmrFq3nZOBHAk.png" alt="250px-sudoku-by-l2g-20050714_solutionsvg.png" style="zoom: 50%;" /></p></blockquote><p><strong>题解：</strong></p><p>类似 N 皇后，建立数组标记行、列和九宫格内的数字出现情况，然后回溯法填数字即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> line[<span class="number">10</span>][<span class="number">10</span>], column[<span class="number">10</span>][<span class="number">10</span>], block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="type">char</span> temp = board[i][j];</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!line[i][k] &amp;&amp; !column[j][k] &amp;&amp; !block[i/<span class="number">3</span>][j/<span class="number">3</span>][k]) &#123;</span><br><span class="line">                        board[i][j] = k + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        line[i][k] = <span class="literal">true</span>;</span><br><span class="line">                        column[j][k] = <span class="literal">true</span>;</span><br><span class="line">                        block[i / <span class="number">3</span>][j / <span class="number">3</span>][k] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board))</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        line[i][k] = <span class="literal">false</span>;</span><br><span class="line">                        column[j][k] = <span class="literal">false</span>;</span><br><span class="line">                        block[i / <span class="number">3</span>][j / <span class="number">3</span>][k] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(line, <span class="number">0</span>, <span class="built_in">sizeof</span>(line));</span><br><span class="line">    <span class="built_in">memset</span>(column, <span class="number">0</span>, <span class="built_in">sizeof</span>(column));</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="type">char</span> temp = board[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="string">&#x27;.&#x27;</span> - <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                line[i][temp] = <span class="literal">true</span>;</span><br><span class="line">                column[j][temp] = <span class="literal">true</span>;</span><br><span class="line">                block[i / <span class="number">3</span>][j / <span class="number">3</span>][temp] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">dfs</span>(board);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a><a href="https://leetcode.cn/problems/minimum-height-trees/">最小高度树</a></h3><p><strong>题目描述：</strong></p><p>树是一个无向图，其中任何两个顶点只通过一条路径连接。换句话说，一个任何没有简单环路的连通图都是一棵树。</p><p>给你一棵包含 n 个节点的树，标记为 0 到 n - 1。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。任意两节点只有一条路径。</p><p>可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h。在所有可能的树中，具有最小高度的树（即，min(h)）被称为最小高度树。</p><p>请你找到所有的最小高度树并按任意顺序返回它们的根节点标签列表。</p><p>树的高度是指根节点和叶子节点之间最长向下路径上边的数量。</p><p>示例 1：</p><blockquote><p>输入：n = 4, edges = [[1,0],[1,2],[1,3]]<br>输出：[1]</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]<br>输出：[3,4]</p></blockquote><p><strong>题解：</strong></p><p>暴力解法会超时，这里采用类似拓扑排序（好高级的名词doge)的方法。目标是找到与距离最远的叶节点的距离最小的根节点，如果把树按照最长路径给捋成一条链子，那么很显然应该选取根节点为链子中点的一个或两个节点，如何取到呢，可以BFS逐层删掉叶节点，最后剩下两个或一个时即为所求的根节点。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;   <span class="comment">//每个节点对应的度数</span></span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; m;  <span class="comment">//邻接表</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans; <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> v=edges[i][<span class="number">1</span>];</span><br><span class="line">        degree[u]++;</span><br><span class="line">        degree[v]++;</span><br><span class="line">        m[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        m[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//把叶子节点入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">1</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="comment">//从外向内一层一层剥</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n - k &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sz=q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            degree[t]--;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">//加入t的邻接叶子节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : m[t])&#123;</span><br><span class="line">                degree[j]--;</span><br><span class="line">                <span class="keyword">if</span> (degree[j] == <span class="number">1</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - k; i++) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法解释&quot;&gt;&lt;a href=&quot;#算法解释&quot; class=&quot;headerlink&quot; title=&quot;算法解释&quot;&gt;&lt;/a&gt;算法解释&lt;/h2&gt;&lt;p&gt;搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="DFS,BFS" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/DFS-BFS/"/>
    
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
    <category term="DFS" scheme="https://liano.top/tags/DFS/"/>
    
    <category term="BFS" scheme="https://liano.top/tags/BFS/"/>
    
    <category term="回溯" scheme="https://liano.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://liano.top/posts/735e5788/"/>
    <id>https://liano.top/posts/735e5788/</id>
    <published>2022-08-22T03:45:35.969Z</published>
    <updated>2022-08-22T09:48:34.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><p>以下是一些最基本的排序算法。虽然在 C++ 里可以通过 std::sort() 快速排序，而且刷题时很少需要自己手写排序算法，但是熟习各种排序算法可以加深自己对算法的基本理解，以及解出由这些排序算法引申出来的题目。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>采用<strong>左闭右开</strong>的二分写法，代码模板如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//特殊情况，没有数或只有一个数，无需排序，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//取区间左端点值为排序对象，目标是比它大的都在右边，比它小的都在左边</span></span><br><span class="line">    <span class="type">int</span> first = l, last = r - <span class="number">1</span>, key = nums[first];</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">        <span class="comment">//寻找比key小的，往前调</span></span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; nums[last] &gt;= key)</span><br><span class="line">            last--;</span><br><span class="line">        nums[first] = nums[last];<span class="comment">//因为nums[first]的值在key中，不会丢失</span></span><br><span class="line">        <span class="comment">//比key大的，往后调</span></span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[first] &lt;= key)</span><br><span class="line">            first++;</span><br><span class="line">        nums[last] = nums[first];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[first] = key;<span class="comment">//key来到了属于它的位置</span></span><br><span class="line">    <span class="comment">//继续排左半区间和右半区间</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, l, first);</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, first + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序主要是采用分而治之的思想，将数组不断分解成多个小数组，然后从排序好的小数组中按大小挑出数填充结果数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//分解</span></span><br><span class="line"><span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line"><span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line">    <span class="comment">//归并原理</span></span><br><span class="line"><span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line">    <span class="comment">//分别从两个小数组开头开始，先挑小的放进结果数组</span></span><br><span class="line"><span class="keyword">while</span> (p &lt; m || q &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q]))</span><br><span class="line">            temp[i++] = nums[p++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[i++] = nums[q++];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//临时的数组赋回原数组</span></span><br><span class="line"><span class="keyword">for</span> (i = l; i &lt; r; i++)</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>先排好小的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j<span class="number">-1</span>]; j--)</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>先排好大的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j+<span class="number">1</span>])</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选定第一个元素为最小元，然后向后比较找真正的最小元，与之交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[min], nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><h3 id="数组中第-k-大的元素"><a href="#数组中第-k-大的元素" class="headerlink" title="数组中第 k 大的元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">数组中第 k 大的元素</a></h3><p><strong>题目描述：</strong></p><p>给定整数数组 nums 和整数 k，请返回数组中第 k 大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p></blockquote><p><strong>题解：</strong></p><p>快速选择一般用于求解 k-th Element 问题，可以在 O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。快速选择的实现和快速排序相似，首先选定数组第一个值为基准值，将小于它的放在左边，大于它的放在右边，然后根据情况判断继续搜索左区间还是右区间。</p><p><img src="https://s2.loli.net/2022/08/22/VX5flsY1HrxBo8T.jpg" alt="capture-2022-08-22-12-50-01.jpg" style="zoom: 25%;" /></p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">quickSelection</span>(nums, l, r);</span><br><span class="line">        <span class="keyword">if</span> (mid == target)</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; target)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数 - 快速选择，目标是把数组按大小切成两半，返回的是分界点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r &amp;&amp; nums[i] &lt;= nums[l])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; j &amp;&amp; nums[j] &gt;= nums[l])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="前-k-个高频元素"><a href="#前-k-个高频元素" class="headerlink" title="前 k 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 k 个高频元素</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [1], k = 1<br>输出: [1]</p></blockquote><p><strong>题解：</strong></p><p>顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属性），然后对桶进行排序。针对样例1来说，我们先通过桶排序得到四个桶 [1,2,3,4]，它们的值分别为 [4,2,1,1]，表示每个数字出现的次数。</p><p>紧接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种<br>排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说，因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [[3,4],[2],[],[1]]，表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num : nums) &#123;</span><br><span class="line">        counts[num]++;</span><br><span class="line">        max_count = <span class="built_in">max</span>(max_count, counts[num]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(max_count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; p : counts)</span><br><span class="line">        buckets[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max_count; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num : buckets[i])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="根据字符出现频率排序"><a href="#根据字符出现频率排序" class="headerlink" title="根据字符出现频率排序"></a><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">根据字符出现频率排序</a></h3><p><strong>题目描述：</strong></p><p>给定一个字符串 s，根据字符出现的频率对其进行降序排序。一个字符出现的频率是它出现在字符串中的次数。</p><p>返回已排序的字符串。如果有多个答案，返回其中任何一个。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: s = “tree”<br>输出: “eert”</p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “cccaaa”<br>输出: “cccaaa”</p></blockquote><p>示例 3:</p><blockquote><p>输入: s = “Aabb”<br>输出: “bbAa”</p></blockquote><p><strong>题解：</strong></p><p>即桶排序。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; a : s) &#123;</span><br><span class="line">        counts[a]++;</span><br><span class="line">        max_count = <span class="built_in">max</span>(max_count, counts[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">buckets</span>(max_count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; p : counts)</span><br><span class="line">        buckets[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max_count; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; a : buckets[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">                ans.<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></h3><p><strong>题目描述：</strong></p><p>给定一个包含红色、白色和蓝色共 n 个元素的数组 nums，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,0,1]<br>输出：[0,1,2]</p></blockquote><p><strong>题解：</strong></p><p>桶排序。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num : nums)</span><br><span class="line">        counts[num]++;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; counts[<span class="number">0</span>]; i++)</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; counts[<span class="number">1</span>] + counts[<span class="number">0</span>]; i++)</span><br><span class="line">        nums[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; counts[<span class="number">2</span>] + counts[<span class="number">1</span>] + counts[<span class="number">0</span>]; i++)</span><br><span class="line">        nums[i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用排序算法&quot;&gt;&lt;a href=&quot;#常用排序算法&quot; class=&quot;headerlink&quot; title=&quot;常用排序算法&quot;&gt;&lt;/a&gt;常用排序算法&lt;/h2&gt;&lt;p&gt;以下是一些最基本的排序算法。虽然在 C++ 里可以通过 std::sort() 快速排序，而且刷题时很少需要</summary>
      
    
    
    
    <category term="算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
    <category term="排序算法" scheme="https://liano.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://liano.top/posts/e8eb0481/"/>
    <id>https://liano.top/posts/e8eb0481/</id>
    <published>2022-08-22T01:02:03.568Z</published>
    <updated>2022-08-22T01:24:08.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为 O(n) 的数组，二分查找的时间复杂度为 O(log n)。二分查找适用对象必须是排好序的数组。</p><p>具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此有些初学者会容易搞不清楚如何定义区间开闭性。这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在做题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。</p><p>二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。</p><h2 id="求开方"><a href="#求开方" class="headerlink" title="求开方"></a>求开方</h2><h3 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a><a href="https://leetcode.cn/problems/sqrtx/">x 的平方根</a></h3><p><strong>题目描述：</strong></p><p>给你一个非负整数 x，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：x = 4<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：x = 8<br>输出：2</p></blockquote><p><strong>题解：</strong></p><p>在 [0, x] 区间二分查找。另外还有一个更快的牛顿迭代法 $x_{n+1}=x_n-\frac{f(x_n)}{f^{‘}(x_n)}$</p><p><strong>代码：</strong></p><p>二分查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = a, mid, sqrt;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        sqrt = a / mid;</span><br><span class="line">        <span class="keyword">if</span> (sqrt == mid) </span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; sqrt)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>牛顿迭代法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="type">long</span> x = a;</span><br><span class="line"><span class="keyword">while</span> (x * x &gt; a)</span><br><span class="line">x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找区间"><a href="#查找区间" class="headerlink" title="查找区间"></a>查找区间</h2><h3 id="查找元素始末位置"><a href="#查找元素始末位置" class="headerlink" title="查找元素始末位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">查找元素始末位置</a></h3><p><strong>题目描述：</strong></p><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [], target = 0<br>输出：[-1,-1]</p></blockquote><p><strong>题解：</strong></p><p>二分查找定位到目标值后向前向后扩大区间即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> mid, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = mid, r = mid;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; nums[l] == target) </span><br><span class="line">        l--;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[r] == target)</span><br><span class="line">        r++;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l+<span class="number">1</span>, r<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">range</span>(nums, mid, target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后（寻找上下边界也使用二分查找）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> lower = <span class="built_in">lower_bound</span>(nums, target);</span><br><span class="line">    <span class="type">int</span> upper = <span class="built_in">upper_bound</span>(nums, target) - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (lower == nums.<span class="built_in">size</span>() || nums[lower] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;lower, upper&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            r = mid; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转数组查找数字"><a href="#旋转数组查找数字" class="headerlink" title="旋转数组查找数字"></a>旋转数组查找数字</h2><h3 id="搜索旋转排序数组II"><a href="#搜索旋转排序数组II" class="headerlink" title="搜索旋转排序数组II"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组II</a></h3><p><strong>题目描述：</strong></p><p>已知存在一个按非降序排列的整数数组 nums，数组中的值不必互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了旋转，使数组变为了[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如，[0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4]。</p><p>给你旋转后的数组 nums 和一个整数 target，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target，则返回 true，否则返回 false。</p><p>你必须尽可能减少整个操作步骤。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [2,5,6,0,0,1,2], target = 0<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,5,6,0,0,1,2], target = 3<br>输出：false</p></blockquote><p><strong>题解：</strong></p><p>其实数组即使被旋转过一次，也并不影响二分查找的使用，如果中点值小于右端点，则右半区间为排好序的；若中点值等于右端点，不能确定，尝试右端点左移重新取中点；若中点值大于右端点，则左半区间为排好序的。继续二分查找即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[r]) </span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[r])</span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt;= nums[mid])</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="寻找旋转排序数组的最小值II"><a href="#寻找旋转排序数组的最小值II" class="headerlink" title="寻找旋转排序数组的最小值II"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组的最小值II</a></h3><p><strong>题目描述：</strong></p><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次旋转后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p><ul><li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]</li><li>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]</li></ul><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]]。</p><p>给你一个可能存在重复元素值的数组 nums，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素。</p><p>你必须尽可能减少整个过程的操作步骤。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums = [1,3,5]<br>输出：1</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,2,2,0,1]<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>别看题目旋转多少次，实际上是上一题的不同表述，同样是一直二分查找至最小值。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[r])</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[r]) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序数组中的单一元素"><a href="#有序数组中的单一元素" class="headerlink" title="有序数组中的单一元素"></a><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/">有序数组中的单一元素</a></h3><p><strong>题目描述：</strong></p><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。请你找出并返回只出现一次的那个数。</p><p>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: nums = [1,1,2,3,3,4,4,8,8]<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums =  [3,3,7,7,10,11,11]<br>输出: 10</p></blockquote><p><strong>题解：</strong></p><p>二分查找，根据中点值及其相邻的左右值，以及左右区间的奇偶性判断在哪一半区间。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                r = mid - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">                l = mid + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h3><p><strong>题目描述：</strong></p><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p><p>算法的时间复杂度应该为 O(log (m+n))。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000</p></blockquote><p><strong>题解：</strong></p><p>根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1。</p><p>假设两个有序数组分别是 A 和 B。要找到第 k 个元素，我们可以比较 A[k/2-1] 和 B[k/2-1]，有三种情况：</p><ul><li>A[k/2-1] &lt; B[k/2-1]，则可以排除 A[0]~A[k/2-1]</li><li>A[k/2-1] &gt; B[k/2-1]，同理</li><li>A[k/2-1] = B[k/2-1]，可以合并进 1 中</li></ul><p>有以下三种情况需要特殊处理：</p><ul><li>如果 A[k/2-1] 或者 B[k/2-1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k/2。</li><li>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k小的元素。</li><li>如果 k=1，我们只要返回两个数组首元素的最小值即可。</li></ul><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == m)</span><br><span class="line">            <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (index2 == n)</span><br><span class="line">            <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">        <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">        <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">        <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">            k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">            index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">            index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法解释&quot;&gt;&lt;a href=&quot;#算法解释&quot; class=&quot;headerlink&quot; title=&quot;算法解释&quot;&gt;&lt;/a&gt;算法解释&lt;/h2&gt;&lt;p&gt;二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于</summary>
      
    
    
    
    <category term="算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="二分查找" scheme="https://liano.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="https://liano.top/posts/91a7e4d1/"/>
    <id>https://liano.top/posts/91a7e4d1/</id>
    <published>2022-08-20T11:26:11.770Z</published>
    <updated>2022-08-22T09:47:41.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。</p><p>若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。</p><p>若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。</p><p>对于 C++ 语言，指针还可以玩出很多新的花样。一些常见的关于指针的操作如下：</p><h3 id="指针与常量"><a href="#指针与常量" class="headerlink" title="指针与常量"></a>指针与常量</h3><blockquote><p>int x;<br>int *p1 = &x; // 指针可以被修改，值也可以被修改<br>const int *p2 = &x; // 指针可以被修改，值不可以被修改（const int）<br>int *const p3 = &x; // 指针不可以被修改（*const），值可以被修改<br>const int *const p4 = &x; // 指针不可以被修改，值也不可以被修改</p></blockquote><h3 id="指针函数与函数指针"><a href="#指针函数与函数指针" class="headerlink" title="指针函数与函数指针"></a>指针函数与函数指针</h3><blockquote><p>// addition是指针函数，一个返回类型是指针的函数<br>int* addition(int a, int b) {<br>    int *sum = new int(a + b);<br>    return sum;<br>}<br>int subtraction(int a, int b) {<br>    return a - b;<br>}<br>int operation(int x, int y, int (*func)(int, int)) {<br>    return (*func)(x,y);<br>}</p><p>// minus是函数指针，指向函数的指针<br>int (*minus)(int, int) = subtraction;<br>int *m = addition(1, 2);<br>int n = operation(3, *m, minus);</p></blockquote><h2 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h2><h3 id="两数之和II"><a href="#两数之和II" class="headerlink" title="两数之和II"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和II</a></h3><p><strong>题目描述：</strong></p><p>给你一个下标从 1 开始的整数数组 numbers，该数组已按非递减顺序排列，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2]，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length。</p><p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和index2。</p><p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]</p></blockquote><p>示例 2：</p><blockquote><p>输入：numbers = [2,3,4], target = 6<br>输出：[1,3]</p></blockquote><p>示例 3：</p><blockquote><p>输入：numbers = [-1,0], target = -1<br>输出：[1,2]</p></blockquote><p><strong>题解：</strong></p><p>采用方向相反的双指针遍历数组，因为已经排好序，所以如果两个数之和小于目标值，则左指针右移，若大于目标值，则右指针左移。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = numbers.<span class="built_in">size</span>() - <span class="number">1</span>, sum;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        sum = numbers[l] + numbers[r];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) </span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并有序数组"><a href="#归并有序数组" class="headerlink" title="归并有序数组"></a>归并有序数组</h2><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">合并两个有序数组</a></h3><p><strong>题目描述：</strong></p><p>给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n，分别表示nums1 和 nums2 中的元素数目。</p><p>请你合并 nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0，应忽略。nums2 的长度为 n。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br>输出：[1]<br>注意：因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p></blockquote><p><strong>题解：</strong></p><p>因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即 nums1 的 m−1 位和 nums2 的 n−1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。<br>因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针 pos，以便复制。</p><blockquote><p>注意：如果 nums1 的数字已经复制完，不要忘记把 nums2 的数字继续复制；如果 nums2 的数字已经复制完，剩余 nums1 的数字不需要改变，因为它们已经被排好序。</p></blockquote><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[pos--] = nums1[m]&gt;nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[pos--] = nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表II</a></h3><p><strong>题目描述：</strong></p><p>给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>链表定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不允许修改链表。</p><p><strong>测试样例：</strong></p><p>示例：</p><blockquote><p>输入：<img src="https://s2.loli.net/2022/08/04/oYFjXthiG5B62pS.png" alt="circularlinkedlist.png" style="zoom:33%;" /><br>head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点</p></blockquote><p><strong>题解：</strong></p><p>对于链表找环路的问题，有一个通用的解法——<strong>快慢指针</strong>（Floyd 判圈法）。给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路；如果 fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fast || !fast-&gt;next) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h3><p><strong>题目描述：</strong></p><p>给你一个字符串 s、一个字符串 t。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “”。s,t只由英文字母组成。</p><blockquote><p>注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “a”, t = “a”<br>输出：”a”</p></blockquote><p>示例 3:</p><blockquote><p>输入: s = “a”, t = “aa”<br>输出: “”</p></blockquote><p><strong>题解：</strong></p><p>本题使用滑动窗口求解，即两个指针 l 和 r 都是从最左端向最右端移动，且 l 的位置一定在 r 的左边或重合。先统计 t 中字符数量，滑动窗口至包含所有字符，l 左移，得到最短子串。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> t : T) &#123;</span><br><span class="line">        flag[t] = <span class="literal">true</span>;</span><br><span class="line">        chars[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, min_l = <span class="number">0</span>, min_size = S.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; S.<span class="built_in">size</span>(); r++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[S[r]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--chars[S[r]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt == T.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l - <span class="number">1</span> &lt; min_size) &#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag[S[l]] &amp;&amp; ++chars[S[l]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_size&gt;S.<span class="built_in">size</span>() ? <span class="string">&quot;&quot;</span> : S.<span class="built_in">substr</span>(min_l, min_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="平方数之和"><a href="#平方数之和" class="headerlink" title="平方数之和"></a><a href="https://leetcode.cn/problems/sum-of-square-numbers/">平方数之和</a></h3><p><strong>题目描述：</strong></p><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2^ + b^2^ = c 。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：c = 5<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：c = 3<br>输出：false</p></blockquote><p><strong>题解：</strong></p><p>双指针，一个指向0，另一个指向根号c取整，左指针向右移或者右指针向左移，就可以避免双重循环解决问题。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> l = <span class="number">0</span>, r = <span class="built_in">sqrt</span>(c) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        ans = l * l + r * r;</span><br><span class="line">        <span class="keyword">if</span> (ans == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; c)</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证回文字符串II"><a href="#验证回文字符串II" class="headerlink" title="验证回文字符串II"></a><a href="https://leetcode.cn/problems/valid-palindrome-ii/">验证回文字符串II</a></h3><p><strong>题目描述：</strong></p><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: s = “aba”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “abca”<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: s = “abc”<br>输出: false</p></blockquote><p><strong>题解：</strong></p><p>双指针，一个在开头，一个在末尾，相向移动，不符合的字符记录下来即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> low , <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = low, j = high; i &lt; j; i++,j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[j]) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[l] == s[r]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">checkPalindrome</span>(s, l+<span class="number">1</span>, r) || <span class="built_in">checkPalindrome</span>(s, l, r<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除字母匹配字符串"><a href="#删除字母匹配字符串" class="headerlink" title="删除字母匹配字符串"></a><a href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/">删除字母匹配字符串</a></h3><p><strong>题目描述：</strong></p><p>给你一个字符串 s 和一个字符串数组 dictionary，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。均只由小写英文字母组成。</p><p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>输出：”apple”</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “abpcplea”, dictionary = [“a”,”b”,”c”]<br>输出：”a”</p></blockquote><p><strong>题解：</strong></p><p>双指针，一个用于遍历 s，另一个遍历 d 中的字符串，记录满足题目要求的字符串即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">    string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (string d : dictionary) &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &lt; d.<span class="built_in">size</span>() </span><br><span class="line">            || (ans.<span class="built_in">size</span>() == d.<span class="built_in">size</span>() &amp;&amp; ans.<span class="built_in">compare</span>(d) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (m &lt; s.<span class="built_in">size</span>() &amp;&amp; n &lt; d.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[m] == d[n]) </span><br><span class="line">                    n++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n == d.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ans = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="至多包含-k-个不同字符的最长子串"><a href="#至多包含-k-个不同字符的最长子串" class="headerlink" title="至多包含 k 个不同字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/">至多包含 k 个不同字符的最长子串</a></h3><p><strong>题目描述：</strong></p><p>给定一个字符串 s，找出至多包含 k 个不同字符的最长子串 T 的长度。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：s = “eceba”, k = 2<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “aa”, k = 1<br>输出：2</p></blockquote><p><strong>题解：</strong></p><p>滑动窗口。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &lt;= k)</span><br><span class="line">            m[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(m.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--m[s[j]] == <span class="number">0</span>)</span><br><span class="line">                m.<span class="built_in">erase</span>(s[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为这题是付费的，所以我并不确定是否完全AC，仅供参考</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法解释&quot;&gt;&lt;a href=&quot;#算法解释&quot; class=&quot;headerlink&quot; title=&quot;算法解释&quot;&gt;&lt;/a&gt;算法解释&lt;/h2&gt;&lt;p&gt;双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。&lt;/p&gt;
&lt;p&gt;若两个指针</summary>
      
    
    
    
    <category term="算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="双指针" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
    <category term="双指针" scheme="https://liano.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://liano.top/posts/a4ce31d2/"/>
    <id>https://liano.top/posts/a4ce31d2/</id>
    <published>2022-08-19T14:30:21.128Z</published>
    <updated>2022-08-22T08:55:51.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h2><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a></h3><p><strong>题目描述：</strong></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: g = [1,2,3], s = [1,1]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: g = [1,2], s = [1,2,3]<br>输出: 2</p></blockquote><p><strong>题解：</strong></p><p>两种角度，一，从小孩角度，先满足胃口小的，把大于且最接近的饼干分配给他；二，从饼干角度，先分配分量大的饼干给胃口小于且最接近的孩子。将两数组分别排序，遍历比较即可实现。</p><blockquote><p>思考：为什么小孩要先满足胃口小的，饼干要先分配大的？试一试。</p></blockquote><p><strong>代码：</strong></p><p>角度一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; children, vector&lt;<span class="type">int</span>&gt;&amp; cookies)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(cookies.<span class="built_in">begin</span>(), cookies.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; children.<span class="built_in">size</span>() &amp;&amp; cookie &lt; cookies.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (children[child] &lt;= cookies[cookie])</span><br><span class="line">            child++;</span><br><span class="line">        cookie++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角度二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; children, vector&lt;<span class="type">int</span>&gt;&amp; cookies)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">sort</span>(cookies.<span class="built_in">begin</span>(), cookies.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; children.<span class="built_in">size</span>() &amp;&amp; cookie &lt; cookies.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cookies[cookie] &gt;= children[child]) </span><br><span class="line">            cookie++;</span><br><span class="line">        child++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode.cn/problems/candy/">分发糖果</a></h3><p><strong>题目描述：</strong></p><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li><li>请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。</li></ul><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：ratings = [1,0,2]<br>输出：5</p></blockquote><p>示例 2：</p><blockquote><p>输入：ratings = [1,2,2]<br>输出：4</p></blockquote><p><strong>题解：</strong></p><p>首先每个孩子分一个，再从左往右遍历一遍，保证每个孩子相对右边相邻孩子糖果数是正确的，再从右向左遍历一遍，保证每个孩子相对左边相邻孩子糖果数正确，最后求和即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = ratings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &lt; ratings[i<span class="number">-1</span>] &amp;&amp; num[i<span class="number">-1</span>] &lt;= num[i]) &#123;</span><br><span class="line">            num[i<span class="number">-1</span>] = num[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间</a></h3><p><strong>题目描述：</strong></p><p>给定一个区间的集合 intervals，其中 intervals[i] = [starti, endi]。返回需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: intervals = [ [1,2], [1,2], [1,2] ]<br>输出: 2</p></blockquote><p>示例 3:</p><blockquote><p>输入: intervals = [ [1,2], [2,3] ]<br>输出: 0</p></blockquote><p><strong>题解：</strong></p><p>又是一个排序题目，两个角度：一，将区间右端升序排列，从左向右，优先保留右端较小且不重叠的区间；二，将区间左端降序排列，从左向右，优先保留左端较大且不重叠的区间。</p><p>如下图所示：</p><p><img src="https://s2.loli.net/2022/08/04/73un2QPUvOzLmGC.png" alt="v2-8af99daabb5a1a1f8c7d9fe6dcda2a2a_r.jpg" style="zoom:67%;" /></p><p><strong>代码：</strong></p><p>角度一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;);</span><br><span class="line">    <span class="type">int</span> removed = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) &#123;</span><br><span class="line">            removed++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角度二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];&#125;);</span><br><span class="line">    <span class="type">int</span> removed = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; prev) &#123;</span><br><span class="line">            removed++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = intervals[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a><a href="https://leetcode.cn/problems/can-place-flowers/">种花问题</a></h3><p><strong>题目描述：</strong></p><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：flowerbed = [1,0,0,0,1], n = 1<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：flowerbed = [1,0,0,0,1], n = 2<br>输出：false</p></blockquote><p><strong>题解：</strong></p><p>问题可以简化为一个基本模型，两端有花，中间空缺，更复杂的情况可以通过切割得到多个简单情况，且互相独立。又因为基本模型中两端的花地位相同，所以直接从左向右遍历，能种则种，即可得到全局最优。</p><p>这里提供另一个想法，虽然与贪心算法无关，但很巧妙，把花坛两端加上0，就可以将两端的特殊情况化为一般，只要有连续的3片空地就能种一朵花。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; flowerbed.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span> </span><br><span class="line">            &amp;&amp; (i == <span class="number">0</span> || flowerbed[i<span class="number">-1</span>] == <span class="number">0</span>) </span><br><span class="line">            &amp;&amp; (i == flowerbed.<span class="built_in">size</span>() - <span class="number">1</span> || flowerbed[i+<span class="number">1</span>] == <span class="number">0</span>)) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里用了 || 符号的短路性，判断过程不会越界</p></blockquote><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h3><p><strong>题目描述：</strong></p><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend 之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points，返回引爆所有气球所必须射出的最小弓箭数。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：points = [[1,2],[3,4],[5,6],[7,8]]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：points = [[1,2],[2,3],[3,4],[4,5]]<br>输出：2</p></blockquote><p><strong>题解：</strong></p><p>这题和上面的无重叠区间很相像，本题要求最少的箭头数量，能一块扎爆的是有重叠区间的，所以在一些重叠的区间中留下一个就行，其他的移除，和例题本质上是一样的，目标都是把一组互不重叠的区间全部找出来，稍微修改一下例题的代码即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), </span><br><span class="line">         [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;);</span><br><span class="line">    <span class="type">int</span> removed = <span class="number">0</span>, prev = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= prev) &#123;</span><br><span class="line">            removed++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> points.<span class="built_in">size</span>() - removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：本题中区间边界重合也算重合</p></blockquote><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">划分字母区间</a></h3><p><strong>题目描述：</strong></p><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p><strong>测试样例：</strong></p><blockquote><p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]</p></blockquote><p><strong>题解：</strong></p><p>这题依然可以转化为区间问题，两次遍历得到每个字母的始末位置，然后合并区间即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        last[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last[s[i] - <span class="string">&#x27;a&#x27;</span>] &gt; end)</span><br><span class="line">            end = last[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (end == i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买或出售股票。你在任何时候最多只能持有一股股票。你也可先购买，然后在同一天出售。返回你能获得的最大利润。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：prices = [7,1,5,3,6,4]<br>输出：7</p></blockquote><p>示例 2：</p><blockquote><p>输入：prices = [1,2,3,4,5]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：prices = [7,6,4,3,1]<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>题目只要求最大利润，所以直接贪心计算差价即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>])</span><br><span class="line">            ans += (prices[i+<span class="number">1</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="*根据身高重建队列"></a>*<a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h3><p><strong>题目描述：</strong></p><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p></blockquote><p><strong>题解：</strong></p><p>先排序，身高降序排列，然后 k 升序，先将最高的按 k 值升序放入队列中，然后插入个子矮的，也是按 k 值插入即可，不会影响前面已经插入好的。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : people) &#123;</span><br><span class="line">        ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>() + n[<span class="number">1</span>], n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; people.size(); i++)&#123;  </span></span><br><span class="line">    <span class="comment">//res.insert(res.begin()+people[i][1], people[i]);</span></span><br><span class="line">    <span class="comment">//&#125;与上面等价</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递减数列"><a href="#非递减数列" class="headerlink" title="非递减数列"></a><a href="https://leetcode.cn/problems/non-decreasing-array/">非递减数列</a></h3><p><strong>题目描述：</strong></p><p>给你一个长度为 n 的整数数组 nums，请你判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的：对于数组中任意的 i (0&lt;=i&lt;=n-2)，总满足 nums[i] &lt;= nums[i + 1]。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: nums = [4,2,3]<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [4,2,1]<br>输出: false</p></blockquote><p><strong>题解：</strong></p><p>只要求出最少修改次数，然后与 1 比较即可，对于不符合条件的两个相邻的数，有两种方案，一，修改前面一个，二，修改后面一个，具体采用哪种方案要看修改后是否会影响前面已经符合的部分，比较这两个数的前面一个数和这两个数中后面一个数的大小即可做出判断。</p><blockquote><p>注：应修改至恰好满足，即不符合的变成相等的，这样对其他部分影响小，修改次数也最少</p></blockquote><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPossibility</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i+<span class="number">1</span>] &gt;= nums[i<span class="number">-1</span>])</span><br><span class="line">                nums[i] = nums[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i+<span class="number">1</span>] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分配问题&quot;&gt;&lt;a href=&quot;#分配问题&quot; class=&quot;headerlink&quot; title=&quot;分配问题&quot;&gt;&lt;/a&gt;分配问题&lt;/h2&gt;&lt;h3 id=&quot;分发饼干&quot;&gt;&lt;a href=&quot;#分发饼干&quot; class=&quot;headerlink&quot; title=&quot;分发饼干&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="算法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心法" scheme="https://liano.top/categories/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
    <category term="贪心算法" scheme="https://liano.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>论如何优雅地写博客</title>
    <link href="https://liano.top/posts/a5649831/"/>
    <id>https://liano.top/posts/a5649831/</id>
    <published>2022-08-14T08:18:52.953Z</published>
    <updated>2022-08-23T14:42:22.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花费了零零碎碎将近三天来搭建并美化个人博客网站，不好好写东西都对不起自己😉，本篇介绍如何优雅地写博客，主要内容分为三部分，一是如何发布博客，二是如何优雅地使用latex公式，三是如何优雅地插入图片。</p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><blockquote><p>问：如何发布博客？</p><p>答：将要上传的 md 文档放入/source/_posts中，素质三连 <code>git clean</code>,<code>git g</code>,<code>git d</code> 即可</p></blockquote><p>要上传的 md 文档前面的 front-matter 部分写上 title，categories，tags 等文章信息，具体可以写哪些信息详见上一篇。</p><p>进入源码模式，格式如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 论如何优雅地写博客</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> 使用技巧</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">-</span> Typora</span><br><span class="line"><span class="bullet">-</span> PicGo</span><br><span class="line"><span class="bullet">-</span> SM.MS图床</span><br><span class="line"><span class="bullet">-</span> hexo</span><br><span class="line"><span class="section">- 写博客</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="latex公式"><a href="#latex公式" class="headerlink" title="latex公式"></a>latex公式</h2><p>众所周知，Typora 以其出色的即时预览功能和对 latex 公式的支持广受欢迎，虽然现在付费了，但还是可以想办法白嫖的，<a href="https://github.com/liano3/typora_theme">方法在这</a>，里面还附赠了一套来自 op 的精美主题。</p><p>但是，当我将用 Typora 写的文档放入博客中时，问题出现了！里面的 latex 公式都寄了！下面讲解解决方法：</p><h3 id="更换插件"><a href="#更换插件" class="headerlink" title="更换插件"></a>更换插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><h3 id="更改插件文件"><a href="#更改插件文件" class="headerlink" title="更改插件文件"></a>更改插件文件</h3><p>进入项目更目录下：<code>node_modules\kramed\lib\rules\inline.js</code></p><p>修改这么两行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="attr">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span></span><br><span class="line">+ <span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span></span><br><span class="line">- <span class="attr">em</span>: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span></span><br><span class="line">+ <span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span></span><br></pre></td></tr></table></figure><p>分别在第 11 行和 20 行左右，减号后面是删掉的内容，加号后面是要加上的内容</p><h3 id="配置主题文件"><a href="#配置主题文件" class="headerlink" title="配置主题文件"></a>配置主题文件</h3><p>_config.butterfly.yml 中更改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="更改部分语法"><a href="#更改部分语法" class="headerlink" title="更改部分语法"></a>更改部分语法</h3><p>如果上述操作全部完成，还是不能成功，看看有没有语法问题。</p><p>比如，如果在公式内连续使用两个花括号，必须加上空格。</p><p>如下面的会渲染失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L_p  = (\sum_&#123;i=1&#125;^m |x_i - y_i |^&#123;p&#125;  )^&#123;&#123;\tfrac&#123;1&#125;&#123;p&#125;&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>在连续的花括号之间加上空格即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L_p  = (\sum_&#123;i=1&#125;^m |x_i - y_i |^&#123;p&#125;  )^&#123; &#123;\tfrac&#123;1&#125; &#123;p&#125; &#125; &#125;$$</span><br></pre></td></tr></table></figure><h2 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h2><p>个人博客不能没有图床，就像西方不能没有耶路撒冷🤣，总之一个图床工具还是非常有用的，首先是无论是 github pages 还是 gitee pages 都是有 1G 的容量限制的，图片传多了就寄了。另外，图床可以实现跨平台跨设备使用同一张图片，分享或上传 md 文档再也不用连带着图片文件夹压缩了。</p><p>本着白嫖精神，并考虑到 github 访问速度慢，gitee 禁止外链，我选择 SM.MS 图床配合 PicGo 工具。SM.MS图床免费用户有 5G 容量（再多点就好了😊)，访问速度还可以。下面介绍如何配置：</p><h3 id="下载PicGo"><a href="#下载PicGo" class="headerlink" title="下载PicGo"></a>下载PicGo</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">网址在这</a>，向下翻，下载 2.3.0 版本，如下图：</p><p><img src="https://s2.loli.net/2022/08/14/7vVblZ2Ijcp5mxO.png" alt="image-20220814215545932" style="zoom: 67%;" /></p><p>下载完成后双击即可安装。</p><h3 id="配置SM-MS"><a href="#配置SM-MS" class="headerlink" title="配置SM.MS"></a>配置SM.MS</h3><p><a href="https://sm.ms/">网址在这</a>，注册登录后点击菜单栏的 user -&gt; DashBoard</p><p><img src="https://s2.loli.net/2022/08/14/9x3IEp8Cf1P2biz.png" alt="Snipaste_2022-08-14_22-03-11" style="zoom:67%;" /></p><p>点击 API Token，复制 Secret Token 的内容，如果为空就点击下面的 Generate</p><p><img src="https://s2.loli.net/2022/08/14/olSEtRNqg6aXhbw.png" alt="Snipaste_2022-08-14_22-07-14" style="zoom:67%;" /></p><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p>打开 PicGo，配置 token，即把刚才复制的内容放进来</p><blockquote><p>注意：PicGo 双击打开可能没反应，实际在任务栏可以看到</p></blockquote><p><img src="https://s2.loli.net/2022/08/14/f2vbSonTrl4JAGt.png" alt="Snipaste_2022-08-14_22-10-57" style="zoom:67%;" /></p><h3 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h3><p>文件 -&gt; 偏好设置 -&gt; 图像，配置如下：</p><p><img src="https://s2.loli.net/2022/08/14/LZhqWcoHMm3iABl.png" alt="Snipaste_2022-08-14_22-17-01" style="zoom:67%;" /></p><p>重启 Typora，即可优雅地写博客。</p><blockquote><p>注意：最后的验证可能不成功，重启之后新建一个 md 文档试试，如果能上传，就不用管</p></blockquote><p>另外，推荐一个截图工具 snipaste，超级好用！</p><hr><p>优雅的分割线😎 我来更新啦！</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="公式换行"><a href="#公式换行" class="headerlink" title="公式换行"></a>公式换行</h3><p>如果要写多行公式，需要以\\begin{cases},\\end{cases}或者\\begin{align},\\end{align}包裹，否则换行失效。</p><p>例如：</p><p>换行无效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">a=b+c \\</span><br><span class="line">b=c+d</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">a=b+c \\b=c+d</script><p>换行成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">a=b+c \\</span><br><span class="line">b=c+d</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{align}a=b+c \\b=c+d\end{align}</script><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>现有渲染器kramed不支持上下标，可以考虑替换为markdown-it，但这个插件对mathjax的支持不太好，暂时我没找到鱼和熊掌兼得的办法，所以，以后写文章上下标尽量在公式中使用吧</p><h3 id="公式大小"><a href="#公式大小" class="headerlink" title="公式大小"></a>公式大小</h3><p>在根目录中搜索mathjax.pug文件，应该有两个，改代码中scale的值即可</p><h3 id="行距"><a href="#行距" class="headerlink" title="行距"></a>行距</h3><p>插入行内公式后文本行距变窄，暂时没找到方法解决，逼死本强迫症了🤬，有解决办法的大佬请评论告诉我😣</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;花费了零零碎碎将近三天来搭建并美化个人博客网站，不好好写东西都对不起自己😉，本篇介绍如何优雅地写博客，主要内容分为三部分，一是如何发布博客</summary>
      
    
    
    
    <category term="博客" scheme="https://liano.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="使用" scheme="https://liano.top/categories/%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="hexo" scheme="https://liano.top/tags/hexo/"/>
    
    <category term="Typora" scheme="https://liano.top/tags/Typora/"/>
    
    <category term="PicGo" scheme="https://liano.top/tags/PicGo/"/>
    
    <category term="SM.MS图床" scheme="https://liano.top/tags/SM-MS%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="写博客" scheme="https://liano.top/tags/%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客（三）主题配置</title>
    <link href="https://liano.top/posts/476e1d48/"/>
    <id>https://liano.top/posts/476e1d48/</id>
    <published>2022-08-12T12:43:49.187Z</published>
    <updated>2022-08-22T01:27:17.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有一个自己的博客还不够优雅，搭配上一个酷炫的主题才能更优雅地书写，本文以 butterfly主题为基础，谈谈博客界面的美化与功能细节的添加</p><h2 id="应用butterfly主题"><a href="#应用butterfly主题" class="headerlink" title="应用butterfly主题"></a>应用butterfly主题</h2><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>在hexo根目录里打开gitbash，输入如下命令：</p><p><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></p><p>成功后如图所示：</p><p><img src="https://s2.loli.net/2022/08/14/8vnQBeaSTY1FKD7.png" alt="image-20220812205140208" style="zoom:67%;" /></p><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>然后进入根目录里的_config.yml文件，将主题改为butterfly:</p><p><img src="https://s2.loli.net/2022/08/14/p2FHgXciI1qaeBk.png" alt="image-20220812205422129" style="zoom:67%;" /></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p><p><img src="https://s2.loli.net/2022/08/14/GqsVtvJZd9RXhkb.png" alt="image-20220812205725232" style="zoom:67%;" /></p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>在根目录创建一个名为 <code>_config.butterfly.yml</code> 的文件，将<strong>butterfly主题目录里的</strong>文件_config.yml内容复制到新建的文件中，以后更改配置时在新建的这个文件里更改，因为解析时新建的这个文件优先级高，这样既可以有效修改配置，又避免升级主题时数据丢失。</p><p><img src="https://s2.loli.net/2022/08/14/i2BdMIhmT9F7gQq.png" style="zoom:67%;" /></p><p>注意：原来的文件不要删除</p><h2 id="网页功能配置"><a href="#网页功能配置" class="headerlink" title="网页功能配置"></a>网页功能配置</h2><h3 id="front-matter"><a href="#front-matter" class="headerlink" title="front-matter"></a>front-matter</h3><p>首先介绍一下 front-matter，顾名思义，是在md文档中最前面，以—-为分界线，用于指定参数或变量的部分</p><h4 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h4><p>相关参数如下表：</p><div class="table-container"><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>[必需]页面标题</td></tr><tr><td>date</td><td>[必需]页面创建日期</td></tr><tr><td>type</td><td>[必需]标签、分类和友链三个页面需要</td></tr><tr><td>updated</td><td>页面更新日期</td></tr><tr><td>comments</td><td>显示评论模块</td></tr><tr><td>top_img</td><td>页面顶部图片</td></tr><tr><td>mathjax</td><td>per_page:false时才需要配置</td></tr></tbody></table></div><h4 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h4><div class="table-container"><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>[必需]文章标题</td></tr><tr><td>date</td><td>[必需]创建日期</td></tr><tr><td>updated</td><td>更新日期</td></tr><tr><td>tags</td><td>标签</td></tr><tr><td>categories</td><td>文章分类</td></tr><tr><td>cover</td><td>文章缩略图</td></tr><tr><td>mathjax</td><td>per_page:false时才需要配置</td></tr></tbody></table></div><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>首先进入主题配置文件_config.butterfly.yml，更改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#菜单栏</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br></pre></td></tr></table></figure><p>根据自己情况，还可以再加，我只创建了这几个页面。</p><p>然后前往你的 Hexo 博客的根目录，输入 <code>hexo new page tags</code>，你会找到source/tags/index.md这个文件，修改这个文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-08-11 19:27:10</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">/img/page.png</span>  <span class="comment">#自己根据你想设置的图片的位置修改</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>分类页操作步骤同上，把命令改为 <code>hexo new page categories</code> 即可</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2><p>东西太多了，写不下去了，关于主题方面的配置，官方文档里写的比我清晰多了，自己看去吧：<a href="https://butterfly.js.org/">地址在这</a> （我好懒🤣</p><p>另外，官方文档的图片显示需要梯子，推荐greenhub，免费好用</p><p>下一篇更如何与typora，picgo，smms图床结合，提升书写体验，敬请期待~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有一个自己的博客还不够优雅，搭配上一个酷炫的主题才能更优雅地书写，本文以 butterfly主题为基础，谈谈博客界面的美化与功能细节的添加&lt;</summary>
      
    
    
    
    <category term="博客" scheme="https://liano.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="搭建" scheme="https://liano.top/categories/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="自建博客" scheme="https://liano.top/tags/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://liano.top/tags/hexo/"/>
    
    <category term="github" scheme="https://liano.top/tags/github/"/>
    
    <category term="网页制作" scheme="https://liano.top/tags/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客（二）node.js与hexo</title>
    <link href="https://liano.top/posts/fd836635/"/>
    <id>https://liano.top/posts/fd836635/</id>
    <published>2022-08-12T12:32:17.387Z</published>
    <updated>2022-08-22T01:27:06.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-js与hexo"><a href="#node-js与hexo" class="headerlink" title="node.js与hexo"></a>node.js与hexo</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p><a href="https://nodejs.org/en/">网址在这</a>，下载左边那个版本</p><p><img src="https://s2.loli.net/2022/08/14/b75yF3ReITtBDXM.png" alt="image-20220812163919844" style="zoom:67%;" /></p><p>完成后双击安装，一路 next 即可（可以更改安装地址）</p><p><strong>测试：</strong></p><p>win+R 打开 cmd，输入 <code>node -v</code> 和 <code>npm -v</code>，检查版本</p><p><img src="https://s2.loli.net/2022/08/14/QoERV7q5nIG9Nlg.png" alt="image-20220812164420495" style="zoom:67%;" /></p><h3 id="修改路径"><a href="#修改路径" class="headerlink" title="修改路径"></a>修改路径</h3><p>因为如果不设置的话，安装模块的时候就会把模块装到C盘，占用C盘的空间，并且有可能安装好hexo后却无法使用，所以我们需要设置一下：</p><p>在 nodejs 文件夹中新建两个空文件夹 node_cache、node_global，</p><p><img src="https://s2.loli.net/2022/08/14/oxhq8bt25QPBGJK.png" alt="image-20220812164913897" style="zoom:67%;" /></p><p>打开cmd，输入如下两个命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;E:\nodejs\node_global&quot; //根据自己地址改</span><br><span class="line">npm config set cache &quot;E:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/14/SwMeVBIocqPlaGu.png" alt="image-20220812165204841" style="zoom:67%;" /></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>win11系统 -&gt; 我的电脑 -&gt; 右键属性 -&gt; 高级系统设置 -&gt; 环境变量</p><p>然后在系统变量中新建一个变量名为“NODE_PATH”，值为“E:\nodejs\node_global\node_modules”</p><p><img src="https://s2.loli.net/2022/08/14/EK23wAF96tnjuHh.png" alt="image-20220812165839664" style="zoom:67%;" /></p><p>然后编辑用户变量里的Path，将相应npm的路径改为：E:\nodejs\node_global，</p><p><img src="https://s2.loli.net/2022/08/14/LCJXyDmVdlcaoE6.png" alt="image-20220812170024835" style="zoom:67%;" /></p><p>一定要在改完后一路点确定到最后，不然保存不上</p><p><strong>测试：</strong></p><p>在 cmd 命令下执行 <code>npm install webpack -g</code>，然后 webpack 这个模块已经在我们设置默认的文件夹中了：</p><p><img src="https://s2.loli.net/2022/08/14/rlQ126mTcgdhCKX.png" alt="image-20220812170309019" style="zoom:67%;" /></p><h3 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h3><p>Hexo就是我们的个人博客网站的框架，在安装之前，我们要先在GitHub上创立一个仓库，名字必须为<code>username.github.io</code>（如果名字里有大写字母，要变成小写）如下图：</p><p><img src="https://s2.loli.net/2022/08/14/ZWbfCiL86hkMdEt.png" alt="image-20220812170745125" style="zoom:67%;" /></p><p>仓库一定要是 public 的</p><p>然后点击 settings -&gt; pages，出现下图所示就对了</p><p><img src="https://s2.loli.net/2022/08/14/uJSt5OkYU2cQi1N.jpg" alt="v2-6a000b836ae32c3d118c1fdeb4696f1c_r" style="zoom:67%;" /></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>首先新建立一个文件夹 Blog（博客相关东西的本地存放点，设在你想设的位置），点开 Blog 文件夹，在该文件夹内鼠标右键打开 Git Bush Here，输入npm命令 <code>npm install -g hexo-cli</code> 安装Hexo</p><p>安装完成后，输入 <code>hexo init</code> 命令初始化博客</p><p>然后输入 <code>hexo g</code> 静态部署</p><p>这时网页已经在本地部署完成，输入 <code>hexo s</code> 命令可以查看：</p><p><img src="https://s2.loli.net/2022/08/14/7XM9paWcfTVDUy8.png" alt="v2-11a0b4917c962bab07a48f7a04160e8b_r" style="zoom:67%;" /></p><p>浏览器网址栏输入 <a href="http://localhost:4000">http://localhost:4000</a> 就可以打开新部署的网页</p><p>看完后 ctr+C 停止运行服务器</p><h3 id="将-hexo-部署到-github"><a href="#将-hexo-部署到-github" class="headerlink" title="将 hexo 部署到 github"></a>将 hexo 部署到 github</h3><p>现在回到我们的 Blog 文件夹，用记事本打开 _config.yml 文件，如下图：</p><p><img src="https://s2.loli.net/2022/08/14/DwjKrdA6sOuiZxz.png" alt="image-20220812172036226" style="zoom:67%;" /></p><p>下滑到文件底部，补全为以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/liano3/liano3.github.io.git  #你的仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>然后回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令：<code>npm install hexo-deployer-git --save</code> ，然后分别输入以下三条命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>完成以后，打开浏览器，输入 <a href="https://yourname.github.io">https://yourname.github.io</a> 就可以打开你的网页了</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;node-js与hexo&quot;&gt;&lt;a href=&quot;#node-js与hexo&quot; class=&quot;headerlink&quot; title=&quot;node.js与hexo&quot;&gt;&lt;/a&gt;node.js与hexo&lt;/h2&gt;&lt;h3 id=&quot;安装node-js&quot;&gt;&lt;a href=&quot;#安装no</summary>
      
    
    
    
    <category term="博客" scheme="https://liano.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="搭建" scheme="https://liano.top/categories/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="自建博客" scheme="https://liano.top/tags/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://liano.top/tags/hexo/"/>
    
    <category term="github" scheme="https://liano.top/tags/github/"/>
    
    <category term="网页制作" scheme="https://liano.top/tags/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客（一）git与github</title>
    <link href="https://liano.top/posts/9b7b26aa/"/>
    <id>https://liano.top/posts/9b7b26aa/</id>
    <published>2022-08-12T12:32:17.386Z</published>
    <updated>2022-08-22T01:27:32.474Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问：搭建个人博客需要什么呢？</p><p>答：只需要耐心</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你需要在遇到问题时自己去网上查找答案，有时候一个问题就要查半天，最后还有可能没解决，目前网上的教程大都时间较长远了，操作起来会遇到各种问题，故做此教程以给新手避坑。</p><h2 id="github与git"><a href="#github与git" class="headerlink" title="github与git"></a>github与git</h2><h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><p>很简单，需要一个电子邮箱，注册个人免费版即可，<a href="https://github.com/">网址在这</a>，略</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p><a href="https://git-scm.com/">网址在这</a></p><p>点击 downloads -&gt; 选择系统 -&gt; 下载 -&gt; 一路next(可以更换安装地址) -&gt; 安装成功！</p><p><img src="https://s2.loli.net/2022/08/14/3ZsjkQd7MJcqIhE.png" alt="image-20220812083541223" style="zoom:67%;" /></p><p><strong>测试：</strong></p><p>右键，点击 Git Bash Here，输入 <code>git</code>，回车</p><p><img src="https://s2.loli.net/2022/08/14/RjNagtnJV8wLfiS.png" alt="image-20220812083839208" style="zoom:67%;" /></p><h3 id="绑定git与github"><a href="#绑定git与github" class="headerlink" title="绑定git与github"></a>绑定git与github</h3><p>首先我们得在 GitHub 上添加 SSH key 配置，要想生成SSH key，就要先安装 SSH，不过我们安装了 Git Bash，其应该自带了 SSH。检验一下是否安装 SSH，我们右键打开 Git Bash，输入 <code>ssh</code>，回车</p><p><img src="https://s2.loli.net/2022/08/14/nhBDEt6f2LbNpiJ.png" alt="image-20220812084617665" style="zoom:67%;" /></p><p>然后，输入 <code>ssh-keygen -t rsa</code> 命令（注意空格），表示我们指定 RSA 算法生成密钥，然后敲四次回车键，之后就就会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub（<strong>注意：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和 Shift+insert.</strong>）文件的位置在 Git Bash 上面都有显示</p><p>接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。复制公钥 id_rsa.pub 文件里的内容，你可以通过目录找到 id_rsa.pub 文件的位置，用记事本打开文件复制。如果你实在找不到文件也没有关系，按照以下步骤直接在 Git Bash 上打开就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh </span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/14/cTG7hXxdJl9nCqp.png" alt="image-20220812085712963" style="zoom:67%;" /></p><p>复制是 ctrl+insert 哦，别搞错了</p><p>接下来进入我们的 GitHub 主页，先点击右上角，再点击 settings，然后 SSH and GPG keys，最后 New SSH key，将复制的公钥 id_rsa.pub 的内容粘贴到 key 内，再点击 Add SSH key</p><p><img src="https://s2.loli.net/2022/08/14/OonHgKvaTq3GF8U.png" alt="image-20220812091931406" style="zoom: 50%;" /></p><p><strong>测试：</strong></p><p>右键打开gitbash，输入 <code>ssh -T git@github.com</code>，回车，可能会出现这种情况，输入 <code>yes</code> 即可</p><p><img src="https://s2.loli.net/2022/08/14/NOBCy9VvIU7FqHS.png" alt="v2-5b4f05ea2e2a7fb8b13fd35a9bafa8ce_720w" style="zoom:80%;" /></p><p><img src="https://s2.loli.net/2022/08/14/a3OmsiLPvKW42J9.png" alt="image-20220812092527889" style="zoom:80%;" /></p><h3 id="尝试提交文件"><a href="#尝试提交文件" class="headerlink" title="尝试提交文件"></a>尝试提交文件</h3><blockquote><p>这一步只是测试，跟着步骤做完后可以把本地仓库和上传上去的文件删掉</p></blockquote><p>首先通过 github 建立一个仓库，复制仓库地址</p><p><img src="https://s2.loli.net/2022/08/14/tzYluDygFwdUfQs.png" alt="image-20220812093105108" style="zoom: 50%;" /></p><p>在桌面右键打开 gitbash，输入 <code>git clone ...(刚复制的地址)</code>，将远程仓库 clone 到本地</p><p><img src="https://s2.loli.net/2022/08/14/DUIn3odGj7uvEzb.png" alt="image-20220812093535381" style="zoom: 67%;" /></p><p>现在我们在刚才克隆下来的文件夹里创建一个 text.txt 测试文件，在这个文件夹里右键打开 gitbash，我们使用 <code>git add</code> 命令将文件添加到了「临时缓冲区」，再用 <code>git commit -m &quot;提交信息&quot;</code> 将其提交到本地仓库</p><p><img src="https://s2.loli.net/2022/08/14/4juhNM6YrHTUc7C.png" alt="image-20220812094332129" style="zoom:67%;" /></p><p>如果你是第一次提交的话，会让你输入用户名和邮箱：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#你只要再加两行代码就行：</span><br><span class="line">$ git config --global user.name<span class="string">&quot;your name&quot;</span></span><br><span class="line">$ git config --global user.email<span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure><p>现在输入 <code>git push origin main</code> 命令，将本地仓库提交到远程仓库，origin是远程主机的名字：</p><p><img src="https://s2.loli.net/2022/08/14/j9XGc8nNkEyoUvS.png" alt="image-20220812094626288" style="zoom:67%;" /></p><p>第一次上传需要输入密码，上传成功后刷新github远程仓库页面，可以看到被提交上去的test.txt</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;问：搭建个人博客需要什么呢？&lt;/p&gt;
&lt;p&gt;答：只需要耐心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;你需要在遇到</summary>
      
    
    
    
    <category term="博客" scheme="https://liano.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="搭建" scheme="https://liano.top/categories/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="自建博客" scheme="https://liano.top/tags/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://liano.top/tags/hexo/"/>
    
    <category term="github" scheme="https://liano.top/tags/github/"/>
    
    <category term="网页制作" scheme="https://liano.top/tags/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://liano.top/posts/4a17b156/"/>
    <id>https://liano.top/posts/4a17b156/</id>
    <published>2022-08-12T12:32:17.384Z</published>
    <updated>2022-08-21T01:45:52.141Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
