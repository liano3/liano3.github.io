<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liano-blog</title>
  
  <subtitle>永不停步</subtitle>
  <link href="https://liano.top/atom.xml" rel="self"/>
  
  <link href="https://liano.top/"/>
  <updated>2022-08-20T11:26:57.991Z</updated>
  <id>https://liano.top/</id>
  
  <author>
    <name>Liano</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双指针</title>
    <link href="https://liano.top/posts/91a7e4d1/"/>
    <id>https://liano.top/posts/91a7e4d1/</id>
    <published>2022-08-20T11:26:11.770Z</published>
    <updated>2022-08-20T11:26:57.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。</p><p>若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。</p><p>若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是<br>排好序的。</p><p>对于 C++ 语言，指针还可以玩出很多新的花样。一些常见的关于指针的操作如下：</p><h3 id="指针与常量"><a href="#指针与常量" class="headerlink" title="指针与常量"></a>指针与常量</h3><blockquote><p>int x;<br>int * p1 &#x3D; &amp;x; &#x2F;&#x2F; 指针可以被修改，值也可以被修改<br>const int * p2 &#x3D; &amp;x; &#x2F;&#x2F; 指针可以被修改，值不可以被修改（const int）<br>int * const p3 &#x3D; &amp;x; &#x2F;&#x2F; 指针不可以被修改（* const），值可以被修改<br>const int * const p4 &#x3D; &amp;x; &#x2F;&#x2F; 指针不可以被修改，值也不可以被修改</p></blockquote><h3 id="指针函数与函数指针"><a href="#指针函数与函数指针" class="headerlink" title="指针函数与函数指针"></a>指针函数与函数指针</h3><blockquote><p>&#x2F;&#x2F; addition是指针函数，一个返回类型是指针的函数<br>int* addition(int a, int b) {<br>    int* sum &#x3D; new int(a + b);<br>    return sum;<br>}<br>int subtraction(int a, int b) {<br>    return a - b;<br>}<br>int operation(int x, int y, int (*func)(int, int)) {<br>    return (*func)(x,y);<br>}</p><p>&#x2F;&#x2F; minus是函数指针，指向函数的指针<br>int (*minus)(int, int) &#x3D; subtraction;<br>int* m &#x3D; addition(1, 2);<br>int n &#x3D; operation(3, *m, minus);</p></blockquote><h2 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h2><h3 id="两数之和II"><a href="#两数之和II" class="headerlink" title="两数之和II"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和II</a></h3><p><strong>题目描述：</strong></p><p>给你一个下标从 1 开始的整数数组 numbers，该数组已按非递减顺序排列，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2]，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length。</p><p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和index2。</p><p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]</p></blockquote><p>示例 2：</p><blockquote><p>输入：numbers &#x3D; [2,3,4], target &#x3D; 6<br>输出：[1,3]</p></blockquote><p>示例 3：</p><blockquote><p>输入：numbers &#x3D; [-1,0], target &#x3D; -1<br>输出：[1,2]</p></blockquote><p><strong>题解：</strong></p><p>采用方向相反的双指针遍历数组，因为已经排好序，所以如果两个数之和小于目标值，则左指针右移，若大于目标值，则右指针左移。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = numbers.<span class="built_in">size</span>() - <span class="number">1</span>, sum;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">sum = numbers[l] + numbers[r];</span><br><span class="line"><span class="keyword">if</span> (sum == target) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; target) </span><br><span class="line">            l++;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">           r--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并有序数组"><a href="#归并有序数组" class="headerlink" title="归并有序数组"></a>归并有序数组</h2><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">合并两个有序数组</a></h3><p><strong>题目描述：</strong></p><p>给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n，分别表示nums1 和 nums2 中的元素数目。</p><p>请你合并 nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0，应忽略。nums2 的长度为 n。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>注意：因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p></blockquote><p><strong>题解：</strong></p><p>因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即 nums1 的 m−1 位和 nums2 的 n−1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。<br>因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针 pos，以便复制。</p><blockquote><p>注意：如果 nums1 的数字已经复制完，不要忘记把 nums2 的数字继续复制；如果 nums2 的数字已经复制完，剩余 nums1 的数字不需要改变，因为它们已经被排好序。</p></blockquote><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> pos = m-- + n-- - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">nums1[pos--] = nums1[m]&gt;nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">nums1[pos--] = nums2[n--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表II</a></h3><p><strong>题目描述：</strong></p><p>给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>链表定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不允许修改链表。</p><p><strong>测试样例：</strong></p><p>示例：</p><blockquote><p>输入：<img src="https://s2.loli.net/2022/08/04/oYFjXthiG5B62pS.png" alt="circularlinkedlist.png" style="zoom:33%;" /><br>head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点</p></blockquote><p><strong>题解：</strong></p><p>对于链表找环路的问题，有一个通用的解法——&#x3D;&#x3D;快慢指针（Floyd 判圈法）&#x3D;&#x3D;。给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路；如果 fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">ListNode *slow = head, *fast = head;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!fast || !fast-&gt;next) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">&#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">fast = head;</span><br><span class="line"><span class="keyword">while</span> (fast != slow)&#123;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h3><p><strong>题目描述：</strong></p><p>给你一个字符串 s、一个字符串 t。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “”。s,t只由英文字母组成。</p><blockquote><p>注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”</p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”</p></blockquote><p>示例 3:</p><blockquote><p>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”</p></blockquote><p><strong>题解：</strong></p><p>本题使用滑动窗口求解，即两个指针 l 和 r 都是从最左端向最右端移动，且 l 的位置一定在 r 的左边或重合。先统计 t 中字符数量，滑动窗口至包含所有字符，l 左移，得到最短子串。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> t : T) &#123;</span><br><span class="line">        flag[t] = <span class="literal">true</span>;</span><br><span class="line">        chars[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, min_l = <span class="number">0</span>, min_size = S.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; S.<span class="built_in">size</span>(); r++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[S[r]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--chars[S[r]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt == T.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l - <span class="number">1</span> &lt; min_size) &#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag[S[l]] &amp;&amp; ++chars[S[l]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_size&gt;S.<span class="built_in">size</span>() ? <span class="string">&quot;&quot;</span> : S.<span class="built_in">substr</span>(min_l, min_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="平方数之和"><a href="#平方数之和" class="headerlink" title="平方数之和"></a><a href="https://leetcode.cn/problems/sum-of-square-numbers/">平方数之和</a></h3><p><strong>题目描述：</strong></p><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2^ + b^2^ &#x3D; c 。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：c &#x3D; 5<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：c &#x3D; 3<br>输出：false</p></blockquote><p><strong>题解：</strong></p><p>双指针，一个指向0，另一个指向根号c取整，左指针向右移或者右指针向左移，就可以避免双重循环解决问题。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> l = <span class="number">0</span>, r = <span class="built_in">sqrt</span>(c) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        ans = l * l + r * r;</span><br><span class="line">        <span class="keyword">if</span> (ans == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; c)</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证回文字符串II"><a href="#验证回文字符串II" class="headerlink" title="验证回文字符串II"></a><a href="https://leetcode.cn/problems/valid-palindrome-ii/">验证回文字符串II</a></h3><p><strong>题目描述：</strong></p><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: s &#x3D; “aba”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: s &#x3D; “abca”<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: s &#x3D; “abc”<br>输出: false</p></blockquote><p><strong>题解：</strong></p><p>双指针，一个在开头，一个在末尾，相向移动，不符合的字符记录下来即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> low , <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = low, j = high; i &lt; j; i++,j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[j]) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[l] == s[r]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">checkPalindrome</span>(s, l+<span class="number">1</span>, r) || <span class="built_in">checkPalindrome</span>(s, l, r<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除字母匹配字符串"><a href="#删除字母匹配字符串" class="headerlink" title="删除字母匹配字符串"></a><a href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/">删除字母匹配字符串</a></h3><p><strong>题目描述：</strong></p><p>给你一个字符串 s 和一个字符串数组 dictionary，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。均只由小写英文字母组成。</p><p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：s &#x3D; “abpcplea”, dictionary &#x3D; [“ale”,”apple”,”monkey”,”plea”]<br>输出：”apple”</p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “abpcplea”, dictionary &#x3D; [“a”,”b”,”c”]<br>输出：”a”</p></blockquote><p><strong>题解：</strong></p><p>双指针，一个用于遍历 s，另一个遍历 d 中的字符串，记录满足题目要求的字符串即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">    string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (string d : dictionary) &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &lt; d.<span class="built_in">size</span>() </span><br><span class="line">            || (ans.<span class="built_in">size</span>() == d.<span class="built_in">size</span>() &amp;&amp; ans.<span class="built_in">compare</span>(d) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (m &lt; s.<span class="built_in">size</span>() &amp;&amp; n &lt; d.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[m] == d[n]) </span><br><span class="line">                    n++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n == d.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ans = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="至多包含-k-个不同字符的最长子串"><a href="#至多包含-k-个不同字符的最长子串" class="headerlink" title="至多包含 k 个不同字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/">至多包含 k 个不同字符的最长子串</a></h3><p><strong>题目描述：</strong></p><p>给定一个字符串 s，找出至多包含 k 个不同字符的最长子串 T 的长度。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：s &#x3D; “eceba”, k &#x3D; 2<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “aa”, k &#x3D; 1<br>输出：2</p></blockquote><p><strong>题解：</strong></p><p>滑动窗口。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &lt;= k)</span><br><span class="line">            m[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(m.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--m[s[j]] == <span class="number">0</span>)</span><br><span class="line">                m.<span class="built_in">erase</span>(s[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为这题是付费的，所以我并不确定是否完全AC，仅供参考</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法解释&quot;&gt;&lt;a href=&quot;#算法解释&quot; class=&quot;headerlink&quot; title=&quot;算法解释&quot;&gt;&lt;/a&gt;算法解释&lt;/h2&gt;&lt;p&gt;双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。&lt;/p&gt;
&lt;p&gt;若两个指针</summary>
      
    
    
    
    <category term="双指针" scheme="https://liano.top/categories/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="双指针" scheme="https://liano.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://liano.top/posts/a4ce31d2/"/>
    <id>https://liano.top/posts/a4ce31d2/</id>
    <published>2022-08-19T14:30:21.128Z</published>
    <updated>2022-08-20T10:18:55.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h2><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a></h3><p><strong>题目描述：</strong></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]<br>输出: 2</p></blockquote><p><strong>题解：</strong></p><p>两种角度，一，从小孩角度，先满足胃口小的，把大于且最接近的饼干分配给他；二，从饼干角度，先分配分量大的饼干给胃口小于且最接近的孩子。将两数组分别排序，遍历比较即可实现。</p><blockquote><p>思考：为什么小孩要先满足胃口小的，饼干要先分配大的？试一试。</p></blockquote><p><strong>代码：</strong></p><p>角度一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; children, vector&lt;<span class="type">int</span>&gt;&amp; cookies)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(cookies.<span class="built_in">begin</span>(), cookies.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; children.<span class="built_in">size</span>() &amp;&amp; cookie &lt; cookies.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (children[child] &lt;= cookies[cookie]) </span><br><span class="line">            child++;</span><br><span class="line">    cookie++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角度二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; children, vector&lt;<span class="type">int</span>&gt;&amp; cookies)</span> </span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="built_in">sort</span>(cookies.<span class="built_in">begin</span>(), cookies.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; children.<span class="built_in">size</span>() &amp;&amp; cookie &lt; cookies.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cookies[cookie] &gt;= children[child]) </span><br><span class="line">            cookie++;</span><br><span class="line">        child++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode.cn/problems/candy/">分发糖果</a></h3><p><strong>题目描述：</strong></p><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li><li>请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。</li></ul><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：ratings &#x3D; [1,0,2]<br>输出：5</p></blockquote><p>示例 2：</p><blockquote><p>输入：ratings &#x3D; [1,2,2]<br>输出：4</p></blockquote><p><strong>题解：</strong></p><p>首先每个孩子分一个，再从左往右遍历一遍，保证每个孩子相对右边相邻孩子糖果数是正确的，再从右向左遍历一遍，保证每个孩子相对左边相邻孩子糖果数正确，最后求和即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> size = ratings.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (ratings[i] &lt; ratings[i<span class="number">-1</span>] &amp;&amp; num[i<span class="number">-1</span>] &lt;= num[i]) &#123;</span><br><span class="line">num[i<span class="number">-1</span>] = num[i] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间</a></h3><p><strong>题目描述：</strong></p><p>给定一个区间的集合 intervals，其中 intervals[i] &#x3D; [starti, endi]。返回需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]<br>输出: 2</p></blockquote><p>示例 3:</p><blockquote><p>输入: intervals &#x3D; [ [1,2], [2,3] ]<br>输出: 0</p></blockquote><p><strong>题解：</strong></p><p>又是一个排序题目，两个角度：一，将区间右端升序排列，从左向右，优先保留右端较小且不重叠的区间；二，将区间左端降序排列，从左向右，优先保留左端较大且不重叠的区间。</p><p>如下图所示：</p><img src="https://s2.loli.net/2022/08/04/73un2QPUvOzLmGC.png" alt="v2-8af99daabb5a1a1f8c7d9fe6dcda2a2a_r.jpg" style="zoom:67%;" /><p><strong>代码：</strong></p><p>角度一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;);</span><br><span class="line"><span class="type">int</span> removed = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) &#123;</span><br><span class="line">removed++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角度二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];&#125;);</span><br><span class="line"><span class="type">int</span> removed = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; prev) &#123;</span><br><span class="line">removed++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">prev = intervals[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a><a href="https://leetcode.cn/problems/can-place-flowers/">种花问题</a></h3><p><strong>题目描述：</strong></p><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2<br>输出：false</p></blockquote><p><strong>题解：</strong></p><p>问题可以简化为一个基本模型，两端有花，中间空缺，更复杂的情况可以通过切割得到多个简单情况，且互相独立。又因为基本模型中两端的花地位相同，所以直接从左向右遍历，能种则种，即可得到全局最优。</p><p>这里提供另一个想法，虽然与贪心算法无关，但很巧妙，把花坛两端加上0，就可以将两端的特殊情况化为一般，只要有连续的3片空地就能种一朵花。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; flowerbed.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span> </span><br><span class="line">           &amp;&amp; (i == <span class="number">0</span> || flowerbed[i<span class="number">-1</span>] == <span class="number">0</span>) </span><br><span class="line">           &amp;&amp; (i == flowerbed.<span class="built_in">size</span>() - <span class="number">1</span> || flowerbed[i+<span class="number">1</span>] == <span class="number">0</span>)) &#123;</span><br><span class="line">               n--;</span><br><span class="line">               flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">           &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里用了 || 符号的短路性，判断过程不会越界</p></blockquote><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h3><p><strong>题目描述：</strong></p><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend 之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points，返回引爆所有气球所必须射出的最小弓箭数。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]<br>输出：2</p></blockquote><p><strong>题解：</strong></p><p>这题和上面的无重叠区间很相像，本题要求最少的箭头数量，能一块扎爆的是有重叠区间的，所以在一些重叠的区间中留下一个就行，其他的移除，和例题本质上是一样的，目标都是把一组互不重叠的区间全部找出来，稍微修改一下例题的代码即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), </span><br><span class="line">         [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;);</span><br><span class="line"><span class="type">int</span> removed = <span class="number">0</span>, prev = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= prev) &#123;</span><br><span class="line">removed++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">prev = points[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> points.<span class="built_in">size</span>() - removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：本题中区间边界重合也算重合</p></blockquote><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">划分字母区间</a></h3><p><strong>题目描述：</strong></p><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p><strong>测试样例：</strong></p><blockquote><p>输入：S &#x3D; “ababcbacadefegdehijhklij”<br>输出：[9,7,8]</p></blockquote><p><strong>题解：</strong></p><p>这题依然可以转化为区间问题，两次遍历得到每个字母的始末位置，然后合并区间即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        last[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last[s[i] - <span class="string">&#x27;a&#x27;</span>] &gt; end)</span><br><span class="line">            end = last[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (end == i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h3><p><strong>题目描述：</strong></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买或出售股票。你在任何时候最多只能持有一股股票。你也可先购买，然后在同一天出售。返回你能获得的最大利润。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：prices &#x3D; [7,1,5,3,6,4]<br>输出：7</p></blockquote><p>示例 2：</p><blockquote><p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0</p></blockquote><p><strong>题解：</strong></p><p>题目只要求最大利润，所以直接贪心计算差价即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>])</span><br><span class="line">            ans += (prices[i+<span class="number">1</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="*根据身高重建队列"></a>*<a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h3><p><strong>题目描述：</strong></p><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p><strong>测试样例：</strong></p><p>示例 1：</p><blockquote><p>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p></blockquote><p><strong>题解：</strong></p><p>先排序，身高降序排列，然后 k 升序，先将最高的按 k 值升序放入队列中，然后插入个子矮的，也是按 k 值插入即可，不会影响前面已经插入好的。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line"><span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : people) &#123;</span><br><span class="line">        ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>() + n[<span class="number">1</span>], n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; people.size(); i++)&#123;  </span></span><br><span class="line">        <span class="comment">//res.insert(res.begin()+people[i][1], people[i]);</span></span><br><span class="line">    <span class="comment">//&#125;与上面等价</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递减数列"><a href="#非递减数列" class="headerlink" title="非递减数列"></a><a href="https://leetcode.cn/problems/non-decreasing-array/">非递减数列</a></h3><p><strong>题目描述：</strong></p><p>给你一个长度为 n 的整数数组 nums，请你判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的：对于数组中任意的 i (0&lt;&#x3D;i&lt;&#x3D;n-2)，总满足 nums[i] &lt;&#x3D; nums[i + 1]。</p><p><strong>测试样例：</strong></p><p>示例 1:</p><blockquote><p>输入: nums &#x3D; [4,2,3]<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums &#x3D; [4,2,1]<br>输出: false</p></blockquote><p><strong>题解：</strong></p><p>只要求出最少修改次数，然后与 1 比较即可，对于不符合条件的两个相邻的数，有两种方案，一，修改前面一个，二，修改后面一个，具体采用哪种方案要看修改后是否会影响前面已经符合的部分，比较这两个数的前面一个数和这两个数中后面一个数的大小即可做出判断。</p><blockquote><p>注：应修改至恰好满足，即不符合的变成相等的，这样对其他部分影响小，修改次数也最少</p></blockquote><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPossibility</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i+<span class="number">1</span>] &gt;= nums[i<span class="number">-1</span>])</span><br><span class="line">                nums[i] = nums[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i+<span class="number">1</span>] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分配问题&quot;&gt;&lt;a href=&quot;#分配问题&quot; class=&quot;headerlink&quot; title=&quot;分配问题&quot;&gt;&lt;/a&gt;分配问题&lt;/h2&gt;&lt;h3 id=&quot;分发饼干&quot;&gt;&lt;a href=&quot;#分发饼干&quot; class=&quot;headerlink&quot; title=&quot;分发饼干&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://liano.top/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://liano.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://liano.top/tags/c/"/>
    
    <category term="贪心算法" scheme="https://liano.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>论如何优雅地写博客</title>
    <link href="https://liano.top/posts/a5649831/"/>
    <id>https://liano.top/posts/a5649831/</id>
    <published>2022-08-14T08:18:52.953Z</published>
    <updated>2022-08-20T10:18:48.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花费了零零碎碎将近三天来搭建并美化个人博客网站，不好好写东西都对不起自己😉，本篇介绍如何优雅地写博客，主要内容分为三部分，一是如何发布博客，二是如何优雅地使用latex公式，三是如何优雅地插入图片。</p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><blockquote><p>问：如何发布博客？</p><p>答：将要上传的 md 文档放入&#x2F;source&#x2F;_posts中，素质三连 <code>git clean</code>,<code>git g</code>,<code>git d</code> 即可</p></blockquote><p>要上传的 md 文档前面的 front-matter 部分写上 title，categories，tags 等文章信息，具体可以写哪些信息详见上一篇。</p><p>进入源码模式，格式如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 论如何优雅地写博客</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> 使用技巧</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">-</span> Typora</span><br><span class="line"><span class="bullet">-</span> PicGo</span><br><span class="line"><span class="bullet">-</span> SM.MS图床</span><br><span class="line"><span class="bullet">-</span> hexo</span><br><span class="line"><span class="section">- 写博客</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="latex公式"><a href="#latex公式" class="headerlink" title="latex公式"></a>latex公式</h2><p>众所周知，Typora 以其出色的即时预览功能和对 latex 公式的支持广受欢迎，虽然现在付费了，但还是可以想办法白嫖的，<a href="https://github.com/liano3/typora_theme">方法在这</a>，里面还附赠了一套来自 op 的精美主题。</p><p>但是，当我将用 Typora 写的文档放入博客中时，问题出现了！里面的 latex 公式都寄了！下面讲解解决方法：</p><h3 id="更换插件"><a href="#更换插件" class="headerlink" title="更换插件"></a>更换插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><h3 id="更改插件文件"><a href="#更改插件文件" class="headerlink" title="更改插件文件"></a>更改插件文件</h3><p>进入项目更目录下：<code>node_modules\kramed\lib\rules\inline.js</code></p><p>修改这么两行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="attr">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line">+ <span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span></span><br><span class="line">- <span class="attr">em</span>: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">+ <span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span></span><br></pre></td></tr></table></figure><p>分别在第 11 行和 20 行左右，减号后面是删掉的内容，加号后面是要加上的内容</p><h3 id="配置主题文件"><a href="#配置主题文件" class="headerlink" title="配置主题文件"></a>配置主题文件</h3><p>_config.butterfly.yml 中更改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="更改部分语法"><a href="#更改部分语法" class="headerlink" title="更改部分语法"></a>更改部分语法</h3><p>如果上述操作全部完成，还是不能成功，看看有没有语法问题。</p><p>比如，如果在公式内连续使用两个花括号，必须加上空格。</p><p>如下面的会渲染失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L_p  = (\sum_&#123;i=1&#125;^m |x_i - y_i |^&#123;p&#125;  )^&#123;&#123;\tfrac&#123;1&#125;&#123;p&#125;&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>在连续的花括号之间加上空格即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L_p  = (\sum_&#123;i=1&#125;^m |x_i - y_i |^&#123;p&#125;  )^&#123; &#123;\tfrac&#123;1&#125; &#123;p&#125; &#125; &#125;$$</span><br></pre></td></tr></table></figure><h2 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h2><p>个人博客不能没有图床，就像西方不能没有耶路撒冷🤣，总之一个图床工具还是非常有用的，首先是无论是 github pages 还是 gitee pages 都是有 1G 的容量限制的，图片传多了就寄了。另外，图床可以实现跨平台跨设备使用同一张图片，分享或上传 md 文档再也不用连带着图片文件夹压缩了。</p><p>本着白嫖精神，并考虑到 github 访问速度慢，gitee 禁止外链，我选择 SM.MS 图床配合 PicGo 工具。SM.MS图床免费用户有 5G 容量（再多点就好了😊)，访问速度还可以。下面介绍如何配置：</p><h3 id="下载PicGo"><a href="#下载PicGo" class="headerlink" title="下载PicGo"></a>下载PicGo</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">网址在这</a>，向下翻，下载 2.3.0 版本，如下图：</p><img src="https://s2.loli.net/2022/08/14/7vVblZ2Ijcp5mxO.png" alt="image-20220814215545932" style="zoom: 67%;" /><p>下载完成后双击即可安装。</p><h3 id="配置SM-MS"><a href="#配置SM-MS" class="headerlink" title="配置SM.MS"></a>配置SM.MS</h3><p><a href="https://sm.ms/">网址在这</a>，注册登录后点击菜单栏的 user -&gt; DashBoard</p><img src="https://s2.loli.net/2022/08/14/9x3IEp8Cf1P2biz.png" alt="Snipaste_2022-08-14_22-03-11" style="zoom:67%;" /><p>点击 API Token，复制 Secret Token 的内容，如果为空就点击下面的 Generate</p><img src="https://s2.loli.net/2022/08/14/olSEtRNqg6aXhbw.png" alt="Snipaste_2022-08-14_22-07-14" style="zoom:67%;" /><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p>打开 PicGo，配置 token，即把刚才复制的内容放进来</p><blockquote><p>注意：PicGo 双击打开可能没反应，实际在任务栏可以看到</p></blockquote><img src="https://s2.loli.net/2022/08/14/f2vbSonTrl4JAGt.png" alt="Snipaste_2022-08-14_22-10-57" style="zoom:67%;" /><h3 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h3><p>文件 -&gt; 偏好设置 -&gt; 图像，配置如下：</p><img src="https://s2.loli.net/2022/08/14/LZhqWcoHMm3iABl.png" alt="Snipaste_2022-08-14_22-17-01" style="zoom:67%;" /><p>重启 Typora，即可优雅地写博客。</p><blockquote><p>注意：最后的验证可能不成功，重启之后新建一个 md 文档试试，如果能上传，就不用管</p></blockquote><p>另外，推荐一个截图工具 snipaste，超级好用！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;花费了零零碎碎将近三天来搭建并美化个人博客网站，不好好写东西都对不起自己😉，本篇介绍如何优雅地写博客，主要内容分为三部分，一是如何发布博客</summary>
      
    
    
    
    <category term="使用技巧" scheme="https://liano.top/categories/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="hexo" scheme="https://liano.top/tags/hexo/"/>
    
    <category term="Typora" scheme="https://liano.top/tags/Typora/"/>
    
    <category term="PicGo" scheme="https://liano.top/tags/PicGo/"/>
    
    <category term="SM.MS图床" scheme="https://liano.top/tags/SM-MS%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="写博客" scheme="https://liano.top/tags/%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客（三）主题配置</title>
    <link href="https://liano.top/posts/476e1d48/"/>
    <id>https://liano.top/posts/476e1d48/</id>
    <published>2022-08-12T12:43:49.187Z</published>
    <updated>2022-08-14T07:32:58.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有一个自己的博客还不够优雅，搭配上一个酷炫的主题才能更优雅地书写，本文以 butterfly主题为基础，谈谈博客界面的美化与功能细节的添加</p><h2 id="应用butterfly主题"><a href="#应用butterfly主题" class="headerlink" title="应用butterfly主题"></a>应用butterfly主题</h2><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>在hexo根目录里打开gitbash，输入如下命令：</p><p><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></p><p>成功后如图所示：</p><img src="https://s2.loli.net/2022/08/14/8vnQBeaSTY1FKD7.png" alt="image-20220812205140208" style="zoom:67%;" /><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>然后进入根目录里的_config.yml文件，将主题改为butterfly:</p><img src="https://s2.loli.net/2022/08/14/p2FHgXciI1qaeBk.png" alt="image-20220812205422129" style="zoom:67%;" /><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p><img src="https://s2.loli.net/2022/08/14/GqsVtvJZd9RXhkb.png" alt="image-20220812205725232" style="zoom:67%;" /><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>在根目录创建一个名为 <code>_config.butterfly.yml</code> 的文件，将<strong>butterfly主题目录里的</strong>文件_config.yml内容复制到新建的文件中，以后更改配置时在新建的这个文件里更改，因为解析时新建的这个文件优先级高，这样既可以有效修改配置，又避免升级主题时数据丢失。</p><img src="https://s2.loli.net/2022/08/14/i2BdMIhmT9F7gQq.png" style="zoom:67%;" /><p>注意：原来的文件不要删除</p><h2 id="网页功能配置"><a href="#网页功能配置" class="headerlink" title="网页功能配置"></a>网页功能配置</h2><h3 id="front-matter"><a href="#front-matter" class="headerlink" title="front-matter"></a>front-matter</h3><p>首先介绍一下 front-matter，顾名思义，是在md文档中最前面，以—为分界线，用于指定参数或变量的部分</p><h4 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h4><p>相关参数如下表：</p><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>[必需]页面标题</td></tr><tr><td>date</td><td>[必需]页面创建日期</td></tr><tr><td>type</td><td>[必需]标签、分类和友链三个页面需要</td></tr><tr><td>updated</td><td>页面更新日期</td></tr><tr><td>comments</td><td>显示评论模块</td></tr><tr><td>top_img</td><td>页面顶部图片</td></tr><tr><td>mathjax</td><td>per_page:false时才需要配置</td></tr></tbody></table><h4 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h4><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>[必需]文章标题</td></tr><tr><td>date</td><td>[必需]创建日期</td></tr><tr><td>updated</td><td>更新日期</td></tr><tr><td>tags</td><td>标签</td></tr><tr><td>categories</td><td>文章分类</td></tr><tr><td>cover</td><td>文章缩略图</td></tr><tr><td>mathjax</td><td>per_page:false时才需要配置</td></tr></tbody></table><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>首先进入主题配置文件_config.butterfly.yml，更改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#菜单栏</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br></pre></td></tr></table></figure><p>根据自己情况，还可以再加，我只创建了这几个页面。</p><p>然后前往你的 Hexo 博客的根目录，输入 <code>hexo new page tags</code>，你会找到source&#x2F;tags&#x2F;index.md这个文件，修改这个文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-08-11 19:27:10</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">/img/page.png</span>  <span class="comment">#自己根据你想设置的图片的位置修改</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>分类页操作步骤同上，把命令改为 <code>hexo new page categories</code> 即可</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2><p>东西太多了，写不下去了，关于主题方面的配置，官方文档里写的比我清晰多了，自己看去吧：<a href="https://butterfly.js.org/">地址在这</a> （我好懒🤣</p><p>另外，官方文档的图片显示需要梯子，推荐greenhub，免费好用</p><p>下一篇更如何与typora，picgo，smms图床结合，提升书写体验，敬请期待~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有一个自己的博客还不够优雅，搭配上一个酷炫的主题才能更优雅地书写，本文以 butterfly主题为基础，谈谈博客界面的美化与功能细节的添加&lt;</summary>
      
    
    
    
    <category term="网页制作" scheme="https://liano.top/categories/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
    
    <category term="自建博客" scheme="https://liano.top/tags/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://liano.top/tags/hexo/"/>
    
    <category term="github" scheme="https://liano.top/tags/github/"/>
    
    <category term="网页制作" scheme="https://liano.top/tags/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客（二）node.js与hexo</title>
    <link href="https://liano.top/posts/fd836635/"/>
    <id>https://liano.top/posts/fd836635/</id>
    <published>2022-08-12T12:32:17.387Z</published>
    <updated>2022-08-17T12:28:47.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-js与hexo"><a href="#node-js与hexo" class="headerlink" title="node.js与hexo"></a>node.js与hexo</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p><a href="https://nodejs.org/en/">网址在这</a>，下载左边那个版本</p><img src="https://s2.loli.net/2022/08/14/b75yF3ReITtBDXM.png" alt="image-20220812163919844" style="zoom:67%;" /><p>完成后双击安装，一路 next 即可（可以更改安装地址）</p><p><strong>测试：</strong></p><p>win+R 打开 cmd，输入 <code>node -v</code> 和 <code>npm -v</code>，检查版本</p><img src="https://s2.loli.net/2022/08/14/QoERV7q5nIG9Nlg.png" alt="image-20220812164420495" style="zoom:67%;" /><h3 id="修改路径"><a href="#修改路径" class="headerlink" title="修改路径"></a>修改路径</h3><p>因为如果不设置的话，安装模块的时候就会把模块装到C盘，占用C盘的空间，并且有可能安装好hexo后却无法使用，所以我们需要设置一下：</p><p>在 nodejs 文件夹中新建两个空文件夹 node_cache、node_global，</p><img src="https://s2.loli.net/2022/08/14/oxhq8bt25QPBGJK.png" alt="image-20220812164913897" style="zoom:67%;" /><p>打开cmd，输入如下两个命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;E:\nodejs\node_global&quot; //根据自己地址改</span><br><span class="line">npm config set cache &quot;E:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/08/14/SwMeVBIocqPlaGu.png" alt="image-20220812165204841" style="zoom:67%;" /><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>win11系统 -&gt; 我的电脑 -&gt; 右键属性 -&gt; 高级系统设置 -&gt; 环境变量</p><p>然后在系统变量中新建一个变量名为“NODE_PATH”，值为“E:\nodejs\node_global\node_modules”</p><img src="https://s2.loli.net/2022/08/14/EK23wAF96tnjuHh.png" alt="image-20220812165839664" style="zoom:67%;" /><p>然后编辑用户变量里的Path，将相应npm的路径改为：E:\nodejs\node_global，</p><img src="https://s2.loli.net/2022/08/14/LCJXyDmVdlcaoE6.png" alt="image-20220812170024835" style="zoom:67%;" /><p>一定要在改完后一路点确定到最后，不然保存不上</p><p><strong>测试：</strong></p><p>在 cmd 命令下执行 <code>npm install webpack -g</code>，然后 webpack 这个模块已经在我们设置默认的文件夹中了：</p><img src="https://s2.loli.net/2022/08/14/rlQ126mTcgdhCKX.png" alt="image-20220812170309019" style="zoom:67%;" /><h3 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h3><p>Hexo就是我们的个人博客网站的框架，在安装之前，我们要先在GitHub上创立一个仓库，名字必须为<code>username.github.io</code>（如果名字里有大写字母，要变成小写）如下图：</p><img src="https://s2.loli.net/2022/08/14/ZWbfCiL86hkMdEt.png" alt="image-20220812170745125" style="zoom:67%;" /><p>仓库一定要是 public 的</p><p>然后点击 settings -&gt; pages，出现下图所示就对了</p><img src="https://s2.loli.net/2022/08/14/uJSt5OkYU2cQi1N.jpg" alt="v2-6a000b836ae32c3d118c1fdeb4696f1c_r" style="zoom:67%;" /><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>首先新建立一个文件夹 Blog（博客相关东西的本地存放点，设在你想设的位置），点开 Blog 文件夹，在该文件夹内鼠标右键打开 Git Bush Here，输入npm命令 <code>npm install -g hexo-cli</code> 安装Hexo</p><p>安装完成后，输入 <code>hexo init</code> 命令初始化博客</p><p>然后输入 <code>hexo g</code> 静态部署</p><p>这时网页已经在本地部署完成，输入 <code>hexo s</code> 命令可以查看：</p><img src="https://s2.loli.net/2022/08/14/7XM9paWcfTVDUy8.png" alt="v2-11a0b4917c962bab07a48f7a04160e8b_r" style="zoom:67%;" /><p>浏览器网址栏输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以打开新部署的网页</p><p>看完后 ctr+C 停止运行服务器</p><h3 id="将-hexo-部署到-github"><a href="#将-hexo-部署到-github" class="headerlink" title="将 hexo 部署到 github"></a>将 hexo 部署到 github</h3><p>现在回到我们的 Blog 文件夹，用记事本打开 _config.yml 文件，如下图：</p><img src="https://s2.loli.net/2022/08/14/DwjKrdA6sOuiZxz.png" alt="image-20220812172036226" style="zoom:67%;" /><p>下滑到文件底部，补全为以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/liano3/liano3.github.io.git  #你的仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>然后回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令：<code>npm install hexo-deployer-git --save</code> ，然后分别输入以下三条命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>完成以后，打开浏览器，输入 <a href="https://yourname.github.io/">https://yourname.github.io</a> 就可以打开你的网页了</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;node-js与hexo&quot;&gt;&lt;a href=&quot;#node-js与hexo&quot; class=&quot;headerlink&quot; title=&quot;node.js与hexo&quot;&gt;&lt;/a&gt;node.js与hexo&lt;/h2&gt;&lt;h3 id=&quot;安装node-js&quot;&gt;&lt;a href=&quot;#安装no</summary>
      
    
    
    
    <category term="网页制作" scheme="https://liano.top/categories/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
    
    <category term="自建博客" scheme="https://liano.top/tags/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://liano.top/tags/hexo/"/>
    
    <category term="github" scheme="https://liano.top/tags/github/"/>
    
    <category term="网页制作" scheme="https://liano.top/tags/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客（一）git与github</title>
    <link href="https://liano.top/posts/9b7b26aa/"/>
    <id>https://liano.top/posts/9b7b26aa/</id>
    <published>2022-08-12T12:32:17.386Z</published>
    <updated>2022-08-14T07:08:08.795Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问：搭建个人博客需要什么呢？</p><p>答：只需要耐心</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你需要在遇到问题时自己去网上查找答案，有时候一个问题就要查半天，最后还有可能没解决，目前网上的教程大都时间较长远了，操作起来会遇到各种问题，故做此教程以给新手避坑。</p><h2 id="github与git"><a href="#github与git" class="headerlink" title="github与git"></a>github与git</h2><h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><p>很简单，需要一个电子邮箱，注册个人免费版即可，<a href="https://github.com/">网址在这</a>，略</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p><a href="https://git-scm.com/">网址在这</a></p><p>点击 downloads -&gt; 选择系统 -&gt; 下载 -&gt; 一路next(可以更换安装地址) -&gt; 安装成功！</p><img src="https://s2.loli.net/2022/08/14/3ZsjkQd7MJcqIhE.png" alt="image-20220812083541223" style="zoom:67%;" /><p><strong>测试：</strong></p><p>右键，点击 Git Bash Here，输入 <code>git</code>，回车</p><img src="https://s2.loli.net/2022/08/14/RjNagtnJV8wLfiS.png" alt="image-20220812083839208" style="zoom:67%;" /><h3 id="绑定git与github"><a href="#绑定git与github" class="headerlink" title="绑定git与github"></a>绑定git与github</h3><p>首先我们得在 GitHub 上添加 SSH key 配置，要想生成SSH key，就要先安装 SSH，不过我们安装了 Git Bash，其应该自带了 SSH。检验一下是否安装 SSH，我们右键打开 Git Bash，输入 <code>ssh</code>，回车</p><img src="https://s2.loli.net/2022/08/14/nhBDEt6f2LbNpiJ.png" alt="image-20220812084617665" style="zoom:67%;" /><p>然后，输入 <code>ssh-keygen -t rsa</code> 命令（注意空格），表示我们指定 RSA 算法生成密钥，然后敲四次回车键，之后就就会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub（**注意：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和 Shift+insert.**）文件的位置在 Git Bash 上面都有显示</p><p>接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。复制公钥 id_rsa.pub 文件里的内容，你可以通过目录找到 id_rsa.pub 文件的位置，用记事本打开文件复制。如果你实在找不到文件也没有关系，按照以下步骤直接在 Git Bash 上打开就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh </span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/08/14/cTG7hXxdJl9nCqp.png" alt="image-20220812085712963" style="zoom:67%;" /><p>复制是 ctrl+insert 哦，别搞错了</p><p>接下来进入我们的 GitHub 主页，先点击右上角，再点击 settings，然后 SSH and GPG keys，最后 New SSH key，将复制的公钥 id_rsa.pub 的内容粘贴到 key 内，再点击 Add SSH key</p><img src="https://s2.loli.net/2022/08/14/OonHgKvaTq3GF8U.png" alt="image-20220812091931406" style="zoom: 50%;" /><p><strong>测试：</strong></p><p>右键打开gitbash，输入 <code>ssh -T git@github.com</code>，回车，可能会出现这种情况，输入 <code>yes</code> 即可</p><img src="https://s2.loli.net/2022/08/14/NOBCy9VvIU7FqHS.png" alt="v2-5b4f05ea2e2a7fb8b13fd35a9bafa8ce_720w" style="zoom:80%;" /><img src="https://s2.loli.net/2022/08/14/a3OmsiLPvKW42J9.png" alt="image-20220812092527889" style="zoom:80%;" /><h3 id="尝试提交文件"><a href="#尝试提交文件" class="headerlink" title="尝试提交文件"></a>尝试提交文件</h3><blockquote><p>这一步只是测试，跟着步骤做完后可以把本地仓库和上传上去的文件删掉</p></blockquote><p>首先通过 github 建立一个仓库，复制仓库地址</p><img src="https://s2.loli.net/2022/08/14/tzYluDygFwdUfQs.png" alt="image-20220812093105108" style="zoom: 50%;" /><p>在桌面右键打开 gitbash，输入 <code>git clone ...(刚复制的地址)</code>，将远程仓库 clone 到本地</p><img src="https://s2.loli.net/2022/08/14/DUIn3odGj7uvEzb.png" alt="image-20220812093535381" style="zoom: 67%;" /><p>现在我们在刚才克隆下来的文件夹里创建一个 text.txt 测试文件，在这个文件夹里右键打开 gitbash，我们使用 <code>git add</code> 命令将文件添加到了「临时缓冲区」，再用 <code>git commit -m &quot;提交信息&quot;</code> 将其提交到本地仓库</p><img src="https://s2.loli.net/2022/08/14/4juhNM6YrHTUc7C.png" alt="image-20220812094332129" style="zoom:67%;" /><p>如果你是第一次提交的话，会让你输入用户名和邮箱：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#你只要再加两行代码就行：</span><br><span class="line">$ git config --global user.name<span class="string">&quot;your name&quot;</span></span><br><span class="line">$ git config --global user.email<span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure><p>现在输入 <code>git push origin main</code> 命令，将本地仓库提交到远程仓库，origin是远程主机的名字：</p><img src="https://s2.loli.net/2022/08/14/j9XGc8nNkEyoUvS.png" alt="image-20220812094626288" style="zoom:67%;" /><p>第一次上传需要输入密码，上传成功后刷新github远程仓库页面，可以看到被提交上去的test.txt</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;问：搭建个人博客需要什么呢？&lt;/p&gt;
&lt;p&gt;答：只需要耐心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;你需要在遇到</summary>
      
    
    
    
    <category term="网页制作" scheme="https://liano.top/categories/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
    
    <category term="自建博客" scheme="https://liano.top/tags/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://liano.top/tags/hexo/"/>
    
    <category term="github" scheme="https://liano.top/tags/github/"/>
    
    <category term="网页制作" scheme="https://liano.top/tags/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://liano.top/posts/4a17b156/"/>
    <id>https://liano.top/posts/4a17b156/</id>
    <published>2022-08-12T12:32:17.384Z</published>
    <updated>2022-08-20T10:18:34.547Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
