<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高精度进制转换与多项式求值</title>
      <link href="/posts/2c9ec966/"/>
      <url>/posts/2c9ec966/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了整整两天时间完成了数据结构的上机实验二，写了800多行代码，中间遇到了不少困难，但我竟然能不在大佬指导下独自完成，实在可喜可贺，非常有成就感🤣。在此记录一下过程与方法。</p><p>PS：在此感谢一位小伙伴在小数的进制转换部分给我提供的思路✌️，欢迎参观他的博客：<a href="https://semitia.top/">Semitia-Blog</a></p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="高精度数"><a href="#高精度数" class="headerlink" title="高精度数"></a>高精度数</h3><p>之前在梅森素数的验证里就写过高精度整数的处理方法，用数组存储每一位。现在学了数据结构，当然要升级一下了，定义结构体即可方便直观地存储一个高精度数。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> neg;           <span class="comment">//符号位，0为正，1位负</span></span><br><span class="line">    <span class="type">int</span> inte[Max + <span class="number">1</span>]; <span class="comment">//整数部分，第一位存实际长度</span></span><br><span class="line">    <span class="type">int</span> deci[n + <span class="number">1</span>];   <span class="comment">//小数部分，第一位存实际长度</span></span><br><span class="line">    <span class="type">int</span> base;          <span class="comment">//进制类型</span></span><br><span class="line">&#125; num;</span><br></pre></td></tr></table></figure>              </div>            </details><blockquote><p>其中Max和n是宏定义的最大位数，n同时也是设定精度</p></blockquote><p>当然一个成熟的数据结构要有自己独有的初始化和销毁函数，这里结构体内部中没有 malloc 空间，所以销毁函数直接用 free 即可，我们只写个初始化函数。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">num *<span class="title function_">InitNum</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分配空间</span></span><br><span class="line">    num *tmp = (num *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配空间失败！&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    tmp-&gt;base = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;neg = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(tmp-&gt;inte, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (Max + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(tmp-&gt;deci, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//返回结构体指针</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>当然，为了方便调试，还要有一个输出函数，用来输出结构体里存的数据。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintNum</span><span class="params">(num *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d进制：&quot;</span>, data-&gt;base);</span><br><span class="line">    <span class="comment">//特判0,输出0即可</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;inte[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; data-&gt;deci[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印负号</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;neg == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="comment">//纯小数</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;inte[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="comment">//打印整数部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= data-&gt;inte[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//超出9用小写字母表述</span></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;inte[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, data-&gt;inte[i] - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, data-&gt;inte[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印小数部分，同整数</span></span><br><span class="line">    <span class="comment">//去除尾部多余的0</span></span><br><span class="line">    <span class="type">int</span> temp = data-&gt;deci[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(data-&gt;deci[temp] == <span class="number">0</span> &amp;&amp; temp &gt; <span class="number">0</span>)</span><br><span class="line">        temp--;</span><br><span class="line">    data-&gt;deci[<span class="number">0</span>] = temp;</span><br><span class="line">    <span class="comment">//打印小数点</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;deci[<span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= data-&gt;deci[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;deci[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, data-&gt;deci[i] - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, data-&gt;deci[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="数据读入"><a href="#数据读入" class="headerlink" title="数据读入"></a>数据读入</h3><p>需要有一个函数，将输入的高精度字符串转为 num 类型的变量存储。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读入二进制或十进制数据，转为num类型存储</span></span><br><span class="line">num *<span class="title function_">ReadStr</span><span class="params">(<span class="type">int</span> N, <span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    num *ans = InitNum(); <span class="comment">//存放转换结果</span></span><br><span class="line">    <span class="type">int</span> pos;              <span class="comment">//指向data</span></span><br><span class="line">    <span class="type">int</span> i;                <span class="comment">//指向ans</span></span><br><span class="line">    <span class="keyword">if</span> (N != <span class="number">2</span> &amp;&amp; N != <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;只能读入二进制或十进制数哦！&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进制</span></span><br><span class="line">    ans-&gt;base = N;</span><br><span class="line">    <span class="comment">//判断负数</span></span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans-&gt;neg = <span class="number">1</span>;</span><br><span class="line">        pos = <span class="number">1</span>; <span class="comment">//指针后移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断正数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans-&gt;neg = <span class="number">0</span>;</span><br><span class="line">        pos = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//考虑正号的缺省和纯小数的整数部分的缺省</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((data[<span class="number">0</span>] &lt; N + <span class="string">&#x27;0&#x27;</span> &amp;&amp; data[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span>) || data[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans-&gt;neg = <span class="number">0</span>;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则为非法输入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入正确的数据！&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往后一个个读入</span></span><br><span class="line">    <span class="comment">//整数部分</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; <span class="built_in">strlen</span>(data) &amp;&amp; data[pos] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用于多项式解析，碰到x或+-号停止读入</span></span><br><span class="line">        <span class="keyword">if</span> (data[pos] == <span class="string">&#x27;x&#x27;</span> || data[pos] == <span class="string">&#x27;+&#x27;</span> || data[pos] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录长度</span></span><br><span class="line">            ans-&gt;inte[<span class="number">0</span>] = i;</span><br><span class="line">            ans-&gt;deci[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断输入合法性</span></span><br><span class="line">        <span class="keyword">if</span> (data[pos] &gt;= N + <span class="string">&#x27;0&#x27;</span> || data[pos] &lt; <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入正确的数据&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去除头部多余的0</span></span><br><span class="line">        <span class="keyword">if</span> (data[pos] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; flg == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flg = <span class="number">1</span>; <span class="comment">//用于判断0是否可去</span></span><br><span class="line">        ans-&gt;inte[++i] = data[pos++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录长度</span></span><br><span class="line">    ans-&gt;inte[<span class="number">0</span>] = i;</span><br><span class="line">    pos++; <span class="comment">//小数点占位，指针后移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//小数部分</span></span><br><span class="line">    i = <span class="number">0</span>; <span class="comment">// 回到起点，读入小数部分</span></span><br><span class="line">    <span class="keyword">while</span> (pos &lt; <span class="built_in">strlen</span>(data))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用于解析多项式</span></span><br><span class="line">        <span class="keyword">if</span> (data[pos] == <span class="string">&#x27;x&#x27;</span> || data[pos] == <span class="string">&#x27;+&#x27;</span> || data[pos] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//去除尾部多余的0</span></span><br><span class="line">            <span class="keyword">while</span> (ans-&gt;deci[i] == <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span>)</span><br><span class="line">                i--;</span><br><span class="line">            ans-&gt;deci[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断合法性</span></span><br><span class="line">        <span class="keyword">if</span> (data[pos] &gt;= N + <span class="string">&#x27;0&#x27;</span> || data[pos] &lt; <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入正确的数据！&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans-&gt;deci[++i] = data[pos++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除尾部多余的0</span></span><br><span class="line">    <span class="keyword">while</span> (ans-&gt;deci[i] == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">        i--;</span><br><span class="line">    ans-&gt;deci[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="comment">// PrintNum(ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="进制转换-1"><a href="#进制转换-1" class="headerlink" title="进制转换"></a>进制转换</h3><p>由于整数部分和小数部分的转换互不影响，且转换规则不同，所以我们将这两部分分开处理，各个击破。</p><h4 id="整数部分"><a href="#整数部分" class="headerlink" title="整数部分"></a>整数部分</h4><p>最高纲领就是待转换数一直除以目标进制类型，留下余数，商继续除，留下余数…….，直到商为 0，把所有余数逆序拼接起来就是转换后的数。</p><p>但是对于高精度数，不能直接用除法，这里用模拟手工算除法实现，一位一位地计算。</p><h4 id="小数部分"><a href="#小数部分" class="headerlink" title="小数部分"></a>小数部分</h4><p>最高纲领就是待转换数一直乘以目标进制类型，留下整数部分，小数部分继续乘，留下整数部分……，直到乘数为 0，把所有留下的整数部分正序拼接起来就是转换后的数。乘法同样用模拟手工计算实现。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>可能会有点乱，但既然能跑，就不想动了🤣</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进制转换函数，实现任意进制互转，将data转为N进制</span></span><br><span class="line">num *<span class="title function_">BaseConversion</span><span class="params">(num *data, <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// temp存储转化结果</span></span><br><span class="line">    num *temp = InitNum();</span><br><span class="line">    <span class="type">int</span> base = data-&gt;base;</span><br><span class="line">    temp-&gt;base = N;</span><br><span class="line">    temp-&gt;neg = data-&gt;neg; <span class="comment">//符号位不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//整数部分</span></span><br><span class="line">    <span class="comment">//模拟手工进制转化</span></span><br><span class="line">    <span class="comment">//大循环是inte[]/N，取余，商再/N，取余，直到商为0；</span></span><br><span class="line">    <span class="comment">//因为数字很大，不能直接除，所以一位一位的除，商拼接去首0就是上面的商，余数*data-&gt;base+下一位数作为下一个被除数，继续/N，取最后一次的余数为上面的余数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> div[data-&gt;inte[<span class="number">0</span>] + <span class="number">1</span>]; <span class="comment">//存储大循环中每一次的被除数</span></span><br><span class="line">    <span class="comment">//第一次的被除数就是inte[]本身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= data-&gt;inte[<span class="number">0</span>]; i++)</span><br><span class="line">        div[i] = data-&gt;inte[i];</span><br><span class="line">    <span class="comment">//存储大循环中的商</span></span><br><span class="line">    <span class="type">int</span> ans[data-&gt;inte[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="comment">//存储大循环中的余数</span></span><br><span class="line">    <span class="type">int</span> res[Max];</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res));</span><br><span class="line">    <span class="comment">//大循环</span></span><br><span class="line">    <span class="keyword">while</span> (div[<span class="number">0</span>] &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>; <span class="comment">//记录小循环中的余数，会不断更新</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//用来拼接小循环中每次的商</span></span><br><span class="line">        ans[<span class="number">0</span>] = div[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//小循环</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= div[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            y = y * base + div[i]; <span class="comment">//当前被除数</span></span><br><span class="line">            ans[i++] = y / N;      <span class="comment">//记录商</span></span><br><span class="line">            y %= N;                <span class="comment">//更新余数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//大循环中的一位余数就是当前最新的y</span></span><br><span class="line">        res[++res[<span class="number">0</span>]] = y;</span><br><span class="line">        i = <span class="number">1</span>; <span class="comment">//重复利用，去除下次被除数(即上次的商)的多余的0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= ans[<span class="number">0</span>] &amp;&amp; ans[i] == <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">//清空被除数，重新用上次的商赋值</span></span><br><span class="line">        <span class="built_in">memset</span>(div, <span class="number">0</span>, <span class="keyword">sizeof</span>(div));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= ans[<span class="number">0</span>]; j++)</span><br><span class="line">            div[++div[<span class="number">0</span>]] = ans[j];</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序取余数即可得到转化后的整数部分</span></span><br><span class="line">    temp-&gt;inte[<span class="number">0</span>] = res[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= temp-&gt;inte[<span class="number">0</span>]; i++)</span><br><span class="line">        temp-&gt;inte[i] = res[res[<span class="number">0</span>]--];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数部分</span></span><br><span class="line">    <span class="comment">//模拟手工进制转化，逻辑上和整数部分类似</span></span><br><span class="line">    <span class="comment">//大循环是*N取整，剩下的继续*N取整，直到0，把取出的整数正序排列即可得到转化结果</span></span><br><span class="line">    <span class="comment">//小循环是一位一位的*N，/data-&gt;base进位，%data-&gt;base留下，拼接起来进入大循环的计算</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> multy[data-&gt;deci[<span class="number">0</span>] + <span class="number">1</span>]; <span class="comment">//存储大循环中每一次的被乘数(暂且这样称呼)</span></span><br><span class="line">    <span class="comment">//第一次的被乘数就是deci[]本身，需要逆序存储</span></span><br><span class="line">    multy[<span class="number">0</span>] = data-&gt;deci[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = data-&gt;deci[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        multy[++pos] = data-&gt;deci[i];</span><br><span class="line">    <span class="comment">//存储大循环中的乘积结果</span></span><br><span class="line">    <span class="type">int</span> ans_[data-&gt;deci[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ans_, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans_));</span><br><span class="line">    <span class="comment">//存储大循环中的取整结果</span></span><br><span class="line">    <span class="type">int</span> res_[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(res_, <span class="number">0</span>, <span class="keyword">sizeof</span>(res_));</span><br><span class="line">    <span class="comment">//大循环</span></span><br><span class="line">    <span class="keyword">while</span> (multy[<span class="number">0</span>] &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>; <span class="comment">//记录小循环中的进位量，会不断更新</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//用来拼接小循环中每次的乘积结果</span></span><br><span class="line">        <span class="comment">//小循环</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= multy[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            y += (multy[i] * N);  <span class="comment">//当前乘积结果</span></span><br><span class="line">            ans_[i++] = y % base; <span class="comment">//记录当前保留的数</span></span><br><span class="line">            y /= base;            <span class="comment">//更新进位量</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans_[<span class="number">0</span>] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//取整，即取最后一次的进位量</span></span><br><span class="line">        res_[<span class="number">0</span>]++;</span><br><span class="line">        <span class="comment">//达到精度后退出大循环</span></span><br><span class="line">        <span class="keyword">if</span> (res_[<span class="number">0</span>] &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            res_[<span class="number">0</span>]--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res_[res_[<span class="number">0</span>]] = y;</span><br><span class="line">        <span class="comment">//清空被乘数，重新用上次的乘积结果赋值</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(multy, <span class="number">0</span>, <span class="keyword">sizeof</span>(multy));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ans_[<span class="number">0</span>]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检测被乘数是否为0</span></span><br><span class="line">            <span class="keyword">if</span> (ans_[j] == <span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">            multy[++multy[<span class="number">0</span>]] = ans_[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被乘数为 0，退出大循环</span></span><br><span class="line">        <span class="keyword">if</span> (count == ans_[<span class="number">0</span>])</span><br><span class="line">            multy[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans_, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正序取余数即可得到转化后的小数部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= res_[<span class="number">0</span>]; i++)</span><br><span class="line">        temp-&gt;deci[i] = res_[i];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上，上面分别就是高精除以低精，高精乘以低精的模板</p></blockquote>              </div>            </details><h2 id="高精度运算"><a href="#高精度运算" class="headerlink" title="高精度运算"></a>高精度运算</h2><p>首先搞定加减法，由于参与运算的两个数据正负不明，大小不定，所以不好直接操作，所以我们先实现一个简单的，限制条件严格的加减器，再根据情况调用它们就行。</p><p>加法器规定两个参数均为正数且第一个大于第二个，减法器规定两个参数均为正数且第一个大于第二个。这里又有了新的问题，高精度数如何比较大小，所以我们首先需要一个比较大小的函数。</p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>规定返回结果为绝对值大小，即不考虑正负号。先比较整数部分的位数，若位数相同，再一位一位地比较，直到出现不同或两数相等。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度比较器，返回|x|&gt;|Y|</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(num *x, num *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//位数不同直接比较</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;inte[<span class="number">0</span>] &gt; y-&gt;inte[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//位数相同向后比较</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;inte[<span class="number">0</span>] == y-&gt;inte[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//比较整数部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x-&gt;inte[<span class="number">0</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//出现不同就结束了</span></span><br><span class="line">            <span class="keyword">if</span> (x-&gt;inte[i] &gt; y-&gt;inte[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;inte[i] &lt; y-&gt;inte[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较小数部分</span></span><br><span class="line">        <span class="type">int</span> low = (x-&gt;deci[<span class="number">0</span>] &gt; y-&gt;deci[<span class="number">0</span>] ? x-&gt;deci[<span class="number">0</span>] : y-&gt;deci[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= low; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;deci[i] &gt; y-&gt;deci[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;deci[i] &lt; y-&gt;deci[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h3><p>先加小数部分，因为存储方式是正序存储，所以本身对应下标的数字就在对应位数，直接一位一位地加即可，保留模 10 余数，商进位到前一位数上，第一位的进位加到整数部分最后一位上；整数部分因为不同长度的数对应位数的下标不同，所以需要先对齐，长度之差就等于下标之差，然后同样按位加。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度加法器，严格规定x，y均为正数且x&gt;y</span></span><br><span class="line">num *<span class="title function_">adding_box</span><span class="params">(num *x, num *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存储结果</span></span><br><span class="line">    num *ans = InitNum();</span><br><span class="line">    <span class="type">int</span> base = x-&gt;base;</span><br><span class="line">    <span class="comment">//进制不变</span></span><br><span class="line">    ans-&gt;base = base;</span><br><span class="line">    <span class="comment">//符号为+</span></span><br><span class="line">    ans-&gt;neg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小数部分</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定最后一位小数</span></span><br><span class="line">    <span class="type">int</span> low = (x-&gt;deci[<span class="number">0</span>] &gt;= y-&gt;deci[<span class="number">0</span>] ? x-&gt;deci[<span class="number">0</span>] : y-&gt;deci[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> pos = low; <span class="comment">//指向当前操作位的指针</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;  <span class="comment">//暂存当前进位和运算结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//逐位相加，考虑进位</span></span><br><span class="line">        temp += (x-&gt;deci[i] + y-&gt;deci[i]);</span><br><span class="line">        ans-&gt;deci[pos--] = temp % base; <span class="comment">//当前位保留的数</span></span><br><span class="line">        temp /= base;                   <span class="comment">//进位值</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans-&gt;deci[<span class="number">0</span>] = low; <span class="comment">//和的小数部分长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//整数部分</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算整数部分长度之差，小数点对齐，逐位相加，和小数部分类似</span></span><br><span class="line">    <span class="type">int</span> dis = x-&gt;inte[<span class="number">0</span>] - y-&gt;inte[<span class="number">0</span>];</span><br><span class="line">    pos = x-&gt;inte[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x-&gt;inte[<span class="number">0</span>]; i - dis &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp += (x-&gt;inte[i] + y-&gt;inte[i - dis]);</span><br><span class="line">        ans-&gt;inte[pos--] = temp % base;</span><br><span class="line">        temp /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = dis; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp += x-&gt;inte[i];</span><br><span class="line">        ans-&gt;inte[pos--] = temp % base;</span><br><span class="line">        temp /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    ans-&gt;inte[<span class="number">0</span>] = x-&gt;inte[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//如果最后一位有进位，需要整数部分整体右移</span></span><br><span class="line">    <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ans-&gt;inte[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            ans-&gt;inte[i + <span class="number">1</span>] = ans-&gt;inte[i];</span><br><span class="line">        ans-&gt;inte[<span class="number">1</span>] = temp;           <span class="comment">//加上最后的进位</span></span><br><span class="line">        ans-&gt;inte[<span class="number">0</span>] = x-&gt;inte[<span class="number">0</span>] + <span class="number">1</span>; <span class="comment">//更新长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans-&gt;inte[<span class="number">0</span>] = x-&gt;inte[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="减法器"><a href="#减法器" class="headerlink" title="减法器"></a>减法器</h3><p>和加法器类似，进位变借位而已。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度减法器，严格规定x，y均为正数且x&gt;y</span></span><br><span class="line">num *<span class="title function_">sub_box</span><span class="params">(num *x, num *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//和加法器类似</span></span><br><span class="line">    num *ans = InitNum();</span><br><span class="line">    <span class="type">int</span> base = x-&gt;base;</span><br><span class="line">    ans-&gt;base = base;</span><br><span class="line">    ans-&gt;neg = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> low = (x-&gt;deci[<span class="number">0</span>] &gt; y-&gt;deci[<span class="number">0</span>] ? x-&gt;deci[<span class="number">0</span>] : y-&gt;deci[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> pos = low;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//存储当前借位值</span></span><br><span class="line">    <span class="type">int</span> a;        <span class="comment">//存储当前位数值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a = x-&gt;deci[i] - temp;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//借位</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; y-&gt;deci[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">            a += base;</span><br><span class="line">        &#125;</span><br><span class="line">        ans-&gt;deci[pos--] = a - y-&gt;deci[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除多余的0</span></span><br><span class="line">    <span class="keyword">while</span> (ans-&gt;deci[low] == <span class="number">0</span> &amp;&amp; low &gt; <span class="number">0</span>)</span><br><span class="line">        low--;</span><br><span class="line">    ans-&gt;deci[<span class="number">0</span>] = low;</span><br><span class="line">    <span class="type">int</span> dis = x-&gt;inte[<span class="number">0</span>] - y-&gt;inte[<span class="number">0</span>];</span><br><span class="line">    pos = x-&gt;inte[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x-&gt;inte[<span class="number">0</span>]; i - dis &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a = x-&gt;inte[i] - temp;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; y-&gt;inte[i - dis])</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">            a += base;</span><br><span class="line">        &#125;</span><br><span class="line">        ans-&gt;inte[pos--] = a - y-&gt;inte[i - dis];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = dis; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a = x-&gt;inte[i] - temp;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">            a += base;</span><br><span class="line">        &#125;</span><br><span class="line">        ans-&gt;inte[pos--] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除多余的0</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ans-&gt;inte[++pos] == <span class="number">0</span> &amp;&amp; pos &lt;= x-&gt;inte[<span class="number">0</span>])</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= x-&gt;inte[<span class="number">0</span>]; i++)</span><br><span class="line">        ans-&gt;inte[i - pos + <span class="number">1</span>] = ans-&gt;inte[i];</span><br><span class="line">    ans-&gt;inte[<span class="number">0</span>] = x-&gt;inte[<span class="number">0</span>] - count;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>有了上面三个基础函数，就可以根据参与运算的两个数的性质，选择调用方式。另外，减法函数可以直接调用加法函数实现，很容易写出实现加减法的函数如下：</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度加法函数，调用加法器和减法器，根据两个运算数的不同情况选择调用方式</span></span><br><span class="line">num *<span class="title function_">Add</span><span class="params">(num *x, num *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// x&gt;0,y&gt;0</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;neg == <span class="number">0</span> &amp;&amp; y-&gt;neg == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (compare(x, y))</span><br><span class="line">            <span class="keyword">return</span> adding_box(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> adding_box(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// x&lt;0,y&lt;0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;neg == <span class="number">1</span> &amp;&amp; y-&gt;neg == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num *ans;</span><br><span class="line">        <span class="keyword">if</span> (compare(x, y))</span><br><span class="line">            ans = adding_box(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = adding_box(y, x);</span><br><span class="line">        ans-&gt;neg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// x&gt;0,y&lt;0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;neg == <span class="number">0</span> &amp;&amp; y-&gt;neg == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (compare(x, y))</span><br><span class="line">            <span class="keyword">return</span> sub_box(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            num *ans = sub_box(y, x);</span><br><span class="line">            ans-&gt;neg = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// x&lt;0,y&gt;0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (compare(x, y))</span><br><span class="line">        &#123;</span><br><span class="line">            num *ans = sub_box(x, y);</span><br><span class="line">            ans-&gt;neg = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> sub_box(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度减法函数，调用加法函数即可</span></span><br><span class="line">num *<span class="title function_">Sub</span><span class="params">(num *x, num *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// x - y = x + (-y)</span></span><br><span class="line">    num *ans;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;neg == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;neg = <span class="number">1</span>;</span><br><span class="line">        ans = Add(x, y);</span><br><span class="line">        y-&gt;neg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;neg = <span class="number">0</span>;</span><br><span class="line">        ans = Add(x, y);</span><br><span class="line">        y-&gt;neg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h3><p>最后来搞定乘法，对于带有小数的高精度数乘法，我们完全可以把小数点放一边，先考虑两个大整数的乘法，最后把小数点放到正确位置即可，这也符合我们手算乘法的习惯。这里直接把之前写的大整数乘法函数搬过来。实现方式还就是那个一位一位乘。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大整数乘法器，模拟手算，通过z[]返回，返回有效位起点(0或1)，第一个有效位位存储长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">multy_box</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> x[], <span class="type">int</span> y[], <span class="type">int</span> z[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//按位计算即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = y[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = x[<span class="number">0</span>]; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            z[i + j] += x[j] * y[i];</span><br><span class="line">            z[i + j - <span class="number">1</span>] += z[i + j] / base;</span><br><span class="line">            z[i + j] %= base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回有效位置与有效长度</span></span><br><span class="line">    <span class="keyword">if</span> (z[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        z[<span class="number">1</span>] = x[<span class="number">0</span>] + y[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        z[<span class="number">0</span>] = x[<span class="number">0</span>] + y[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后把带小数点的高精度数转为大整数，进入乘法器，再加一个判断小数点位置，小数位数等于两个乘数的小数位数之和，就可以写出我们需要的乘法函数了，如下：</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度乘法函数，调用大整数乘法器，在合适位置点上小数点即可</span></span><br><span class="line">num *<span class="title function_">Mul</span><span class="params">(num *x, num *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将x转为大整数a</span></span><br><span class="line">    <span class="type">int</span> xlen = x-&gt;inte[<span class="number">0</span>] + x-&gt;deci[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> a[xlen + <span class="number">1</span>];</span><br><span class="line">    a[<span class="number">0</span>] = xlen;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x-&gt;inte[<span class="number">0</span>]; i++)</span><br><span class="line">        a[++pos] = x-&gt;inte[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x-&gt;deci[<span class="number">0</span>]; i++)</span><br><span class="line">        a[++pos] = x-&gt;deci[i];</span><br><span class="line">    <span class="comment">//将y转为大整数b</span></span><br><span class="line">    <span class="type">int</span> ylen = y-&gt;inte[<span class="number">0</span>] + y-&gt;deci[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> b[ylen + <span class="number">1</span>];</span><br><span class="line">    b[<span class="number">0</span>] = ylen;</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= y-&gt;inte[<span class="number">0</span>]; i++)</span><br><span class="line">        b[++pos] = y-&gt;inte[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= y-&gt;deci[<span class="number">0</span>]; i++)</span><br><span class="line">        b[++pos] = y-&gt;deci[i];</span><br><span class="line">    <span class="comment">//存储结果的z</span></span><br><span class="line">    <span class="type">int</span> z[xlen + ylen + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(z, <span class="number">0</span>, <span class="keyword">sizeof</span>(z));</span><br><span class="line">    <span class="comment">//进入大整数乘法器，获取z的有效区间</span></span><br><span class="line">    <span class="type">int</span> start = multy_box(x-&gt;base, a, b, z);</span><br><span class="line">    <span class="type">int</span> end = z[start] + start;</span><br><span class="line">    <span class="comment">//小数点位置</span></span><br><span class="line">    <span class="type">int</span> dot = x-&gt;deci[<span class="number">0</span>] + y-&gt;deci[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//把大整数z转为需要的结果ans</span></span><br><span class="line">    num *ans = InitNum(ans);</span><br><span class="line">    ans-&gt;base = x-&gt;base;</span><br><span class="line">    ans-&gt;neg = (x-&gt;neg + y-&gt;neg) % <span class="number">2</span>; <span class="comment">//判断符号</span></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, z[start]);</span></span><br><span class="line">    <span class="type">int</span> temp = start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (z[temp] == <span class="number">0</span>) <span class="comment">//去除高位0</span></span><br><span class="line">        temp++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = temp; i &lt;= end - dot; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d\n&quot;, i, z[i]);</span></span><br><span class="line">        ans-&gt;inte[++pos] = z[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans-&gt;inte[<span class="number">0</span>] = pos;</span><br><span class="line">    <span class="comment">//指针归零，读入小数部分</span></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//有效位数较少，需要补0</span></span><br><span class="line">    <span class="keyword">if</span> (end - start &lt; dot)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//z中有效位数和补的0加一起足够小数位数为止</span></span><br><span class="line">        <span class="keyword">while</span> (pos + end - start &lt; dot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ans-&gt;deci[++pos] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再读入z中的全部数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans-&gt;deci[++pos] = z[i];</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则直接读入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = end - dot + <span class="number">1</span>; i &lt;= end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans-&gt;deci[++pos] = z[i];</span><br><span class="line">            <span class="comment">// printf(&quot;%d &quot;, z[i]);</span></span><br><span class="line">            <span class="comment">//因为大整数乘法器得到的结果精度是两个乘数精度之和</span></span><br><span class="line">            <span class="comment">//为了防止把ans撑死，达到目标精度就可以退出了</span></span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans-&gt;deci[<span class="number">0</span>] = pos;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="多项式求值"><a href="#多项式求值" class="headerlink" title="多项式求值"></a>多项式求值</h2><h3 id="解析表达式"><a href="#解析表达式" class="headerlink" title="解析表达式"></a>解析表达式</h3><h4 id="表达式标准化"><a href="#表达式标准化" class="headerlink" title="表达式标准化"></a>表达式标准化</h4><p>对于输入的一个多项式字符串，例如：3/7x^3-1/3x^2+6x-4，要提取出各项的系数与指数非常麻烦，所以我们需要将它格式化，转化为容易识别和处理的形式，比如转换为：+3/7x^3-1/3x^2+6x^1-4x^0，这样就可以通过 x 和 +- 号的位置快速定位到系数和指数的位置。所以我们需要一个转换函数。</p><h4 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h4><p>转换为标准形式后，我们可以提取出各项的系数与指数，同样用结构体来存储这些数据，定义结构体如下：</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多项式的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    num *a[MX];    <span class="comment">//系数，按位存储</span></span><br><span class="line">    <span class="type">int</span> power[MX]; <span class="comment">//指数</span></span><br><span class="line">    <span class="type">int</span> sum;       <span class="comment">//项数</span></span><br><span class="line">&#125; var;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">var *<span class="title function_">InitVar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    var *tmp = (var *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(var));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;a[i] = <span class="literal">NULL</span>;</span><br><span class="line">        tmp-&gt;power[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">var *<span class="title function_">DestroyVar</span><span class="params">(var *tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;a[i] != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">free</span>(tmp-&gt;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：结构体中有 malloc 的时候不要忘记 free，比如这里的 num *a[]，里面有可能有指向堆内存的指针，需要在销毁函数里 free 掉。</p></blockquote>              </div>            </details><p>当然，为了方便调试，输出函数必不可少。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintVar</span><span class="params">(var *cal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cal-&gt;sum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNum(cal-&gt;a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cal-&gt;power[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>最最困难的一个问题来了，对于这样的形式：+3/7x^3-1/3x^2+6x^1-4x^0，系数里有分数，不但要识别出来，还要进行计算后才能作为系数！这里我们先写一个除法函数，低精除以低精，结果返回 num 类型高精度数。大体思路就是先用整型的除法把结果的整数部分搞出来，然后剩下的被除数不断乘 10 再除以除数，保留每次的商拼接起来就是结果的小数部分，实际也是模拟手算的方法。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//除法函数，低精除以低精，返回高精</span></span><br><span class="line">num *<span class="title function_">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    num *ans = InitNum();</span><br><span class="line">    ans-&gt;base = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//确定符号</span></span><br><span class="line">    ans-&gt;neg = (x * y &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//负数转为正数，方便运算</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        x = -x;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">        y = -y;</span><br><span class="line">    <span class="comment">// printf(&quot;x=%d y=%d\n&quot;, x, y);</span></span><br><span class="line">    <span class="comment">//先得到整数部分</span></span><br><span class="line">    <span class="type">int</span> z = x / y;</span><br><span class="line">    <span class="comment">//存储z的每一位数，放在整数部分里</span></span><br><span class="line">    <span class="type">int</span> temp[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (z)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[++i] = z % <span class="number">10</span>;</span><br><span class="line">        z /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[<span class="number">0</span>] = i;</span><br><span class="line">    ans-&gt;inte[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        ans-&gt;inte[j] = temp[temp[<span class="number">0</span>]--];</span><br><span class="line">    <span class="comment">//如果除尽了，没有小数部分</span></span><br><span class="line">    <span class="keyword">if</span> (x % y == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans-&gt;deci[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则余数*10继续除，直到除尽或者达到精度</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = x % y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= <span class="number">10</span>;</span><br><span class="line">            ans-&gt;deci[++pos] = res / y;</span><br><span class="line">            res %= y;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans-&gt;deci[<span class="number">0</span>] = pos;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>停止条件是除尽了或者是达到精度了，除尽的标志是余数是 0；因为每除一次小数点后就会多一位数，所以除了多少次就有多少精度，所以除n次即可结束。</p></blockquote>              </div>            </details><p>整个函数如下：（屎山代码，懒得优化了，也许还有bug，摆烂了🙌</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析表达式，首先标准化格式，然后提取系数与指数，将多项式信息以Var类型存储</span></span><br><span class="line">var *<span class="title function_">trans</span><span class="params">(<span class="type">char</span> expr[], <span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//首先把系数缺省的1和指数缺省的1和0补全，方便统一操作</span></span><br><span class="line">    <span class="type">char</span> line[MX * <span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(expr); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//系数为1的缺省</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; expr[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            line[pos++] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((expr[i] == <span class="string">&#x27;+&#x27;</span> || expr[i] == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; expr[i + <span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            line[pos++] = expr[i];</span><br><span class="line">            line[pos++] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指数为1的缺省</span></span><br><span class="line">        <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;x&#x27;</span> &amp;&amp; expr[i + <span class="number">1</span>] != <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            line[pos++] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            line[pos++] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">            line[pos++] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指数为0的缺省</span></span><br><span class="line">        <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;+&#x27;</span> || expr[i] == <span class="string">&#x27;-&#x27;</span> || (expr[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; expr[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; i == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> flg = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (expr[j] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; expr[j] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; j &lt; <span class="built_in">strlen</span>(expr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//检测是否缺省</span></span><br><span class="line">                <span class="keyword">if</span> (expr[j] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flg = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flg == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                line[pos++] = expr[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//缺省了，补齐</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j - <span class="number">1</span>; k++)</span><br><span class="line">                    line[pos++] = expr[k];</span><br><span class="line">                line[pos++] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">                line[pos++] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">                line[pos++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        line[pos++] = expr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    line[pos] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, expr);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, line);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分析出系数并以高精度形式存储，并提取指数</span></span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var *cal = InitVar();</span><br><span class="line">        <span class="type">int</span> ptr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(line);)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (ptr = <span class="number">0</span>; ptr &lt; MX; ptr++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="built_in">strlen</span>(line))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> part1 = atoi(line + i);</span><br><span class="line">                <span class="comment">// printf(&quot;part1=%d\n&quot;, part1);</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="type">int</span> skip = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (line[i] != <span class="string">&#x27;/&#x27;</span> &amp;&amp; i &lt; <span class="built_in">strlen</span>(line))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (line[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cal-&gt;a[ptr] = divide(part1, <span class="number">1</span>);</span><br><span class="line">                        cal-&gt;power[ptr] = atoi(line + i + <span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">while</span> (line[i] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; line[i] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; i &lt; <span class="built_in">strlen</span>(line))</span><br><span class="line">                            i++;</span><br><span class="line">                        skip = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (skip == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// printf(&quot;%c\n&quot;, line[i]);</span></span><br><span class="line">                <span class="type">int</span> part2 = atoi(line + i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// printf(&quot;part2=%d\n&quot;, part2);</span></span><br><span class="line">                cal-&gt;a[ptr] = divide(part1, part2);</span><br><span class="line">                <span class="keyword">while</span> (line[i] != <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">                    i++;</span><br><span class="line">                cal-&gt;power[ptr] = atoi(line + i + <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">while</span> (line[i] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; line[i] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; i &lt; <span class="built_in">strlen</span>(line))</span><br><span class="line">                    i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cal-&gt;sum = ptr;</span><br><span class="line">        <span class="comment">// PrintVar(cal);</span></span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var *cal = InitVar();</span><br><span class="line">        <span class="type">int</span> ptr;</span><br><span class="line">        <span class="type">int</span> x_pos[MX], s_pos[MX];</span><br><span class="line">        <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(x_pos, <span class="number">0</span>, <span class="keyword">sizeof</span>(x_pos));</span><br><span class="line">        <span class="built_in">memset</span>(s_pos, <span class="number">0</span>, <span class="keyword">sizeof</span>(s_pos));</span><br><span class="line">        s_pos[pos2++] = <span class="number">0</span>; <span class="comment">//第一个系数读取位置</span></span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;, line);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(line); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (line[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">                x_pos[pos1++] = i;</span><br><span class="line">            <span class="keyword">if</span> (line[i] == <span class="string">&#x27;+&#x27;</span> || line[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                s_pos[pos2++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ptr = <span class="number">0</span>; ptr &lt; MX; ptr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x_pos[ptr] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            cal-&gt;a[ptr] = ReadStr(<span class="number">10</span>, line + s_pos[ptr]);</span><br><span class="line">            cal-&gt;power[ptr] = atoi(line + x_pos[ptr] + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cal-&gt;sum = ptr;</span><br><span class="line">        <span class="comment">// PrintVar(cal);</span></span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为后面要求又变了，系数只有小数，没有分数，所以又加了个 type == 2 的情况，实际上系数是小数就简单多了。</p></blockquote>              </div>            </details><h3 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h3><p>为了方便计算 x^n，先写个乘方函数，底数为高精度，指数为低精度，调用乘法函数即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乘方函数，方便运算，调用乘法函数即可</span></span><br><span class="line">num *<span class="title function_">Pow</span><span class="params">(num *x, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    num *ans = InitNum();</span><br><span class="line">    <span class="comment">//特判指数为0</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans-&gt;inte[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ans-&gt;inte[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans-&gt;base = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    num temp = *x;</span><br><span class="line">    num *used;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//防止内存泄漏</span></span><br><span class="line">        used = Mul(&amp;temp, x);</span><br><span class="line">        temp = *used;</span><br><span class="line">        <span class="built_in">free</span>(used);</span><br><span class="line">    &#125;</span><br><span class="line">    *ans = temp;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意不要内存泄露了！这里 used 就是用来 free 的</p></blockquote>              </div>            </details><p>有了上面的铺垫，现在可以很容易地写出求值的函数啦。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算多项式的值，调用上面的函数即可</span></span><br><span class="line">num *<span class="title function_">Calcu</span><span class="params">(<span class="type">char</span> expr[], num *x, <span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先解析表达式</span></span><br><span class="line">    var *cal = trans(expr, type);</span><br><span class="line">    <span class="comment">//调用加法和乘法运算</span></span><br><span class="line">    <span class="comment">// PrintVar(cal);</span></span><br><span class="line">    num *ans = InitNum();</span><br><span class="line">    num *used;</span><br><span class="line">    num temp[cal-&gt;sum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cal-&gt;sum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num *tmp = Pow(x, cal-&gt;power[i]);</span><br><span class="line">        used = Mul(cal-&gt;a[i], tmp);</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        temp[i] = *used;</span><br><span class="line">        <span class="built_in">free</span>(used);</span><br><span class="line">    &#125;</span><br><span class="line">    num temp2;</span><br><span class="line">    temp2 = temp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cal-&gt;sum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        used = Add(&amp;temp2, &amp;temp[i]);</span><br><span class="line">        temp2 = *used;</span><br><span class="line">        <span class="built_in">free</span>(used);</span><br><span class="line">    &#125;</span><br><span class="line">    *ans = temp2;</span><br><span class="line">    DestroyVar(cal);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>到这里，所有的功能都实现了，浅写个可以交互的主函数吧：</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> choose;</span><br><span class="line">    <span class="type">char</span> str[Max + n + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> N = <span class="number">0</span>;</span><br><span class="line">    num *ans;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;功能选择：\n0.退出\n1.十进制转N进制\n2.二进制转N进制\n3.加减乘运算\n4.简单多项式求值\n\n&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">        <span class="keyword">if</span> (choose == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (choose == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;十进制数 &amp; N：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;N);</span><br><span class="line">            num *data = ReadStr(<span class="number">10</span>, str);</span><br><span class="line">            ans = BaseConversion(data, N);</span><br><span class="line">            PrintNum(ans);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">            <span class="built_in">free</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (choose == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;二进制数 &amp; N：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;N);</span><br><span class="line">            num *data = ReadStr(<span class="number">2</span>, str);</span><br><span class="line">            ans = BaseConversion(data, N);</span><br><span class="line">            PrintNum(ans);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">            <span class="built_in">free</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (choose == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;数据1 &amp; 数据2 &amp; 运算符号(+-*)：&quot;</span>);</span><br><span class="line">            <span class="type">char</span> str1[Max + n + <span class="number">1</span>], str2[Max + n + <span class="number">1</span>], sign;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %c&quot;</span>, str1, str2, &amp;sign);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;结果进制类型：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">            num *data1 = ReadStr(<span class="number">10</span>, str1);</span><br><span class="line">            num *data2 = ReadStr(<span class="number">10</span>, str2);</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                ans = Add(data1, data2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                ans = Sub(data1, data2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans = Mul(data1, data2);</span><br><span class="line">            num *ans_ = BaseConversion(ans, N);</span><br><span class="line">            PrintNum(ans);</span><br><span class="line">            PrintNum(ans_);</span><br><span class="line">            <span class="built_in">free</span>(data1);</span><br><span class="line">            <span class="built_in">free</span>(data2);</span><br><span class="line">            <span class="built_in">free</span>(ans);</span><br><span class="line">            <span class="built_in">free</span>(ans_);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (choose == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> expr[MX * <span class="number">10</span>], x[Max + n + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memset</span>(expr, <span class="number">0</span>, <span class="keyword">sizeof</span>(expr));</span><br><span class="line">            <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;选择输入格式：\n1.分数：形如3/7x^3-1/3x^2-6x+4\n2.小数：形如0.4286x^3-0.3333x^2-6x+4\n\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;格式：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;type);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;多项式 &amp; x：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, expr, x);</span><br><span class="line">            num *x_ = ReadStr(<span class="number">10</span>, x);</span><br><span class="line">            ans = Calcu(expr, x_, type);</span><br><span class="line">            PrintNum(ans);</span><br><span class="line">            <span class="built_in">free</span>(x_);</span><br><span class="line">            <span class="built_in">free</span>(ans);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>再来个成就感满满的图：</p><p><img src="https://s2.loli.net/2022/10/07/iYmz3DqFGd9EcM2.png" alt="image-20221007134119583.png"></p><p>最后附上项目地址：<a href="https://github.com/liano3/DataStrucLab2">Github仓库</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>上机检查完美完成！没有出任何bug！开心✌️</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 高精度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度计算 </tag>
            
            <tag> 进制转换 </tag>
            
            <tag> 多项式解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模式匹配KMP算法</title>
      <link href="/posts/b5cfc372/"/>
      <url>/posts/b5cfc372/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：文中均为伪代码。主要是展示算法思想和实现方式</p></blockquote><h2 id="算法要求"><a href="#算法要求" class="headerlink" title="算法要求"></a>算法要求</h2><p>给定主串 S 和子串 T，要求返回 T 在 S 中第一次出现的位置，若不存在，返回 -1；</p><h2 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h2><p>以 S 的第 1 个字符为起点，逐个与 T 中字符比较，若匹配失败，起点向前进一位，即第二次匹配从第 2 个字符开始。直至匹配成功或无法匹配。</p><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(String s, String t, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; s.length &amp;&amp; j &lt; t.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[k] == t[j]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k = k - j + <span class="number">1</span>;<span class="comment">//k-j为当前起点位置，+1为下次匹配起点</span></span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= t.length)</span><br><span class="line">        <span class="keyword">return</span> (k - t.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn)</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p>暴力匹配的缺点在于每次匹配失败主串和子串指针都要回到起点。KMP算法对此进行了优化，匹配失败后，主串指针不动，子串指针也不用回到起点，而是回溯到适当位置。</p><p><img src="https://s2.loli.net/2022/10/01/i9loNBXWkamvZH5.png" alt="模式匹配" style="zoom:67%;" /></p><p>如上图所示，假设现在在位置 x 处匹配失败了，如果子串 t 中在 x 前面存在与起点相同的一段字符串，分别记作 D 与 C ，又因为 AC，BD 已经匹配，所以这四个串完全相同，那么，就可以将子串向右滑动，即子串指针向前回溯一个到 C 的末尾，让 C 与 B 对齐，这样 BC 就匹配好了，所以主串指针不用回溯，继续向后比较即可。可以看出，如果存在这样的情况，则 C 的长度越长，匹配速度越快。所以在算法中，我们需要求出满足条件的最长的串 C。</p><p>看起来速度会提升不少，但是问题来了，它一步跳过那么多字符，有没有可能会漏掉中间可以成功匹配的情况呢？答案是不会。可以反证法，假如中间部分可以匹配成功，即 t 不用向右滑那么多就可以匹配成功，那么就存在更长的 C’（C向右加长）与 B’（B向左加长）相匹配，那么就有对应的 D’ （D向左加长）。这与 C 和 D 是 t 中符合条件的最长串相矛盾。</p><p>正确性没有问题了，如何实现呢？可以看出，子串 t 的回溯位置是由其本身的组成决定的，在不同位置匹配失败需要回溯的位置不同，在 t[j] 匹配失败需要回溯到的位置可以记为 next[j]。我们先不考虑 next 数组如何求，先写出算法框架。</p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Strlen 1024</span></span><br><span class="line"><span class="type">int</span> next[Max_Strlen];<span class="comment">//已经算好</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP_index</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; t.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == t[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= t.length)</span><br><span class="line">        <span class="keyword">return</span> (i - t.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第六行 j == -1 是因为记 next[0] = -1</p></blockquote><p>时间复杂度：O(m+n)</p><h3 id="计算next-j"><a href="#计算next-j" class="headerlink" title="计算next[j]"></a>计算next[j]</h3><h5 id="暴力穷举法"><a href="#暴力穷举法" class="headerlink" title="暴力穷举法"></a>暴力穷举法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">next1</span><span class="params">(String t, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    String str1, str2;</span><br><span class="line">    <span class="type">int</span> k = j;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        k--;</span><br><span class="line">        str1 = <span class="built_in">subString</span>(t, <span class="number">0</span>, k);<span class="comment">//对t，从t[0]开始，截取长度为 k 的串</span></span><br><span class="line">        str2 = <span class="built_in">subString</span>(t, j-k, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k &amp;&amp; <span class="built_in">strncmp</span>(str1, str2, k));</span><br><span class="line">    <span class="comment">//strncmp比较str1与str2前k个元素是否完全相同</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改进穷举法"><a href="#改进穷举法" class="headerlink" title="改进穷举法"></a>改进穷举法</h5><p>先判断尾元素是否相等，再比较串是否相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">next2</span><span class="params">(String t, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = j - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[k] == t[j<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(t, &amp;t[j-k<span class="number">-1</span>], k+<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h5><p><img src="https://s2.loli.net/2022/10/01/1jOmWwlkZJe6NQU.png" alt="递推求解next[j]" style="zoom:67%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(<span class="type">char</span> t[], <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k])</span><br><span class="line">            next[++j] = ++k;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，递推法的效率最高，但是，递推法还有可以优化的地方，比如模式串为<code>aaaab</code>，主串为<code>aaabaaaab</code>，则当第一次匹配失败时，i = 3，j = 3，根据next[j]的指示，下一次比较 j = 2，然后比较 j = 1, j = 0。但实际上，因为模式串前四个都是相同的，所以下次匹配一定失败。所以可以做如下优化：当 s[i] != s[j] 时，若 t[j] == t[next[j]]，则直接跳过一次匹配，匹配 t[j] 与 t[next[next[j]]]。</p><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">next_val</span><span class="params">(<span class="type">char</span> t[], <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">            ++j; ++k;</span><br><span class="line">            <span class="keyword">if</span> (t[j] != t[k])</span><br><span class="line">                next[j] = k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模式匹配 </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode配置plantuml环境</title>
      <link href="/posts/ef8bb752/"/>
      <url>/posts/ef8bb752/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习数据结构时，老师推荐了画流程图的工具plantuml，虽可以在线使用，但总是觉得不太方便，又想到万能的编辑器vscode或许可以与之结合，于是上网找教程配置，果然可以，现记录如下。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="配置Java"><a href="#配置Java" class="headerlink" title="配置Java"></a>配置Java</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://download.oracle.com/java/18/latest/jdk-18_windows-x64_bin.exe">戳这里直接下载</a>，双击下载的安装包进行安装</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>新建两个系统变量</p><div class="table-container"><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>JAVA_HOME</td><td>E:\java\jdk-18.0.2.1(改为自己的安装目录)</td></tr><tr><td>CLASSPATH</td><td>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</td></tr></tbody></table></div><p>找到系统变量PATH，添加一条<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</code></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在cmd中分别输入<code>java</code>，<code>java -version</code>，<code>javac</code>，无报错即可。</p><h3 id="配置GraphViz"><a href="#配置GraphViz" class="headerlink" title="配置GraphViz"></a>配置GraphViz</h3><h4 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h4><p><a href="https://gitlab.com/api/v4/projects/4207231/packages/generic/graphviz-releases/6.0.1/windows_10_cmake_Release_graphviz-install-6.0.1-win64.exe">戳这里直接下载</a></p><p>下载后会有警告，把下载好的文件后缀改为.exe，双击，选择第二个自动添加系统变量的选项，然后安装（虽然不知道为什么，但这样可行</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>cmd运行<code>dot -version</code>命令，正常运行即可</p><h3 id="配置vscode"><a href="#配置vscode" class="headerlink" title="配置vscode"></a>配置vscode</h3><p>没用过vscode的请自己找教程安装，那么万能的编辑器不用一下吗😉</p><h4 id="安装plantuml插件"><a href="#安装plantuml插件" class="headerlink" title="安装plantuml插件"></a>安装plantuml插件</h4><p>安装两个插件，<code>Graphviz Preview</code>，<code>PlantUML</code></p><p>然后就可以优雅地画图啦！</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li>新建文档，没有后缀名，写脚本，语法见<a href="https://plantuml.com/zh/">官方文档</a></li><li>Alt+D预览</li><li>Ctrl+S保存</li><li>导出图。打开Command palette，开启方式有两种：其一快捷键Ctrl + Shift+ P；其二对着脚本编辑框点击右键选择command palette，输入plantuml，选择导出图片选项。导出位置应该在根目录新建文件夹out里。</li></ul><p><strong>例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@startuml</span></span><br><span class="line">start</span><br><span class="line">scale <span class="number">2</span><span class="comment">//解决导出png不清晰的问题</span></span><br><span class="line">:输入List *p, ElemType value;</span><br><span class="line">-&gt;将p指向第一个节点;</span><br><span class="line">:p = p-&gt;next;</span><br><span class="line">-&gt;判断p是否为空;</span><br><span class="line"><span class="keyword">while</span> (p == NULL ?) is (N)</span><br><span class="line">    -&gt;判断p是否为目标元素;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data == value ?) then (Y)</span><br><span class="line">        :输出p;</span><br><span class="line">        stop</span><br><span class="line">    <span class="title function_">else</span> <span class="params">(N)</span></span><br><span class="line">        -&gt;p指向下一个节点;</span><br><span class="line">        :p = p-&gt;next;</span><br><span class="line">    endif</span><br><span class="line"><span class="title function_">endwhile</span> <span class="params">(Y)</span></span><br><span class="line">:输出NULL;</span><br><span class="line">end</span><br><span class="line"><span class="meta">@enduml</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://s2.loli.net/2022/09/13/MZ4tOXTmp6W915G.png" alt="LocateElem.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> plantuml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> plantuml </tag>
            
            <tag> 流程图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/posts/c4fedc02/"/>
      <url>/posts/c4fedc02/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象定义"><a href="#抽象定义" class="headerlink" title="抽象定义"></a>抽象定义</h2><p>输入：加权图 $G=(V(G),E(G)),\ w:E(G)\rightarrow \mathbf{R}^+$，顶点 $u_0\in V(G)$</p><p>输出：$u_0$ 到其余所有顶点的最短路径和对应距离</p><p>集合S用来存储已经找到的最短路径，l记录路径终点的前导节点</p><ol><li>任给 $u,v\in V(G)$，若 $u,v\notin E(G)$，令 $w(uv)=\infty$</li><li>令 $d(u_0)=0,\ l(u_0)=u_0$; 任给 $u \in V(G),\ u \neq u_0,\ d(u)=\infty,\quad l(u)=*$; $S_0=\left\{u_0\right\};\ i=0$</li><li>对任给 $u\in V(G)-S_i$，若 $d(u_i)+w(u_iu)&lt;d(u)$，则令 $d(u)=d(u_i)+w(u_iu),\ l(u)=u_i$</li><li>选出 $u_{i+1}\in V(G)-S_i$，使得 $d(u_{i+1})=min_{u\in V(G)-S_i}d(u)$，令 $S_{i+1}=S_i\cup{u_{i+1}}$</li><li>若 $i=v(G)-1$，算法停止；否则，i++，转(3)</li></ol><h2 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h2><p>其实是类似贪心加广搜加动归，大致思路是这样的：</p><p>先把内层的，最靠近起点的最短路径确定好，然后通过已知的最短路径做中继点，更新其外层节点的现有最短路径，这里的内外层其实是根据离起点的距离分的。就是说要到1000m外的一个地方，中间很多休息区，我要贪心地走每一步，即保证我一定是通过最短路径走到前导节点。到目标点的路径长度随着前导节点的变化不断变短，直至最短。</p><h2 id="例题详解"><a href="#例题详解" class="headerlink" title="例题详解"></a>例题详解</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p><strong>第一层：从v1出发，计算v1到其它节点的距离（无法连接则用“无穷”符号）</strong></p><p>全表找最小值，发现v1到v6最短为3</p><ul><li>S中添加一条最短路径：v1——v6</li><li>v6列标红不再考虑</li></ul><p><img src="https://s2.loli.net/2022/09/05/q9YjiC3WNxzSodm.png" alt="第一层" style="zoom:67%;" /></p><p><strong>第二层：从v1——v6出发，计算v1通过v6到其它节点的距离</strong></p><p>在全表中找最小值（v6列已经删除)，此时4为最小值，对应路径v1——v6——v5</p><ul><li>添加最短路径v1——v6——v5</li><li>v5列不再考虑</li></ul><p><img src="https://s2.loli.net/2022/09/05/4bwz6pvhnaFAeK9.jpg" alt="第二层" style="zoom:67%;" /></p><p><strong>第三层：从v1——v6——v5出发，计算v1通过v6及v5到其它节点的距离</strong></p><ul><li>已知v1——v6——v5长度为4；</li><li><p>发现，v5不能到现存的其它任何一个节点，因此距离全部为“无穷”</p></li><li><p>看全表（v5和v6已经删除）找最小值，5是最小值，对应的路径是v1——v6——v2</p></li><li>添加最短路径v1——v6——v2</li><li>v2列不再考虑</li></ul><p><img src="https://s2.loli.net/2022/09/05/lLebp7AdxZ3suzi.jpg" alt="第三层" style="zoom:67%;" /></p><p>新最短路径：v1——v6——v2</p><p><strong>第四轮：从v1——v6——v2出发，计算v1通过v6及v2到其它节点的距离</strong></p><p>v1——v6——v2到其它现存节点的距离（v2，v5，v6已删除)</p><ul><li>遍历全表（v2，v5和v6已经删除）发现，9最小，对应的路径为v1——v6——v4</li><li>添加最短路径v1——v6——v4</li><li>v4列不再考虑</li></ul><p><img src="https://s2.loli.net/2022/09/05/d8WpBj2ATSgOus9.jpg" alt="第四层" style="zoom:67%;" /></p><p>新最短路径：v1——v6——v4</p><p><strong>第五轮：从v1——v6——v4出发，计算v1通过v6及v4到其它节点的距离</strong></p><p>计算v1——v6——v4到其它节点的距离（只剩v3列)</p><ul><li>遍历全表发现，12是现存的最小值，对应v1——v6——v2——v3路径最短</li><li>添加最短路径v1——v6——v2——v3</li><li>v3列不再考虑</li></ul><p><img src="https://s2.loli.net/2022/09/05/Ickhsvm1NDlKFSY.jpg" alt="第五层" style="zoom:67%;" /></p><p>添加最后一条最短路径：v1——v6——v2——v3</p><ul><li>由于全部列已经删除，因此结束遍历</li></ul><p><strong>最终的表格</strong></p><p><img src="https://s2.loli.net/2022/09/05/gbsDwiWuhVYxKfI.jpg" alt="最终表格" style="zoom:67%;" /></p><blockquote><p>每列的<strong>标红值</strong>，则为<strong>v1到该节点的最短距离</strong>；从<strong>S列中找结尾为该列的路径。</strong></p></blockquote><p><strong>结果汇总</strong></p><p>v1到各节点的路径及其最短距离</p><ul><li><p><strong>v2</strong>：<strong>v1——v6——v2</strong> = 5</p></li><li><p><strong>v3</strong>：<strong>v1——v6——v2——v3</strong> = 12</p></li><li><strong>v4</strong>：<strong>v1——v6——v4</strong> = 9</li><li><strong>v5</strong>：<strong>v1——v6——v5</strong> = 4</li><li><strong>v6</strong>：<strong>v1——v6</strong> = 3</li></ul><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p><img src="https://s2.loli.net/2022/09/05/D6wuS4y3QVhziBN.jpg" alt="图解算法"  /></p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/454373256">【看完必懂】Dijkstra算法（附案例详解）- 知乎(zhihu.com)</a>         </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra算法 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly主题标签外挂</title>
      <link href="/posts/61d8cc98/"/>
      <url>/posts/61d8cc98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文地址：<a href="https://akilar.top/posts/615e2dec/">https://akilar.top/posts/615e2dec/</a></p><p>本文只做搬运，简要记录。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>根目录<code>git bash</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-tag-plugins-plus --save</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p><code>_config.yml</code> or <code>_config.butterfly.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag-plugins-plus</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/615e2dec/</span></span><br><span class="line"><span class="attr">tag_plugins:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">issues:</span> <span class="literal">false</span> <span class="comment">#issues标签依赖注入开关</span></span><br><span class="line">  <span class="attr">link:</span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">/img/link.png</span> <span class="comment">#link_card标签默认的图标图片</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br><span class="line">    <span class="attr">anima:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css</span> <span class="comment">#动画标签anima的依赖</span></span><br><span class="line">    <span class="attr">jquery:</span> <span class="string">https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">issues:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">iconfont:</span> <span class="string">//at.alicdn.com/t/font_2032782_8d5kxvn09md.js</span> <span class="comment">#参看https://akilar.top/posts/d2ebecef/</span></span><br><span class="line">    <span class="attr">carousel:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js</span></span><br><span class="line">    <span class="attr">tag_plugins_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="行内文本样式text"><a href="#行内文本样式text" class="headerlink" title="行内文本样式text"></a>行内文本样式text</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line">带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line">带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line">带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line">键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line">密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><h3 id="行内文本span"><a href="#行内文本span" class="headerlink" title="行内文本span"></a>行内文本span</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ol><li>字体: logo, code</li><li>颜色: red,yellow,green,cyan,blue,gray</li><li>大小: small, h4, h3, h2, h1, large, huge, ultra</li><li>对齐方向: left, center, right</li></ol><p><strong>示例</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<span class='p center logo large'>Volantis</span><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><h3 id="段落文本p"><a href="#段落文本p" class="headerlink" title="段落文本p"></a>段落文本p</h3><p><strong>语法</strong></p><p>同上</p><p><strong>示例</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><h3 id="引用note"><a href="#引用note" class="headerlink" title="引用note"></a>引用note</h3><p><strong>配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p><code>flat</code>样式</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>flat样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><h3 id="复选列表checkbox"><a href="#复选列表checkbox" class="headerlink" title="复选列表checkbox"></a>复选列表checkbox</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><h3 id="时间轴timeline"><a href="#时间轴timeline" class="headerlink" title="时间轴timeline"></a>时间轴timeline</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><h3 id="链接卡片link"><a href="#链接卡片link" class="headerlink" title="链接卡片link"></a>链接卡片link</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link Liano-Blog, https://liano.top, https://liano.top/img/avatar.png %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="tag link"><a class="link-card" title="Liano-Blog" href="https://liano.top"><div class="left"><img src="https://liano.top/img/avatar.png"/></div><div class="right"><p class="text">Liano-Blog</p><p class="url">https://liano.top</p></div></a></div><h3 id="按钮btns"><a href="#按钮btns" class="headerlink" title="按钮btns"></a>按钮btns</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;标题&lt;/b&gt;</code>和<code>&lt;p&gt;描述文字&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">wide</td><td style="text-align:left">宽一点的按钮</td></tr><tr><td style="text-align:left">fill</td><td style="text-align:left">填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td style="text-align:left">center</td><td style="text-align:left">居中，按钮之间是固定间距</td></tr><tr><td style="text-align:left">around</td><td style="text-align:left">居中分散</td></tr><tr><td style="text-align:left">grid2</td><td style="text-align:left">等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td style="text-align:left">grid3</td><td style="text-align:left">等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td style="text-align:left">grid4</td><td style="text-align:left">等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td style="text-align:left">grid5</td><td style="text-align:left">等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table></div><ol><li><p>如果需要显示类似「团队成员」之类的一组含有头像的链接：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell Liano, https://liano.top, https://liano.top/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell Liano, https://liano.top, https://liano.top/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell Liano, https://liano.top, https://liano.top/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell Liano, https://liano.top, https://liano.top/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell Liano, https://liano.top, https://liano.top/img/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure></li><li><p>或者含有图标的按钮：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>效果</strong></p><ol><li><p>如果需要显示类似「团队成员」之类的一组含有头像的链接：</p><div class="btns circle grid5">            <a class="button" href='https://liano.top' title='Liano'><img src='https://liano.top/img/avatar.png'>Liano</a><a class="button" href='https://liano.top' title='Liano'><img src='https://liano.top/img/avatar.png'>Liano</a><a class="button" href='https://liano.top' title='Liano'><img src='https://liano.top/img/avatar.png'>Liano</a><a class="button" href='https://liano.top' title='Liano'><img src='https://liano.top/img/avatar.png'>Liano</a><a class="button" href='https://liano.top' title='Liano'><img src='https://liano.top/img/avatar.png'>Liano</a>          </div></li><li><p>或者含有图标的按钮：</p><div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div></li></ol><h3 id="单张图片image"><a href="#单张图片image" class="headerlink" title="单张图片image"></a>单张图片image</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://liano.top/img/404.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://liano.top/img/404.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div><h3 id="音频audio"><a href="#音频audio" class="headerlink" title="音频audio"></a>音频audio</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><h3 id="视频video"><a href="#视频video" class="headerlink" title="视频video"></a>视频video</h3><p><strong>参数</strong></p><ol><li>对其方向：left, center, right</li><li>列数：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><p><strong>示例</strong></p><ol><li><p>100%宽度</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>50%宽度</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure></li><li><p>25%宽度</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>效果</strong></p><div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><h3 id="折叠框folding"><a href="#折叠框folding" class="headerlink" title="折叠框folding"></a>折叠框folding</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ol><li>颜色：blue, cyan, green, yellow, red</li><li>状态：状态填写 open 代表默认打开。</li></ol><p><strong>示例</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/滑稽.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><h3 id="分栏tab"><a href="#分栏tab" class="headerlink" title="分栏tab"></a>分栏tab</h3><p><strong>语法</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子/页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><p><strong>示例</strong></p><p>Demo 1 - 预设选择第一个【默认】</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>Demo 2 - 预设选择tabs</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>Demo 3 - 没有预设值</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly主题 </tag>
            
            <tag> 写博客 </tag>
            
            <tag> 标签外挂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神奇的位运算</title>
      <link href="/posts/11eece28/"/>
      <url>/posts/11eece28/</url>
      
        <content type="html"><![CDATA[<h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><p>位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧”按位异或（取不同）、“&amp;”按位与（取交）、“|”按位或（取并）、“~”取反、“&lt;&lt;” 算术左移和“&gt;&gt;”算术右移。</p><p>除此之外，<code>n &amp; (n - 1)</code> 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100 ，减去 1 得到 11110011，这两个数按位与得到 11110000。<code>n &amp; (-n)</code> 可以得到 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。</p><h2 id="位运算基础问题"><a href="#位运算基础问题" class="headerlink" title="位运算基础问题"></a>位运算基础问题</h2><h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><a href="https://leetcode.cn/problems/hamming-distance/">汉明距离</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p><p>示例 1：</p><blockquote><p>输入：x = 1, y = 4<br>输出：2<br>解释：<br>1   (0 0 0 1)<br>4   (0 1 0 0)</p></blockquote><p>示例 2：</p><blockquote><p>输入：x = 3, y = 1<br>输出：1</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>按位异或，统计 1 的个数即可</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> diff = x ^ y, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (diff) &#123;</span><br><span class="line">        ans += diff &amp; <span class="number">1</span>;</span><br><span class="line">        diff &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="颠倒二进制位"><a href="#颠倒二进制位" class="headerlink" title="颠倒二进制位"></a><a href="https://leetcode.cn/problems/reverse-bits/">颠倒二进制位</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>颠倒给定的 32 位无符号整数的二进制位。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>使用算术左移和右移，可以很轻易地实现二进制的翻转。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        ans += n &amp; <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>需要用到异或运算的性质：</p><ul><li>a \^ a = 0</li><li>a \^ 0 = a</li><li>a \^ b \^ a = b \^ (a \^ a) = b（交换律和结合律）</li></ul><p>所以只要全部异或最后结果就是答案</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num: nums)</span><br><span class="line">        ans ^= num;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="二进制特性"><a href="#二进制特性" class="headerlink" title="二进制特性"></a>二进制特性</h2><p>利用二进制的一些特性，我们可以把位运算使用到更多问题上。例如，我们可以利用二进制和位运算输出一个数组的所有子集。假设我们有一个长度为 n 的数组，我们可以生成长度为 n 的所有二进制，1 表示选取该数字，0 表示不选取。这样我们就获得了 $2^n$ 个子集。</p><h3 id="4的幂"><a href="#4的幂" class="headerlink" title="4的幂"></a><a href="https://leetcode.cn/problems/power-of-four/">4的幂</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code>；否则，返回 <code>false</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>首先我们考虑一个数字是不是 2 的（整数）次方：如果一个数字 n 是 2 的整数次方，那么它 的二进制一定是0…010…0 这样的形式；考虑到 n − 1 的二进制是 0…001…1，这两个数求按位与 的结果一定是 0。因此如果 n &amp; (n - 1) 为 0，那么这个数是 2 的次方。如果这个数也是 4 的次方，那二进制表示中 1 的位置必须为奇数位。我们可以把 n 和二进制的 10101…101（即十进制下的 1431655765）做按位与，如果结果不为 0，那么说明这个数是 4 的 次方。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n &amp; (n - <span class="number">1</span>)) &amp;&amp; (n &amp; <span class="number">1431655765</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="最大单词长度乘积"><a href="#最大单词长度乘积" class="headerlink" title="最大单词长度乘积"></a><a href="https://leetcode.cn/problems/maximum-product-of-word-lengths/">最大单词长度乘积</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个字符串数组 words，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>怎样快速判断两个字母串是否含有重复数字呢？可以为每个字母串建立一个长度为 26 的二进制数字，每个位置表示是否存在该字母。如果两个字母串含有重复数字，那它们的二进制表示的按位与不为 0。同时，我们可以建立一个哈希表来存储字母串（在数组的位置）到二进制数字的映射关系，方便查找调用。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string &amp; word : words) &#123;</span><br><span class="line">        <span class="type">int</span> mask = <span class="number">0</span>, size = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; c : word)</span><br><span class="line">            mask |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        hash[mask] = <span class="built_in">max</span>(hash[mask], size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [h_mask, h_len]: hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(mask &amp; h_mask))</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, size * h_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><a href="https://leetcode.cn/problems/counting-bits/">比特位计数</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>本题可以利用动态规划和位运算进行快速的求解。定义一个数组 dp，其中 dp[i] 表示数字 i 的二进制含有 1 的个数。对于第 i 个数字，如果它二进制的最后一位为 1，那么它含有 1 的个数 则为 dp[i-1] + 1；如果它二进制的最后一位为 0，那么它含有 1 的个数和其算术右移结果相同，即 dp[i&gt;&gt;1]。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        dp[i] = i &amp; <span class="number">1</span>? dp[i<span class="number">-1</span>] + <span class="number">1</span>: dp[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 等价于dp[i] = dp[i&amp;(i-1)] + 1;</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="丢失的数字"><a href="#丢失的数字" class="headerlink" title="丢失的数字"></a><a href="https://leetcode.cn/problems/missing-number/">丢失的数字</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p><p>示例 1：</p><blockquote><p>输入：nums = [3,0,1]<br>输出：2<br>解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [0,1]<br>输出：2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>实际是上面例题的变种，只需在后面加上 0-n 的数字，即可转为只出现一次的数字那一题</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        res ^= i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这种巧妙优雅的写法，看似没加，实际等于加了</p>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="交替位二进制数"><a href="#交替位二进制数" class="headerlink" title="交替位二进制数"></a><a href="https://leetcode.cn/problems/binary-number-with-alternating-bits/">交替位二进制数</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>对输入 n 的二进制表示右移一位后，得到的数字再与 n 按位异或得到 a。当且仅当输入 n 为交替位二进制数时，a 的二进制表示全为 1（不包括前导 0）。这里进行简单证明：当 a 的每一位为 1 时，当且仅当 n 的所有相邻位相异，即 n 为交替位二进制数。</p><p>将 a 与 a + 1 按位与，当且仅当 a 的二进制表示全为 1 时，结果为 0。这里进行简单证明：当且仅当 a 的二进制表示全为 1 时，a + 1 可以进位，并将原最高位置为 0，按位与的结果为 0。否则，不会产生进位，两个最高位都为 1，相与结果不为 0。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> a = n ^ (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (a &amp; (a + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的两条性质，但不容易想到</p>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="数字的补数"><a href="#数字的补数" class="headerlink" title="数字的补数"></a><a href="https://leetcode.cn/problems/number-complement/">数字的补数</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>与同位数的最大的取异或</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findComplement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> tmp = num, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">        c &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num ^ (c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="只出现一次的数字III"><a href="#只出现一次的数字III" class="headerlink" title="只出现一次的数字III"></a>只出现一次的数字III</h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按任意顺序返回答案。</p><p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>例题的进阶版，全部异或后剩下 $x_1$ 和 $x_2$ 的异或结果，x 显然不会等于 0，因为如果 x=0，那么说明 $x_1 = x_2$，这样就不是只出现一次的数字了。因此，我们可以使用位运算 x \&amp; -x 取出 x 的二进制表示中最低位那个 1，设其为第 l 位，那么 $x_1$ 和 $x_2$ 中的某一个数的二进制表示的第 l 位为 0，另一个数的二进制表示的第 l 位为 1。</p><p>这样一来，我们就可以把 nums 中的所有元素分成两类，其中一类包含所有二进制表示的第 l 位为 0 的数，另一类包含所有二进制表示的第 l 位为 1 的数。可以发现：</p><ul><li>对于任意一个在数组 nums 中出现两次的元素，该元素的两次出现会被包含在同一类中；</li><li>对于任意一个在数组 nums 中只出现了一次的元素，即 $x_1$ 和 $x_2$ 它们会被包含在不同类中。</li></ul><p>因此，如果我们将每一类的元素全部异或起来，那么其中一类会得到 $x_1$，另一类会得到 $x_2$。这样我们就找出了这两个只出现一次的元素。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> xorsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num: nums)</span><br><span class="line">        xorsum ^= num;</span><br><span class="line">    <span class="comment">// 防止溢出</span></span><br><span class="line">    <span class="type">int</span> lsb = (xorsum == INT_MIN ? xorsum : xorsum &amp; (-xorsum));</span><br><span class="line">    <span class="type">int</span> type1 = <span class="number">0</span>, type2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &amp; lsb)</span><br><span class="line">            type1 ^= num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            type2 ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;type1, type2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧解数学问题</title>
      <link href="/posts/4621e56e/"/>
      <url>/posts/4621e56e/</url>
      
        <content type="html"><![CDATA[<h2 id="公倍数与公因数"><a href="#公倍数与公因数" class="headerlink" title="公倍数与公因数"></a>公倍数与公因数</h2><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>利用辗转相除法，我们可以很方便地求得两个数的最大公因数（greatest common divisor，gcd）；将两个数相乘再除以最大公因数即可得到最小公倍数（least common multiple, lcm）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a% b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>进一步地，我们也可以通过扩展欧几里得算法（extended gcd）在求得 a 和 b 最大公因数的同时，也得到它们的系数 x 和 y，从而使 ax + by = gcd(a, b)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">xGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1, gcd = <span class="built_in">xGCD</span>(b, a % b, x1, y1);</span><br><span class="line">    x = y1;</span><br><span class="line">    y = x1 - (a / b) * y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p>质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，由质因子分解定理，每一个数都可以分解成质数的乘积，且分解后形式唯一。</p><h3 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a><a href="https://leetcode.cn/problems/count-primes/">计数质数</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定整数 n，返回所有小于非负整数 n 的质数的数量。（n &gt;= 0）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法）是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数 n 时，同时判断所有小于 n 的整数，因此非常适合这道题。其原理也十分易懂：从 1 到 n 遍历，假设当前遍历到 m，则把所有小于 n 的、且是 m 的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = n - <span class="number">2</span>; <span class="comment">// 去掉不是质数的1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i]) &#123;<span class="comment">//若一个数已经标记过，则他的倍数肯定也被标记过了，可以跳过</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prime[j]) &#123;</span><br><span class="line">                    prime[j] = <span class="literal">false</span>;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用质数的一些性质，我们可以进一步优化该算法。对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。另外，偶数倍的 x 一定被 2 标记过了，所以 j 增量为 2*i；另外，若一个数有偶数因子，则这个数一定已经被 2 标记过了，所以 i 增量为 2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>, sqrtn = <span class="built_in">sqrt</span>(n), count = n / <span class="number">2</span>; <span class="comment">// 偶数一定不是质数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= sqrtn) &#123; <span class="comment">// 最小质因子一定小于等于开方数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += <span class="number">2</span> * i) &#123; <span class="comment">// 避免偶数和重复遍历</span></span><br><span class="line">            <span class="keyword">if</span> (prime[j]) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt;= sqrtn &amp;&amp; !prime[i]); <span class="comment">// 避免偶数和重复遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="数字处理"><a href="#数字处理" class="headerlink" title="数字处理"></a>数字处理</h2><h3 id="七进制数"><a href="#七进制数" class="headerlink" title="七进制数"></a><a href="https://leetcode.cn/problems/base-7/">七进制数</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>进制转换类型的题，通常是利用除法和取模（mod）来进行计算，同时也要注意一些细节，如负数和零。如果输出是数字类型而非字符串，则也需要考虑是否会超出整数上下界。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToBase7</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> is_negative = (num &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (is_negative) </span><br><span class="line">        num = -num;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        <span class="type">int</span> a = num / <span class="number">7</span>, b = num % <span class="number">7</span>;</span><br><span class="line">        ans = <span class="built_in">to_string</span>(b) + ans;</span><br><span class="line">        num = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_negative ? <span class="string">&quot;-&quot;</span> + ans: ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">阶乘后的零</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。（n &gt;= 0)</p><p>示例 1：</p><blockquote><p>输入：n = 3<br>输出：0</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 5<br>输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：n = 0<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>每个尾部的 0 由 2 × 5 = 10 而来，因此我们可以把阶乘的每一个元素拆成质数相乘，统计有多少个 2 和 5，取最小值即可，明显的，质因子 2 的数量远多于质因子 5 的数量，因此我们可以只统计阶乘结果里有多少个质因子 5，即 1~n 的质因子中 5 的个数和</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= n; i += <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = i;</span><br><span class="line">        <span class="keyword">while</span>(temp % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            temp /= <span class="number">5</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用数学方法再优化，换个角度考虑 1~n 的质因子 p 的个数，首先 p 的倍数的个数为$n_1=[\frac{n}{p}]$，贡献了 $n_1$ 个 p，然后 $p^2$ 的倍数个数为 $n_2=[\frac{n}{p^2}]$，因为在 $n_1$ 中已经算过了一半，所以只多贡献了 $n_2$ 个 p，以此类推，</p><script type="math/tex; mode=display">ans=\sum_{k=1}[\frac{n}{p^k}]=\sum_{k=1}[\frac{\frac{n}{p^{k-1}}}{p}]</script><p>因此我们可以通过不断将 n 除以 5，并累加每次除后的 n，来得到答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n / <span class="number">5</span> + <span class="built_in">trailingZeroes</span>(n / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多么简洁，优雅，美妙！数学真伟大！</p>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">字符串相加</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定两个字符串形式的非负整数 num1 和 num2，num1 和num2 都不包含任何前导零，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger），也不能直接将输入的字符串转换为整数形式。num1 和num2 都不包含任何前导零</p><p>示例 1：</p><blockquote><p>输入：num1 = “11”, num2 = “123”<br>输出：”134”</p></blockquote><p>示例 2：</p><blockquote><p>输入：num1 = “456”, num2 = “77”<br>输出：”533”</p></blockquote><p>示例 3：</p><blockquote><p>输入：num1 = “0”, num2 = “0”<br>输出：”0”</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>因为相加运算是从后往前进行的，所以可以先翻转字符串，再逐位计算。模拟人工手算法即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">output</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">reverse</span>(num1.<span class="built_in">begin</span>(), num1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(num2.<span class="built_in">begin</span>(), num2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> onelen = num1.<span class="built_in">length</span>(), twolen = num2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (onelen &lt;= twolen)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(num1, num2);</span><br><span class="line">        <span class="built_in">swap</span>(onelen, twolen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> addbit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; twolen; i++)&#123;</span><br><span class="line">        <span class="type">int</span> cur_sum = (num1[i]-<span class="string">&#x27;0&#x27;</span>) + (num2[i]-<span class="string">&#x27;0&#x27;</span>) + addbit;</span><br><span class="line">        output += <span class="built_in">to_string</span>((cur_sum) % <span class="number">10</span>);</span><br><span class="line">        addbit = cur_sum &lt; <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = twolen; i &lt; onelen; i++)&#123;</span><br><span class="line">        <span class="type">int</span> cur_sum = (num1[i]-<span class="string">&#x27;0&#x27;</span>) + addbit;</span><br><span class="line">        output += <span class="built_in">to_string</span>((cur_sum) % <span class="number">10</span>);</span><br><span class="line">        addbit = cur_sum &lt; <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addbit)</span><br><span class="line">        output += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(output.<span class="built_in">begin</span>(), output.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="‘3’的幂次方"><a href="#‘3’的幂次方" class="headerlink" title="‘3’的幂次方"></a><a href="https://leetcode.cn/problems/power-of-three/">‘3’的幂次方</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true；否则，返回 false。(n为int类型)</p><p>示例 1：</p><blockquote><p>输入：n = 27<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 0<br>输出：false</p></blockquote><p>示例 3：</p><blockquote><p>输入：n = 45<br>输出：false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>有两种方法，一种是利用对数。设 $log_3(n) = m$，如果 n 是 3 的整数次方，那么 m 一定是整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fmod</span>(<span class="built_in">log10</span>(n) / <span class="built_in">log10</span>(<span class="number">3</span>), <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是，因为在 int 范围内 3 的最大次方是 $3^{19} = 1162261467$，如果 n 是 3 的整数次方，那么 1162261467 除以 n 的余数一定是零；反之亦然。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool isPowerOfThree(int n) &#123;</span><br><span class="line">return n &gt; 0 &amp;&amp; 1162261467 % n == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="随机与取样"><a href="#随机与取样" class="headerlink" title="随机与取样"></a>随机与取样</h2><h3 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a><a href="https://leetcode.cn/problems/shuffle-an-array/">打乱数组</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个数组，要求在类中实现两个指令函数。第一个函数“shuffle”可以随机打乱这个数组，第二个函数“reset”可以恢复原来的顺序。</p><p>输入是一个存有整数数字的数组，和一个包含指令函数名称的数组。输出是一个二维数组，表示每个指令生成的数组。</p><blockquote><p>Input: nums = [1,2,3], actions: [“shuffle”,”shuffle”,”reset”]<br>Output: [[2,1,3],[3,2,1],[1,2,3]]<br>在这个样例中，前两次打乱的结果只要是随机生成即可。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>我们采用经典的 Fisher-Yates 洗牌算法，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法，且实现非常方便。注意这里“reset”函数以及类的构造函数的实现细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; origin;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums): <span class="built_in">origin</span>(nums) &#123;&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffled</span><span class="params">(origin)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = origin.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 反向洗牌：（正向效果相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">swap</span>(shuffled[i], shuffled[<span class="built_in">rand</span>() % (i + <span class="number">1</span>)]);</span><br><span class="line">        <span class="keyword">return</span> shuffled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者直接使用random_shuffle()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; shuffled = origin;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(shuffled.<span class="built_in">begin</span>(), shuffled.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> shuffled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="按权重随机选择"><a href="#按权重随机选择" class="headerlink" title="按权重随机选择"></a><a href="https://leetcode.cn/problems/random-pick-with-weight/">按权重随机选择</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。</p><blockquote><p>Input: weights = [1,3], actions: [“pickIndex”,”pickIndex”,”pickIndex”]<br>Output: [0,1,1]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>设数组 w 的权重之和为 total。根据题目的要求，我们可以看成将 [1,total] 范围内的所有整数分成 n 个部分（其中 n 是数组 w 的长度），第 i 个部分恰好包含 w[i] 个整数，并且这 n 个部分两两的交集为空。随后我们在 [1,total] 范围内随机选择一个整数 x，如果整数 x 被包含在第 i 个部分内，我们就返回 i。</p><p>一种较为简单的划分方法是按照从小到大的顺序依次划分每个部分。例如 w=[3,1,2,4] 时，权重之和 total=10，那么我们按照 [1,3],[4,4],[5,6],[7,10] 对 [1,10] 进行划分，使得它们的长度恰好依次为 3,1,2,4。可以发现，每个区间的左边界是在它之前出现的所有元素的和加上 1，右边界是到它为止的所有元素的和。因此，如果我们用 pre[i] 表示数组 w 的前缀和：</p><script type="math/tex; mode=display">pre[i]=\sum_{k=0}^{i}w[k]\\第 i 个区间的左边界就是 pre[i]−w[i]+1，右边界为 pre[i]。</script><p>当划分完成后，假设我们随机到了整数 x，我们希望找到满足：$pre[i]−w[i]+1≤x≤pre[i]$ 的 i 并将其作为答案返回。由于 pre[i] 是单调递增的，因此我们可以使用二分查找快速找到 i，即找出最小的满足 x≤pre[i] 的下标 i。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt; weights): <span class="built_in">sums</span>(std::<span class="built_in">move</span>(weights)) &#123;</span><br><span class="line">        <span class="built_in">partial_sum</span>(sums.<span class="built_in">begin</span>(), sums.<span class="built_in">end</span>(), sums.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = (<span class="built_in">rand</span>() % sums.<span class="built_in">back</span>()) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(sums.<span class="built_in">begin</span>(), sums.<span class="built_in">end</span>(), pos) - sums.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>partial_sum用于计算局部和（start, end, storage)</p><p>lower_bound用于找出范围内不小于num的第一个元素（start, end, storage)</p></blockquote>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="链表随机节点"><a href="#链表随机节点" class="headerlink" title="链表随机节点"></a><a href="https://leetcode.cn/problems/linked-list-random-node/">链表随机节点</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。</p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5<br>Output: 3</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>不同于数组，在未遍历完链表前，我们无法知道链表的总长度。这里我们就可以使用水库采样：遍历一次链表，在遍历到第 m 个节点时，有 1/m 的概率选择这个节点覆盖掉之前的节点选择。</p><p>我们提供一个简单的，对于水库算法随机性的证明。对于长度为 n 的链表的第 m 个节点，最后被采样的充要条件是它被选择，且之后的节点都没有被选择。这种情况发生的概率为 $\frac{1}{m}\times\frac{m}{m+1}\times\frac{m+1}{m+2}…=\frac{1}{n}$ 因此每个点都有均等的概率被选择。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode* head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* n): <span class="built_in">head</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = head-&gt;val;</span><br><span class="line">        ListNode* node = head-&gt;next;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">rand</span>() % i) == <span class="number">0</span>)</span><br><span class="line">                ans = node-&gt;val;</span><br><span class="line">            i++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="Excel表列名称"><a href="#Excel表列名称" class="headerlink" title="Excel表列名称"></a><a href="https://leetcode.cn/problems/excel-sheet-column-title/">Excel表列名称</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个整数 columnNumber，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><blockquote><p>A -&gt; 1<br>B -&gt; 2<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…</p></blockquote><p>示例 1：</p><blockquote><p>输入：columnNumber = 1<br>输出：”A”</p></blockquote><p>示例 2：</p><blockquote><p>输入：columnNumber = 28<br>输出：”AB”</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>和正常 0~25 的 26 进制相比，本质上就是每一位多加了 1。假设 A = 0，B = 1，那么 AB = 26 * 0 + 1 * 1，而现在 AB = 26 * (0 + 1) + 1 * (1 + 1)，所以只要在处理每一位的时候减 1，就可以按照正常的 26 进制来处理</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span>(columnNumber) &#123;</span><br><span class="line">        columnNumber--;</span><br><span class="line">        <span class="type">int</span> re = columnNumber % <span class="number">26</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="string">&#x27;A&#x27;</span> + re);</span><br><span class="line">        columnNumber /= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a><a href="https://leetcode.cn/problems/add-binary/">二进制求和</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你两个二进制字符串，返回它们的和（用二进制表示）。输入为非空字符串且只包含数字 1 和 0。</p><p>示例 1:</p><blockquote><p>输入: a = “11”, b = “1”<br>输出: “100”</p></blockquote><p>示例 2:</p><blockquote><p>输入: a = “1010”, b = “1011”<br>输出: “10101”</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>翻转，进位计算</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        carry += i &lt; a.<span class="built_in">size</span>() ? (a.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">        carry += i &lt; b.<span class="built_in">size</span>() ? (b.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(carry % <span class="number">2</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry)</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个整数数组 nums，返回数组 answer，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><p>题目数据保证数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p>示例 1:</p><blockquote><p>输入: nums = [1,2,3,4]<br>输出: [24,12,8,6]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [-1,1,0,-3,3]<br>输出: [0,0,9,0,0]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>L[i] 表示 nums[i] 左侧所有数字的乘积，R[i] 表示右侧，初始化后遍历数组即可</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(length, <span class="number">0</span>)</span>, <span class="title">R</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answer</span><span class="params">(length)</span></span>;</span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">    R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        answer[i] = L[i] * R[i];</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="最少移动次数使数组相等II"><a href="#最少移动次数使数组相等II" class="headerlink" title="最少移动次数使数组相等II"></a><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">最少移动次数使数组相等II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个长度为 n 的整数数组 nums，返回使所有数组元素相等需要的最少移动数。在一步操作中，你可以使数组中的一个元素加 1 或者减 1。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,10,2,9]<br>输出：16</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>很容易想到，都变成中位数所需移动次数较少，证明为什么用中位数，其实很简单，如果target往两侧偏移，如果一侧数字少一侧数字多，往多的一侧移动必然使得结果减少。直到target两侧的数字数量完全相等时，取得最小值。这里使用快速选择找到 target</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minMoves2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">nth_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + nums.<span class="built_in">size</span>() / <span class="number">2</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> target = nums[nums.<span class="built_in">size</span>()/<span class="number">2</span>], ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; x: nums) </span><br><span class="line">        ans += <span class="built_in">abs</span>(x - target);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">多数元素</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个大小为 n 的数组 nums，返回其中的多数元素。多数元素是指在数组中出现次数大于 n/2 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1：</p><blockquote><p>输入：nums = [3,2,3]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,2,1,1,1,2,2]<br>输出：2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><h4 id="Boyer-Moore-投票算法："><a href="#Boyer-Moore-投票算法：" class="headerlink" title="Boyer-Moore 投票算法："></a>Boyer-Moore 投票算法：</h4><ol><li>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</li><li>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：<ul><li>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</li><li>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</li></ul></li><li>在遍历完成后，candidate 即为整个数组的众数（这里众数指个数 &gt; n/2)。</li></ol><p>这里提供一个比较好理解的证明：</p><p>首先遍历数组时，遍历到的人将有一次投票权，相同的数字代表同一个人，在投票中，所有人都是利己的，即只会给自己投支持票，给不是自己的候选人投反对票。对于第一个候选人来说，如果他不是 maj，count迟早会变为 0，因为他自己最多给自己投的票数不超过一半，而其他人都会投反对票；即使反对票全部是 maj 投的（这里是极端情况），那么以 count=0 为分界，前面一段数组中 maj 也只占了一半，所以后面一段数组中众数还是 maj。如果第一个候选人是 maj，若 count 到最后都没有变为 0，当然选出来的就是 maj，若 count 在中间变为 0 了，那么前面一段数组中 maj 没占到一半票数，所以后面一段众数还是 maj。把前面一段丢掉不考虑，继续在后面一段中投票，可以看出是重复上述过程，所以最终候选人一定是是 maj</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == candidate)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="用rand7-实现rand10"><a href="#用rand7-实现rand10" class="headerlink" title="用rand7()实现rand10()"></a><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/">用rand7()实现rand10()</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。</p><p>每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。</p><blockquote><p>输入: 3<br>输出: [3,8,10]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>两个rand7()相乘，选择概率相等的一些数，映射到 [1,10] 即可；</p><p><img src="https://s2.loli.net/2022/08/23/zdyiqb6BoaK5wVL.jpg" alt="映射结果" style="zoom: 50%;" /></p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row, col, idx;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        row = <span class="built_in">rand7</span>();</span><br><span class="line">        col = <span class="built_in">rand7</span>();</span><br><span class="line">        idx = col + (row - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (idx &gt; <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (idx - <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">快乐数</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><blockquote><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环但始终变不到 1。<br>如果这个过程结果为 1，那么这个数就是快乐数。</p></blockquote><p>如果 n 是快乐数就返回 true；不是，则返回 false。</p><p>示例 1：</p><blockquote><p>输入：n = 19<br>输出：true<br>解释：<br>1^1^ + 9^2^ = 82<br>8^2^ + 2^2^ = 68<br>6^2^ + 8^2^ = 100<br>1^2^ + 0^2^ + 0^2^ = 1</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>对于 3 位数的数字，它不可能大于 $243(3×9^2)$。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以只有两种情况，一是进入循环，二是得到 1。把每个中间数字作为一个节点，可以使用前面章节讲过的快慢指针进行环路检测。如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitSquareSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> bit = n % <span class="number">10</span>;</span><br><span class="line">        sum += bit * bit;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slow = n, fast = n;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = <span class="built_in">bitSquareSum</span>(slow);</span><br><span class="line">        fast = <span class="built_in">bitSquareSum</span>(fast);</span><br><span class="line">        fast = <span class="built_in">bitSquareSum</span>(fast);</span><br><span class="line">    &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">    <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="/posts/7f3bcd7f/"/>
      <url>/posts/7f3bcd7f/</url>
      
        <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>顾名思义，分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。我们在排序章节展示的归并排序就是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终我们会得到多个长度为 1 的子数组;“治”即为把已经排好序的两个小数组合成为一个排好序的大数组，从长度为 1 的子数组开始，最终合成一个大数组。</p><p>另外，自上而下的分治可以和 memoization 结合，避免重复遍历相同的子问题。如果方便推导，也可以换用自下而上的动态规划方法求解。</p><h2 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题"></a>表达式问题</h2><h3 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">为运算表达式设计优先级</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个由数字和运算符（只包含+，-，*）组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以按任意顺序返回答案。</p><p>生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104。</p><p>示例 1：</p><blockquote><p>输入：expression = “2-1-1”<br>输出：[0,2]</p></blockquote><p>示例 2：</p><blockquote><p>输入：expression = “2*3-4*5”<br>输出：[-34,-14,-10,-10,10]<br>解释：<br>(2*(3-(4*5))) = -34<br>((2*3)-(4*5)) = -14<br>((2*(3-4))*5) = -10<br>(2*((3-4)*5)) = -10<br>(((2*3)-4)*5) = 10</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>利用分治思想，我们可以把加括号转化为，对于每个运算符号，先执行处理两侧的数学表达式，再处理此运算符号。注意特殊情况，即字符串内无运算符号，只有数字。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ways;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> c = input[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//分</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(<span class="number">0</span>, i));</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(i + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//治</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; l: left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; r: right) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: ways.<span class="built_in">push_back</span>(l + r); <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: ways.<span class="built_in">push_back</span>(l - r); <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: ways.<span class="built_in">push_back</span>(l * r); <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ways.<span class="built_in">empty</span>()) </span><br><span class="line">        ways.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input));<span class="comment">//stoi()函数将string类型转为int</span></span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，某些被 divide 的子字符串可能重复出现多次，因此我们可以用 memoization 来去重。或者与其我们从上到下用分治处理 + memoization，不如直接从下到上用动态规划处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; ops;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> op = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="comment">// 将 input 划分成数据（data）和运算符（ops），后面加一个 &quot;+&quot; 方便处理</span></span><br><span class="line">    <span class="function">istringstream <span class="title">ss</span><span class="params">(input + <span class="string">&quot;+&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(num);</span><br><span class="line">        ops.<span class="built_in">push_back</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 三维 vector 数组</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dp[i][j] 是一个一维 vector 数组，里面存储着：从第 i+1 个数字到第 j+1 个数字组成的算式的所有可能的运算结果，</span></span><br><span class="line"><span class="comment">    所以最后要输出的就是 dp[0][n-1]。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 如果 i == j，显然只有一种可能</span></span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                dp[j][i].<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* k 在 i 和 j 之间形成了一个 divide</span></span><br><span class="line"><span class="comment">                 举一个例子，有算式：1-2+3*4</span></span><br><span class="line"><span class="comment">                 当 i = 0, j = 3, k = 1 时，实际上就相当于计算这样一个算式的值：(1-2)+(3*4)，然后 push_back 到 dp[0][3] 里面</span></span><br><span class="line"><span class="comment">                 这样计数可以保证不重不漏</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; i; k += <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> left : dp[j][k]) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span> right : dp[k+<span class="number">1</span>][i]) &#123;</span><br><span class="line">                            <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">switch</span> (ops[k]) &#123;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: val = left + right; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: val = left - right; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: val = left * right; <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            dp[j][i].<span class="built_in">push_back</span>(val);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="漂亮数组"><a href="#漂亮数组" class="headerlink" title="漂亮数组"></a><a href="https://leetcode.cn/problems/beautiful-array/">漂亮数组</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>对于某些固定的 N，如果数组 A 是整数 1, 2, …, N 组成的排列，使得：对于每个 i &lt; j，都不存在 k 满足 i &lt; k &lt; j 使得 A[k] * 2 = A[i] + A[j]。那么数组 A 是漂亮数组。</p><p>给定 N，返回任意漂亮数组 A（保证存在一个）。</p><p>示例 1：</p><blockquote><p>输入：4<br>输出：[2,1,4,3]</p></blockquote><p>示例 2：</p><blockquote><p>输入：5<br>输出：[3,1,2,5,4]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>观察表达式，发现左边恒为偶数，则要不满足，只需右边一奇一偶即可，所以可以把数组一分为二，奇数放左边，偶数放右边，现在只要左右两边分别是漂亮数组即可，则 1~N 的奇数或偶数分别可以双射到 1~(N+1)/2 和 1~N/2 的整数，容易证明，映射不影响漂亮数组的性质，所以问题被分解为两个更小规模的子问题，递归处理即可</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <p>带 memoization 的分治法，自上而下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; memo;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memo.<span class="built_in">count</span>(n))</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)  </span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x : <span class="built_in">beautifulArray</span>((n + <span class="number">1</span>) / <span class="number">2</span>))</span><br><span class="line">            res[t++] = <span class="number">2</span> * x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x : <span class="built_in">beautifulArray</span>(n / <span class="number">2</span>))</span><br><span class="line">            res[t++] = <span class="number">2</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以动态规划，自下而上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    dp[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    dp[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i + <span class="number">1</span>) / <span class="number">2</span>; j++)</span><br><span class="line">            dp[i].<span class="built_in">push_back</span>(dp[(i+<span class="number">1</span>)/<span class="number">2</span>][j] * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i / <span class="number">2</span>; j++)</span><br><span class="line">            dp[i].<span class="built_in">push_back</span>(dp[i/<span class="number">2</span>][j] * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode.cn/problems/burst-balloons/">戳气球</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] <em> nums[i] </em> nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例 1：</p><blockquote><p>输入：nums = [3,1,5,8]<br>输出：167</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,5]<br>输出：10</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>为方便处理，把数组两端加上 nums[-1] 和 nums[n]，都等于 1，并保存在 rec 中，即 rec[i] = nums[i-1]，戳气球会导致原本不相邻的气球变成相邻的，所以我们反向考虑，添加气球，定义 solve(i, j) 表示在区间 (i, j) 内可获得的最大硬币数，则可以取一个中间的点 mid（这个mid必须放在最后戳破，因为只有这样可以消除两个子问题的相关性）分别求 solve(i, mid) 和 solve(mid, j)，然后相加即可，于是把原问题分解为了一个个子问题。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp; <span class="comment">//记忆化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rec; <span class="comment">//记录气球值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    rec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        rec.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    rec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    dp.<span class="built_in">resize</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">0</span>, n + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (dp[l][r] != <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mid = l + <span class="number">1</span>; mid &lt; r; mid++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = rec[mid] * rec[l] * rec[r];</span><br><span class="line">        sum += <span class="built_in">solve</span>(l, mid) + <span class="built_in">solve</span>(mid, r);</span><br><span class="line">        dp[l][r] = <span class="built_in">max</span>(sum, dp[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l][r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以使用自下而上的动态规划（dp[i][j] 表示 (i, j) 范围内最大硬币数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="type">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                sum += dp[i][k] + dp[k][j];</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分治法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/posts/a80d0031/"/>
      <url>/posts/a80d0031/</url>
      
        <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>动态规划（Dynamic Programming, DP）在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间</p><p>通俗一点来讲，动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规划问题的关键是找到状态转移方程，这样我们可以通过计算和储存子问题的解来求解最终问题。同时，我们也可以对动态规划进行空间压缩，起到节省空间消耗的效果。这一技巧笔者将在之后的题目中介绍。</p><p>在一些情况下，动态规划可以看成是带有状态记录（memoization）的优先搜索。状态记录的意思为，如果一个子问题在优先搜索时已经计算过一次，我们可以把它的结果储存下来，之后遍历到该子问题的时候可以直接返回储存的结果。动态规划是自下而上的，即先解决子问题，再解决父问题；而用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索到同一个子问题则进行状态记录，防止重复计算。如果题目需求的是最终状态，那么使用动态规划比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。</p><h2 id="一维dp"><a href="#一维dp" class="headerlink" title="一维dp"></a>一维dp</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><blockquote><p>输入：n = 2<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 3<br>输出：3</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>问题可以分解为两大类，第一类，最后一步爬了两个台阶，第二类，最后一步爬了一个台阶。设 $f(k)$ 为上到 k 阶台阶的总方案数，则状态转移方程为 $f(k)=f(k-1)+f(k-2)$</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，就是斐波那契数列问题，可以进行空间压缩，重复利用存储空间，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur = pre1 + pre2;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><blockquote><p>输入：[1,2,3,1]<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：[2,7,9,3,1]<br>输出：12</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>设共有 k 个房间，有两种获得最高总金额的可能。</p><p>一是偷了第 k 个房间，总金额为前 k-2 个房间的最高总金额加上第 k 个房间的金额；二是没偷第 k 个房间，总金额为前 k-1 个房间的最高总金额，取两者中的较大者。设最高总金额为 $f(k)$，则状态转移方程为 $f(k)=max(f(k-2)+value[k],\quad f(k-1))$.</p><p>边界条件为 $f(1)=value[1] ,\quad f(2)=max(value[1],\quad value[2]).$</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; size; i++)</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以进行空间压缩，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur = <span class="built_in">max</span>(pre2 + nums[i], pre1);</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="等差数列划分"><a href="#等差数列划分" class="headerlink" title="等差数列划分"></a><a href="https://leetcode.cn/problems/arithmetic-slices/">等差数列划分</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。给你一个整数数组 nums，返回数组 nums 中所有为等差数组的子数组个数。</p><p>子数组是数组中的一个连续序列。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,2,3,4]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1]<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i]-num[i-1] = num[i-1]-num[i-2]。定义以数字 nums[i] 结尾的等差子数组个数为 dp[i]，最后对 dp 数组求和即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">3</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] - nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>] - nums[i<span class="number">-2</span>])</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h2><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个包含非负整数的 m x n 网格 grid，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><blockquote><p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7</p></blockquote><p>示例 2：</p><blockquote><p>输入：grid = [[1,2,3],[4,5,6]]<br>输出：12</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>二维dp就建立二维数组，dp[i][j] 表示从左上角到位置 [i,j] 的最小路径和，</p><p>状态转移方程为 $dp[i][j]=min(dp[i-1][j],\quad dp[i][j-1])+grid[i][j]$，注意边界。</p><p>边界条件为 $dp[0][0]=grid[0][0]$.</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = grid[i][j]; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j]; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以进行空间压缩至一维，因为 dp 矩阵的每一个值只和左边和上面的值相关，当我们遍历到第 i 行第 j 列时，第 j-1 列已经更新过了，现在的 dp[j-1] 代表 dp[i][j-1] 的值；d[j] 待更新，现在的 dp[j] 代表 dp[i-1][j] 的值。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[j] = grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[j] = dp[j] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="“01”矩阵"><a href="#“01”矩阵" class="headerlink" title="“01”矩阵"></a><a href="https://leetcode.cn/problems/01-matrix/">“01”矩阵</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个由 0 和 1 组成的矩阵 mat，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。两个相邻元素间的距离为 1。</p><p>示例 1：</p><blockquote><p>输入：mat = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：[[0,0,0],[0,1,0],[0,0,0]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：mat = [[0,0,0],[0,1,0],[1,1,1]]<br>输出：[[0,0,0],[0,1,0],[1,2,1]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>dp[i][j] 表示位置 [i,j] 的元素到最近的 0 的距离，如果限制只能向右下搜索，则状态转移方程为：</p><script type="math/tex; mode=display">dp[i][j]=\begin{cases} 1+min(dp[i-1][j], \quad dp[i][j-1]),  & mat[i][j]=1 \\0, & mat[i][j]=0\end{cases}</script><p>左上同理，取最小值即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, INT_MAX - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//这样写就不用单独写特例了</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i<span class="number">-1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; m - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i+<span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">最大正方形</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p>示例 1：</p><blockquote><p>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：matrix = [[“0”,”1”],[“1”,”0”]]<br>输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：matrix = [[“0”]]<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>dp[i][j] 为以 [i,j] 为右下角的正方形的最大边长，若 matrix[i][j] = 0，则 dp[i][j] = 0；否则我们假设 dp[i][j] = k，其充分条件为 dp[i-1][j-1]、dp[i][j-1] 和 dp[i-1][j] 的值必须都不小于 k−1，否则 [i,j] 位置不可以构成一个面积为 $k^2$ 的正方形。同理，如果这三个值中的最小值为 k−1，则 [i,j] 位置一定且最大可以构成一个面积为 $k^2$ 的正方形。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), max_side = <span class="number">0</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">max_side = <span class="built_in">max</span>(max_side, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_side * max_side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="分割类型题"><a href="#分割类型题" class="headerlink" title="分割类型题"></a>分割类型题</h2><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>给你一个整数 n，返回和为 n 的完全平方数的最少数量。</p><p>示例 1：</p><blockquote><p>输入：n = 12<br>输出：3 </p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 13<br>输出：2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。我们定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 最少可以由几个完全平方数相加构成。在本题中，位置 i 只依赖 $i - k^2$ 的位置，如 i - 1、i - 4、i - 9 等等，才能满足完全平方分割的条件。因此，状态转移方程为：</p><script type="math/tex; mode=display">dp[i]=1+min(dp[i-1],dp[i-4],dp[i-9]······)</script><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++)</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/">解码方法</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>一条包含字母 A-Z 的消息通过以下映射进行了编码：</p><blockquote><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”</p></blockquote><p>要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><blockquote><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)</p></blockquote><p>注意，消息不能分组为 (1 11 06)，因为 “06” 不能映射为 “F”，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的非空字符串 s，请计算并返回解码方法的总数 。</p><p>题目数据保证答案肯定是一个 32 位的整数。</p><p>示例 1：</p><blockquote><p>输入：s = “12”<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “226”<br>输出：3</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = “0”<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>就是要把一个大数字分割为一堆 1-26 的数字，设 dp[i] 表示字符串前 i 个字符的解码方法数，则状态转移方程为：</p><script type="math/tex; mode=display">dp[i]=\begin{cases}dp[i-1], & s[i] \neq 0 \\dp[i-2], & s[i-1] \neq 0 \quad\&\quad s[i-1]*10+s[i]<=26\end{cases}</script><p>重叠部分叠加即可，注意数组下标从 0 开始。边界条件为 dp[0] = 1。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i<span class="number">-1</span>] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            dp[i] += dp[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s[i<span class="number">-2</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; (s[i<span class="number">-2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)</span><br><span class="line">            dp[i] += dp[i<span class="number">-2</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">单词拆分</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s。s 和 wordDict[i] 仅有小写英文字母组成，wordDict 中的所有字符串互不相同。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>示例 1：</p><blockquote><p>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true</p></blockquote><p>示例 2：</p><blockquote><p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true</p></blockquote><p>示例 3：</p><blockquote><p>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>能否拼接，可以转化为能否拆分，类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。注意对于位置 0，需要初始化值为真。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string &amp; word: wordDict) &#123;</span><br><span class="line">            <span class="type">int</span> len = word.<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len &amp;&amp; s.<span class="built_in">substr</span>(i - len, len) == word)</span><br><span class="line">                dp[i] = dp[i] || dp[i - len];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个整数数组 nums，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><blockquote><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [0,1,0,3,2,3]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>对于子序列问题，第一种动态规划方法是，定义一个 dp 数组，其中 dp[i] 表示以 i 结尾的符合某性质的子序列的个数。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。</p><p>在本题中，dp[i] 可以表示以 i 结尾的、最长递增子序列长度。对于每一个位置 i，如果其之前的某个位置 j 所对应的数字小于位置 i 所对应的数字，则我们可以获得一个以 i 结尾的、长度为 dp[j]+1 的子序列。为了遍历所有情况，我们需要 i 和 j 进行两层循环，其时间复杂度为 O($n^2$)。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_length = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题还可以使用二分查找将时间复杂度降低为 O(n log n)。我们定义一个 dp 数组，其中 dp[k] 存储长度为 k+1 的最长递增子序列的最后一个数字。我们遍历每一个位置 i，如果其对应的数字大于 dp 数组中所有数字的值，那么我们把它放在 dp 数组尾部，表示最长递增子序列长度加 1；如果我们发现这个数字在 dp 数组中比数字 a 大、比数字 b 小，则我们将 b 更新为此数字，使得之后构成递增序列的可能性增大。以这种方式维护的 dp 数组永远是递增的，因此可以用二分查找加速搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">    dp.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp.<span class="built_in">back</span>() &lt; nums[i])</span><br><span class="line">            dp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> itr = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[i]);</span><br><span class="line">            *itr = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定两个仅由小写英文字母组成的字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。</p><p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p><p>两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><blockquote><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3  </p></blockquote><p>示例 2：</p><blockquote><p>输入：text1 = “abc”, text2 = “abc”<br>输出：3</p></blockquote><p>示例 3：</p><blockquote><p>输入：text1 = “abc”, text2 = “def”<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>对于子序列问题，第二种动态规划方法是，定义一个 dp 数组，其中 dp[i] 表示到位置 i 为止的子序列的性质，并不必须以 i 结尾。这样 dp 数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。</p><p>在本题中，我们可以建立一个二维数组 dp，其中 dp[i][j] 表示到第一个字符串位置 i 为止、到第二个字符串位置 j 为止、最长的公共子序列长度。这样一来我们就可以很方便地分情况讨论这两个位置对应的字母相同与不同的情况了。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包问题是一种组合优化的 NP 完全问题：有 N 个物品和容量为 W 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为无界背包问题或完全背包问题。</p><h3 id="1-“0-1”背包问题"><a href="#1-“0-1”背包问题" class="headerlink" title="1.“0-1”背包问题"></a>1.“0-1”背包问题</h3><p>我们可以用动态规划来解决背包问题。以 0-1 背包问题为例。我们可以定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，如果我们不将物品 i 放入背包，那么 dp[i][j] = dp[i-1][j]，即前 i 个物品的最大价值等于只取前 i-1 个物品时的最大价值；如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 dp[i][j] = dp[i-1][j-w] + v。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为 O(NW)。</p><p><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)</code></p><p>转化为代码语言如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w] + v);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以进一步对 0-1 背包进行空间优化，将空间复杂度降低为 O(W)。从状态转移方程可以看出，考虑第 i 个物品时，只与上一行有关，因此我们可以去掉 dp 矩阵的第一个维度，在考虑物品 i 时变成 dp[j] = max(dp[j], dp[j-w] + v)。这里要注意我们在遍历每一行的时候必须<strong>逆向遍历</strong>，这样才能够调用上一行物品 i-1 时 dp[j-w] 的值；若按照从左往右的顺序进行正向遍历，则 dp[j-w] 的值在遍历到 j 之前就已经被更新成物品 i 的值了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = W; j &gt;= w; j--)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h3><p>在完全背包问题中，一个物品可以拿多次。假设物品体积均为 2，假设我们遍历到物品 i = 2 且其体积为 w = 2，价值为 v = 3；对于背包容量 j = 5，最多只能装下 2 个该物品。那么我们的状态转移方程就变成了 dp[2][5] = max(dp[1][5], dp[1][3] + 3, dp[1][1] + 6)。如果采用这种方法，假设背包容量无穷大而物体的体积无穷小，我们这里的比较次数也会趋近于无穷大，远超 O(NW) 的时间复杂度。</p><p>怎么解决这个问题呢？我们发现在 dp[2][3] 的时候我们其实已经考虑了 dp[1][3] 和 dp[2][1] 的情况，而在 dp[2][1] 也已经考虑了 dp[1][1] 的情况。因此，对于拿多个物品的情况，我们只需考虑 dp[2][3] 即可，即 dp[2][5] = max(dp[1][5], dp[2][3] + 3)。这样，我们就得到了完全背包问题的状态转移方程：</p><p><code>dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)</code></p><p>其与 0-1 背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j-w] + v);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以利用空间压缩将时间复杂度降低为 O(W)。这里要注意我们在遍历每一行的时候必须<strong>正向遍历</strong>，因为我们需要利用当前物品在第 j-w 列的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = w; j &lt;= W; j++)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个只包含正整数的非空数组 nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,5,11,5]<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,2,3,5]<br>输出：false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>等价于“0-1”背包问题，输出是否可以取出总和正好为 sum/2 的数字，把数字大小看做体积，不用考虑价值，dp[i][j] 表示是否能正好取出体积为 j 的物品</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(target + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j - nums[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= nums[i<span class="number">-1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n。请你找出并返回 strs 的最大子集的长度，该子集最多有 m 个 0 和 n 个 1。如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的子集 。</p><p>示例 1：</p><blockquote><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：strs = [“10”, “0”, “1”], m = 1, n = 1<br>输出：2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>这里有两个不同维度的体积，dp[i][j][k] 表示在遍历到第 i 个物品时，在 0 的个数小于等于 m，1 的个数小于等于 n 时，所能取到的最大子集长度，则状态转移方程为：</p><script type="math/tex; mode=display">dp[i][j][k]=\begin{cases}dp[i-1][j][k] \\dp[i-1][j-num0][k-num1] + 1\end{cases}</script><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="type">const</span> string &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count0 = s.<span class="built_in">length</span>(), count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; c: s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">            count0--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(count0, count1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = strs.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(length + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [zeros, ones] = <span class="built_in">count</span>(strs[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; zeros || k &lt; ones)</span><br><span class="line">                    dp[i][j][k] = dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j][k] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k], dp[i<span class="number">-1</span>][j-zeros][k-ones] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length][m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个整数数组 coins，表示不同面额的硬币；以及一个整数 amount，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><blockquote><p>输入：coins = [1, 2, 5], amount = 11<br>输出：3 </p></blockquote><p>示例 2：</p><blockquote><p>输入：coins = [2], amount = 3<br>输出：-1</p></blockquote><p>示例 3：</p><blockquote><p>输入：coins = [1], amount = 0<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>完全背包问题，dp[i] 表示总金额为 i 时的最少硬币个数，则状态转移方程为：</p><script type="math/tex; mode=display">dp[i] = \mathop{min}\limits_{j=0,1,···}dp[i-c_j]+1</script><p>因为遍历 j 时会实时更新 dp[i] 的值，所以方程变为：</p><script type="math/tex; mode=display">dp[i]=min(dp[i], dp[i-current\_coin]+1)</script><p>为了避免dp[i]刚开始就被取到，初始值取为amount + 1，同时也可以判断最后是否输出 -1。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coin.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin)</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h2><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你两个单词 word1 和 word2，请返回将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行三种操作：插入一个字符，删除一个字符，替换一个字符。</p><p>示例 1：</p><blockquote><p>输入：word1 = “horse”, word2 = “ros”<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：word1 = “intention”, word2 = “execution”<br>输出：5</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>类似于题目 1143，我们使用一个二维数组 dp[i][j]，表示将第一个字符串到位置 i 为止，和第二个字符串到位置 j 为止，最多需要几步编辑。当第 i 位和第 j 位对应的字符相同时，dp[i][j] 等于 dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是 dp[i-1][j-1] + 1，插入 i 位置/删除 j 位置的消耗是 dp[i][j-1] + 1，插入 j 位置/删除 i 位置的消耗是 dp[i-1][j] + 1。边界条件为 dp[0][j] = j，dp[i][0] = i</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + ((word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) ? <span class="number">0</span> : <span class="number">1</span>), <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>] + <span class="number">1</span>, dp[i<span class="number">-1</span>][j] + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a><a href="https://leetcode.cn/problems/2-keys-keyboard/">只有两个键的键盘</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>最初记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p><blockquote><p>Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br>Paste（粘贴）：粘贴上一次复制的字符。</p></blockquote><p>给你一个数字 n，你需要使用最少的操作次数，在记事本上输出恰好 n 个 ‘A’。返回能够打印出 n 个 ‘A’ 的最少操作次数。</p><p>示例 1：</p><blockquote><p>输入：3<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：1<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。设 dp[i] 表示得到 i 个 ‘A’ 的最少操作数，要得到 i 个，对于 i 的因子 j，从 j 个到 i 个最少操作次数等价于 1 到 i/j，即 dp[i/j]，从 1 到 j 最少操作次数为 dp[j]，所以状态转移方程为：</p><script type="math/tex; mode=display">dp[i]=dp[j]+dp[i/j]</script><p>若 i 为素数，则只能通过一次复制，若干次粘贴得到，故边界条件为 dp[i] = i。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSteps</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[j] + dp[i/j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><blockquote><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素</p></blockquote><p>所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。</p><p>示例 1：</p><blockquote><p>输入：s = “aa”, p = “a”<br>输出：false</p></blockquote><p>示例 2:</p><blockquote><p>Input: s = “aab”, p = “c*a*b”<br>Output: true<br>我们可以重复 c 零次，重复 a 两次。</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = “ab”, p = “.*“<br>输出：true</p></blockquote><p>提示：</p><ul><li>s 只包含从 a-z 的小写字母。</li><li>p 只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>我们可以使用一个二维数组 dp，其中 dp[i][j] 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。根据正则表达式的不同情况，即字符、星号，点号，我们可以分情况讨论来更新 dp 数组。状态转移方程如下：</p><script type="math/tex; mode=display">dp[i][j]=\begin{cases}    p[j]为小写字母\begin{cases}        dp[i-1][j-1], & s[i] = p[j] \\        false, & s[i] \neq p[j]    \end{cases} \\    p[j]='.', \quad dp[i-1][j-1] \\    p[j]='*'\begin{cases}    dp[i][j-2], & s[i] \neq p[j-1] \\    dp[i-1][j] \quad or \quad dp[i][j-2], & s[i]=p[j-1],(包含p[j-1]='.')    \end{cases}\end{cases}</script><p>其中 p[j] = ‘*’ 时的情况比较复杂，本质上只有两种操作方式：</p><ul><li>匹配一次后继续向前匹配，即 dp[i-1][j]，s[i]=s[i-1]=···=p[j-1]的情况。</li><li>匹配0次，扔掉p[j-1]和’*’，继续比较，即 dp[i][j-2]。</li></ul><p>代码如下，注意数组下标。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>(), i, j;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">//空串能够匹配</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[i][j] |= dp[i][j<span class="number">-2</span>];<span class="comment">//*匹配0次前面的字符</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">match</span>(s,p,i,j<span class="number">-1</span>)) <span class="comment">//s第i个和p的第j-1个可以匹配, *匹配再多匹配一次i字符</span></span><br><span class="line">                    dp[i][j] |= dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">match</span>(s,p,i,j))<span class="comment">//必须是i、j能够匹配</span></span><br><span class="line">                    dp[i][j] |= dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string &amp;s, string &amp;p, <span class="type">int</span> i, <span class="type">int</span> j)</span>  </span>&#123;   <span class="comment">//第i,j个字符能匹配</span></span><br><span class="line">    <span class="keyword">return</span> i&gt;<span class="number">0</span> &amp;&amp; (p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span> || p[j<span class="number">-1</span>] == s[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h2><h3 id="买卖股票的最佳时期"><a href="#买卖股票的最佳时期" class="headerlink" title="买卖股票的最佳时期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时期</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个数组 prices，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0。</p><p>示例 1：</p><blockquote><p>输入：[7,1,5,3,6,4]<br>输出：5</p></blockquote><p>示例 2：</p><blockquote><p>输入：prices = [7,6,4,3,1]<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>我们可以遍历一遍数组，在每一个位置 i 时，记录 i 位置之前所有价格中的最低价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; dp[i])</span><br><span class="line">            dp[i+<span class="number">1</span>] = prices[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - dp[i+<span class="number">1</span>] &gt; max)</span><br><span class="line">                max = prices[i] - dp[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上记录最低价用一个变量即可，这里只是为了DP而DP</p></blockquote>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机IV</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个整数数组 prices，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1：</p><blockquote><p>输入：k = 2, prices = [2,4,1]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：k = 2, prices = [3,2,6,5,0,3]<br>输出：7</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>如果 k 大于总天数的一半，那么我们一旦发现可以赚钱就可以进行买卖；这里一半的原因是因为当天股价是不变的，因此一次买卖需要两天。如果 k 小于总天数，我们用 buy[i][j] 表示对于数组 prices[0..i] 中的价格而言，进行恰好 j 笔交易，并且当前手上持有一支股票，这种情况下的最大利润；用 sell[i][j] 表示恰好进行 j 笔交易，并且当前手上不持有股票，这种情况下的最大利润。</p><blockquote><p>为了方便分析，买入不算交易，卖出才算一次交易</p></blockquote><p>那么我们可以对状态转移方程进行推导。对于 buy[i][j]，我们考虑当前手上持有的股票是否是在第 i 天买入的。可以得到状态转移方程：</p><script type="math/tex; mode=display">buy[i][j]=max(buy[i−1][j],sell[i−1][j]−price[i])</script><p>同理对于 sell[i][j]，我们可以得到状态转移方程：</p><script type="math/tex; mode=display">sell[i][j]=max(sell[i−1][j],buy[i−1][j−1]+price[i])</script><p>在上述的状态转移方程中，确定边界条件是非常重要的步骤。我们可以考虑将所有的 buy[0][0..k] 以及 sell[0][0..k] 设置为边界。</p><p>对于 buy[0][0..k]，由于只有 prices[0] 唯一的股价，因此我们不可能进行过任何交易，那么我们可以将所有的 buy[0][1..k] 设置为一个非常小的值，表示不合法的状态。而对于 buy[0][0]，它的值为 −prices[0]，即「我们在第 0 天以 prices[0] 的价格买入股票」是唯一满足手上持有股票的方法。</p><p>同理我们可以将所有的 sell[0][1..k] 设置为一个非常小的值，表示不合法的状态。而对于 sell[0][0]，它的值为 0，即「我们在第 0 天不做任何事」是唯一满足手上不持有股票的方法。</p><p>在设置完边界之后，我们就可以使用二重循环，在 i∈[1,n),j∈[0,k] 的范围内进行状态转移。需要注意的是，sell[i][j] 的状态转移方程中包含 buy[i−1][j−1]，在 j=0 时其表示不合法的状态，因此在 j=0 时，我们无需对 sell[i][j] 进行转移，让其保持值为 0 即可。</p><blockquote><p>注意，不一定交易次数多了就利润高</p></blockquote><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> days = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (days &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k * <span class="number">2</span> &gt;= days)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxProfitUnlimited</span>(prices);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(k + <span class="number">1</span>, INT_MIN)</span>, <span class="title">sell</span><span class="params">(k + <span class="number">1</span>, INT_MIN/<span class="number">2</span>)</span></span>;</span><br><span class="line">    buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            buy[j] = <span class="built_in">max</span>(buy[j], sell[j] - prices[i]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                sell[j] = <span class="built_in">max</span>(sell[j], buy[j<span class="number">-1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(sell.<span class="built_in">begin</span>(), sell.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfitUnlimited</span><span class="params">(vector&lt;<span class="type">int</span>&gt; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i<span class="number">-1</span>])</span><br><span class="line">            maxProfit += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="买卖股票之含冷冻期"><a href="#买卖股票之含冷冻期" class="headerlink" title="买卖股票之含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">买卖股票之含冷冻期</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个整数数组 prices，其中第 prices[i] 表示第 i 天的股票价格。设计一个算法计算出最大利润。</p><p>在满足以下约束条件下，你可以尽可能地完成更多的交易：卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><blockquote><p>输入: prices = [1,2,3,0,2]<br>输出: 3 </p></blockquote><p>示例 2:</p><blockquote><p>输入: prices = [1]<br>输出: 0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>考虑第 i 天结束后的情况，有三种状态：</p><ul><li>手里有一支股票，最大收益用 dp[i][0] 表示</li><li>手里没有股票，今天刚卖掉，明天处于冷冻期，最大收益用 dp[i][1] 表示</li><li>手里没有股票，早就卖掉了，明天不是冷冻期，最大收益用 dp[i][2] 表示</li></ul><p>则状态转移方程为：</p><script type="math/tex; mode=display">\begin{align*}dp[i][0]&=max(dp[i-1][0], dp[i-1][2]-prices[i]) \\dp[i][1]&=dp[i-1][0]+prices[i] \\dp[i][2]&=max(dp[i-1][1], dp[i-1][2])\end{align*}</script><p>因为最后一天持有股票显然不是最大收益，所以最终答案为 max(dp[n][1], dp[n][2]);</p><p>考虑边界条件:</p><script type="math/tex; mode=display">\begin{align}dp[1][0]&=-prices[0] \\dp[1][1]&=0 \\dp[1][2]&=0\end{align}</script><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] - prices[i<span class="number">-1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i<span class="number">-1</span>];</span><br><span class="line">        dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用状态机来解决这类复杂的状态转移问题，通过建立多个状态以及它们的转移方式，我们可以很容易地推导出各个状态的转移方程。如图所示，我们可以建立四个状态来表示带有冷却的股票交易，以及它们的之间的转移方式。</p><p><img src="https://s2.loli.net/2022/08/05/nrGIsifHb49WAM7.png" alt="状态机" style="zoom:33%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(n)</span>, <span class="title">sell</span><span class="params">(n)</span>, <span class="title">s1</span><span class="params">(n)</span>, <span class="title">s2</span><span class="params">(n)</span></span>;</span><br><span class="line">    s1[<span class="number">0</span>] = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        buy[i] = s2[i<span class="number">-1</span>] - prices[i];</span><br><span class="line">        s1[i] = <span class="built_in">max</span>(buy[i<span class="number">-1</span>], s1[i<span class="number">-1</span>]);</span><br><span class="line">        sell[i] = <span class="built_in">max</span>(buy[i<span class="number">-1</span>], s1[i<span class="number">-1</span>]) + prices[i];</span><br><span class="line">        s2[i] = <span class="built_in">max</span>(s2[i<span class="number">-1</span>], sell[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(sell[n<span class="number">-1</span>], s2[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，今晚能够偷窃到的最高金额。</p><p>示例 1：</p><blockquote><p>输入：nums = [2,3,2]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,2,3,1]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：3</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>与之前的区别在于若偷了第一间，则偷窃范围为1 ~ n-1，若没偷第一间，则偷窃范围为2 ~ n</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp1</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">dp2</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp1[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp2[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp1[i] = <span class="built_in">max</span>(dp1[i<span class="number">-2</span>] + nums[i<span class="number">-1</span>], dp1[i<span class="number">-1</span>]);</span><br><span class="line">        dp2[i] = <span class="built_in">max</span>(dp2[i<span class="number">-2</span>] + nums[i], dp2[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp1[n<span class="number">-1</span>], dp2[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p>示例 1：</p><blockquote><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1]<br>输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [5,4,-1,7,8]<br>输出：23</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>dp[i] 表示以 nums[i] 结尾的连续子数组的最大和，则 <script type="math/tex">dp[i] = max(dp[i-1] + nums[i], nums[i])</script></p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>] + nums[i], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将一维空间压缩为常量，考虑到 dp[i] 只和 dp[i-1] 相关，于是我们可以只用一个变量 pre 来维护对于当前 dp[i] 的 dp[i-1] 的值是多少，从而让空间复杂度降低到 O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> pre = nums[<span class="number">0</span>], cur, Max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur = <span class="built_in">max</span>(pre + nums[i], nums[i]);</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; Max)</span><br><span class="line">            Max = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">整数拆分</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个正整数 n，将其拆分为 k 个正整数的和（k &gt;= 2），并使这些整数的乘积最大化。返回你可以获得的最大乘积。</p><p>示例 1:</p><blockquote><p>输入: n = 2<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: n = 10<br>输出: 36</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>设 dp[i] 表示将 i 拆分后的最大乘积，假设将 i 拆分为 j 和 i-j，或者继续拆分，取较大值即可，即 <script type="math/tex">dp[i]=\mathop{max}\limits_{0<j<i}(j\times (i-j), j\times dp[i-j])</script></p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            Max = <span class="built_in">max</span>(Max, <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">        dp[i] = Max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定两个单词 word1 和 word2，返回使得 word1 和  word2 相同所需的最小步数。每步可以删除任意一个字符串中的一个字符。</p><p>示例 1：</p><blockquote><p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2</p></blockquote><p>示例  2:</p><blockquote><p>输入：word1 = “leetcode”, word2 = “etco”<br>输出：4</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>dp[i][j] 表示使 word1[0:i] 和 word2[0:j] 相同的最少删除操作次数。</p><script type="math/tex; mode=display">\begin{align*}dp[i][j]&=\begin{cases}dp[i-1][j-1], & word1[i]=word2[j]\\min(dp[i-1][j], dp[i][j-1])+1, & word1[i]\neq word2[j]\end{cases}\\dp[0][j]&=j; \\ dp[i][0]&=i;\end{align*}</script><blockquote><p>上述表示中，word[0:i]表示前 i 个元素</p></blockquote><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">size</span>(), n = word2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩到一维，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">size</span>(), n = word2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        dp[j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> last = dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> old = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[j] = last;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            last = old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里用last记录dp[i-1][j-1]，因为在正向遍历中它会先被更新为dp[i][j-1]</p></blockquote>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="最长数对链"><a href="#最长数对链" class="headerlink" title="最长数对链"></a><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/">最长数对链</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给出 n 个数对。在每一个数对中，第一个数字总是比第二个数字小。现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p><p>给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p><p>示例：</p><blockquote><p>输入：[[1,2], [2,3], [3,4]]<br>输出：2<br>解释：最长的数对链是 [1,2] -&gt; [3,4]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>dp[i] 表示以数对 i 结尾的最长数对链长度，则当 j &gt; i 且 pairs[i][1] &lt; pairs[j][0] 时有 <script type="math/tex">dp[j]=max(dp[j], dp[i]+1)</script></p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestChain</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> n = pairs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs[i][<span class="number">1</span>] &lt; pairs[j][<span class="number">0</span>])</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如，[1, 7, 4, 9, 2, 5] 是一个摆动序列，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums，返回 nums 中作为摆动序列的最长子序列的长度。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,7,4,9,2,5]<br>输出：6</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1,2,3,4,5,6,7,8,9]<br>输出：2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>up[i] 表示范围 0~i 最长摆动子序列长度，末尾向上摆，down[i] 表示末尾向下摆，则</p><script type="math/tex; mode=display">\begin{align*}up[i]&=\begin{cases}up[i-1] & nums[i]≤nums[i-1] \\max(up[i-1], down[i-1]+1) & nums[i]>nums[i-1]\end{cases}\\down[i]&=\begin{cases}down[i-1] & nums[i]≥nums[i-1] \\max(down[i-1], up[i-1]+1) & nums[i]<nums[i-1]\end{cases}\\up[0]&=down[0]=1\end{align*}</script><p>这里的状态转移方程可能很难理解，下面证明一下 up[i] 的式子，down同理：</p><p>当 nums[i]&lt;=nums[i-1] 时，找不到比 up[i-1] 更长的了，因为任意以 nums[i] 结尾的末尾向上摆的都可以把 nums[i] 换成 nums[i-1]，且若不以 nums[i] 结尾，就等价于 up[i-1]，所以 up[i] = up[i-1]；</p><p>当 nums[i]&gt;nums[i-1]，如果不取 nums[i]，则 up[i]=up[i-1]，如果取 nums[i]，则分别考虑如何从 up[i-1] 和 down[i-1] 转移过来，如果从 up[i-1] 转移过来，那么必须经过 down[i-1]，所以只考虑 down[i-1] 即可，设末尾元素为 nums[j]，若nums[j]&gt;=nums[i-1]，则可以替换为nums[i-1]，后面接上 nums[i]，若 nums[j]&lt;nums[i-1]，则可以直接在后面加上 nums[i]，总之就是 up[i] = down[i-1] + 1；</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span> &amp;&amp; nums[<span class="number">0</span>] != nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">down</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            up[i] = <span class="built_in">max</span>(down[i<span class="number">-1</span>] + <span class="number">1</span>, up[i<span class="number">-1</span>]);</span><br><span class="line">            down[i] = down[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            down[i] = <span class="built_in">max</span>(up[i<span class="number">-1</span>] + <span class="number">1</span>, down[i<span class="number">-1</span>]);</span><br><span class="line">            up[i] = up[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            up[i] = up[i<span class="number">-1</span>];</span><br><span class="line">            down[i] = down[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(up[n<span class="number">-1</span>], down[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然可以压缩为常量空间，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span> &amp;&amp; nums[<span class="number">0</span>] != nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">            up = <span class="built_in">max</span>(down + <span class="number">1</span>, up);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">            down = <span class="built_in">max</span>(up + <span class="number">1</span>, down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(up, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode.cn/problems/target-sum/">目标和</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个整数数组 nums 和一个整数 target。向数组中的每个整数前添加 ‘+’ 或 ‘-‘，然后串联起所有整数，可以构造一个表达式：</p><p>例如，nums = [2, 1]，可以在 2 之前添加 ‘+’，在 1 之前添加 ‘-‘，然后串联起来得到表达式 “+2-1”。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同表达式的数目。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1], target = 1<br>输出：1</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>一个比较巧妙的方法，只考虑加法，剩下的全部做减法，设总和为 sum，则加法目标和为<script type="math/tex">(sum + target) /2</script>，然后就转化为了“0-1”背包问题。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        n = -n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= nums[i<span class="number">-1</span>]; j--)</span><br><span class="line">            dp[j] += dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="买卖股票之含手续费"><a href="#买卖股票之含手续费" class="headerlink" title="买卖股票之含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票之含手续费</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个整数数组 prices，其中 prices[i] 表示第 i 天的股票价格；整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>示例 1：</p><blockquote><p>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出：8</p></blockquote><p>示例 2：</p><blockquote><p>输入：prices = [1,3,7,5,10,3], fee = 3<br>输出：6</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>第 i 天结束时，dp[i][0] 表示手里没有股票的最大利润，dp[i][1] 表示手里有股票的最大利润，则</p><script type="math/tex; mode=display">\begin{align*}dp[i][0]&=max(dp[i-1][0], dp[i-1][1]+prices[i-1]-fee)\\dp[i][1]&=max(dp[i-1][1], dp[i-1][0]-prices[i-1])\\dp[1][0]&=0 \\dp[1][1] &= -prices[0]\end{align*}</script><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i<span class="number">-1</span>] - fee);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩大法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sell = <span class="number">0</span>, buy = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, buy + prices[i<span class="number">-1</span>] - fee);</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, sell - prices[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切皆可搜索</title>
      <link href="/posts/1b2b09bd/"/>
      <url>/posts/1b2b09bd/</url>
      
        <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。</p><p>在大规模实验环境中，通常通过在搜索前，根据条件降低搜索规模；根据问题的约束条件进行剪枝；利用搜索过程中的中间解，避免重复计算这几种方法进行优化。</p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。</p><p>考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“深”的方向前进的策略，假如我们使用递归实现，我们的遍历过程为 1（起始节点）-&gt;2（遍历更深一层的左子节点）-&gt;4（遍历更深一层的左子节点）-&gt;2（无子节点，返回父结点）-&gt;1（子节点均已完成遍历，返回父结点）-&gt;3（遍历更深一层的右子节点）-&gt;1（无子节点，返回父结点）-&gt;结束程序（子节点均已完成遍历）。如果我们使用栈实现，我们的栈顶元素的变化过程为 1-&gt;2-&gt;4-&gt;3。</p><p><img src="https://s2.loli.net/2022/08/04/HjNsDCer1JM5nI3.png" alt="示例" style="zoom:100%;" /></p><p>深度优先搜索也可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存在入度不为零的点，则说明有环。</p><p>有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这种做法叫做状态记录或记忆化（memoization)。</p><h3 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个大小为 m x n 的二进制矩阵 grid。</p><p>岛屿是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直的四个方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0。</p><p>示例 1：</p><blockquote><p>输入:<br>[[1,0,1,1,0,1,0,1],<br>[1,0,1,1,0,1,1,1],<br>[0,0,0,0,0,0,0,1]]<br>输出: 6</p></blockquote><p>示例 2：</p><blockquote><p>输入：grid = [[0,0,0,0,0,0,0,0]]<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>此题是十分标准的搜索题，我们可以拿来练手深度优先搜索。一般来说，深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否可以开始搜索，如果可以即在辅函数进行搜索。辅函数则负责深度优先搜索的递归调用。</p><p>当然，我们也可以使用栈（stack）实现深度优先搜索，但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时笔者推荐使用递归式写法，同时也方便进行回溯（见下节）。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <h4 id="1-使用栈："><a href="#1-使用栈：" class="headerlink" title="1.使用栈："></a>1.使用栈：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = m ? grid[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> local_area, area = <span class="number">0</span>, x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                local_area = <span class="number">1</span>;</span><br><span class="line">                grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; island;</span><br><span class="line">                island.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                <span class="keyword">while</span> (!island.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [r, c] = island.<span class="built_in">top</span>();</span><br><span class="line">                    island.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        x = r + direction[k];</span><br><span class="line">                        y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m</span><br><span class="line">                            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                            grid[x][y] = <span class="number">0</span>;</span><br><span class="line">                            local_area++;</span><br><span class="line">                            island.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                area = <span class="built_in">max</span>(area, local_area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里我们使用了一个小技巧，对于四个方向的遍历，可以创造一个数组 [-1, 0, 1, 0, -1]，每相邻两位即为上下左右四个方向之一。</p></blockquote><h4 id="2-使用递归："><a href="#2-使用递归：" class="headerlink" title="2.使用递归："></a>2.使用递归：</h4><p>在辅函数里，一个一定要注意的点是辅函数内递归搜索时，边界条件的判定。边界判定一般有两种写法，一种是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。</p><p>第一种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x, y, area = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        x = r + direction[i];</span><br><span class="line">        y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()) </span><br><span class="line">            area += <span class="built_in">dfs</span>(grid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>()</span><br><span class="line">        || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[r][c] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a><a href="https://leetcode.cn/problems/number-of-provinces/">省份数量</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中省份的数量。</p><p>示例 1：</p><blockquote><p>输入：isConnected =<br>[[1,1,0],<br>[1,1,0],<br>[0,0,1]]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：isConnected =<br>[[1,0,0],<br>[0,1,0],<br>[0,0,1]]<br>输出：3</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>实际上与上一题是一样的，上题中矩阵每个元素都可看做一个结点，上下左右相邻即有关系；本题中每一行或列为一个结点，元素为 1 即有关系。这里我们采用第一种递归写法。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; friends)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = friends.<span class="built_in">size</span>(), count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(friends, i, visited);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; friends, <span class="type">int</span> i, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; friends.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (friends[i][k] == <span class="number">1</span> &amp;&amp; !visited[k])</span><br><span class="line">            <span class="built_in">dfs</span>(friends, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="太平洋大西洋水流问题"><a href="#太平洋大西洋水流问题" class="headerlink" title="太平洋大西洋水流问题"></a><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">太平洋大西洋水流问题</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>有一个 m × n 的矩形岛屿，与太平洋和大西洋相邻。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights，heights[r][c] 表示坐标 (r, c) 上单元格高于海平面的高度。</p><p>岛上雨水较多，如果相邻单元格的高度小于或等于当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p><p>返回网格坐标 result 的 2D 列表，其中 result[i] = [ri, ci] 表示雨水从单元格 (ri, ci) 流动既可流向太平洋也可流向大西洋。</p><p>示例 1：</p><blockquote><p>输入: heights =<br>[[1,2,2,3,5],<br>[3,2,3,4,4],<br>[2,4,5,3,1],<br>[6,7,1,4,5],<br>[5,1,1,2,4]]<br>输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]</p></blockquote><p>示例 2：</p><blockquote><p>输入: heights =<br>[[2,1],<br>[1,2]]<br>输出: [[0,0],[0,1],[1,0],[1,1]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>虽然题目要求的是满足向下流能到达两个大洋的位置，如果我们对所有的位置进行搜索，那么在不剪枝的情况下复杂度会很高。因此我们可以反过来想，从两个大洋开始向上流，这样我们只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋向上流都能到达的位置。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">can_reach_p</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">can_reach_a</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, m - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_reach_p[i][j] &amp;&amp; can_reach_a[i][j])</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; can_reach,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (can_reach[r][c])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    can_reach[r][c] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        x = r + direction[i];</span><br><span class="line">        y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>() </span><br><span class="line">            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; matrix[r][c] &lt;= matrix[x][y])</span><br><span class="line">            <span class="built_in">dfs</span>(matrix, can_reach, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便。</p><p>顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。在具体的写法上，它与普通的深度优先搜索一样，都有 [修改当前节点状态]→[递归子节点]的步骤，只是多了回溯的步骤，变成[修改当前节点状态]→[递归子节点]→[回改当前节点状态]。</p><p>两个小诀窍，一是按引用传状态，二是所有的状态修改在递归完成后回改。</p><p>回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标<br>记，比如矩阵里搜字符串。</p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode.cn/problems/permutations/">全排列</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个不含重复数字的数组 nums ，返回其所有可能的全排列。你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1]<br>输出：[[1]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>按数组序穷举所有可能的排列，已经取过的标记一下，找到一组后向前回溯，取消标记，继续按此方法搜索。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isIn</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">retSeq</span>(result, temp, nums, <span class="number">0</span>, isIn);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">retSeq</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;result, vector&lt;<span class="type">int</span>&gt; temp, vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> len, vector&lt;<span class="type">int</span>&gt; isIn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == nums.<span class="built_in">size</span>())</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isIn[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                isIn[i] = <span class="number">1</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                len++;</span><br><span class="line">                <span class="built_in">retSeq</span>(result, temp, nums, len, isIn);</span><br><span class="line">                len--;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">                isIn[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里提供一份更简洁优雅的代码，因为数字互不重复，所以穷举所有交换即可。代码框架和上面还是一样的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> level, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, level+<span class="number">1</span>, ans); <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>                       <p>不难看出回溯算法代码框架如下：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">主函数 &#123;</span><br><span class="line">       定义结果数组;</span><br><span class="line">       调用辅函数(目标数组，结果数组，递归层数);</span><br><span class="line">       返回结果数组;</span><br><span class="line">&#125;</span><br><span class="line">辅函数 &#123;</span><br><span class="line">       递归出口;</span><br><span class="line">       循环 &#123;</span><br><span class="line">           完成当前层的操作;</span><br><span class="line">           递归调用下一层的辅函数;</span><br><span class="line">           回溯当前层的改变量;   </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a><a href="https://leetcode.cn/problems/combinations/">组合</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按任何顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：n = 4, k = 2<br>输出：<br>[[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 1, k = 1<br>输出：[[1]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>和上一题区别在于取的数字个数和不考虑取出顺序，第一点只是影响了结果数组大小，第二点可以这样解决：向后取数字，控制取出的组合升序，这样就避免了重复。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">comb</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, comb, count, <span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; comb, <span class="type">int</span>&amp; count, <span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= n; i++) &#123;</span><br><span class="line">        comb[count++] = i;</span><br><span class="line">        <span class="built_in">backtracking</span>(ans, comb, count, i + <span class="number">1</span>, n, k);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">单词搜索</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word。如果 word 存在于网格中，返回 true；否则，返回 false。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例 1：</p><blockquote><p>输入：board =<br>[[“A”,”B”,”C”,”E”],<br>[“S”,”F”,”C”,”S”],<br>[“A”,”D”,”E”,”E”]],<br>word = “ABCCED”<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：board =<br>[[“A”,”B”,”C”,”E”],<br>[“S”,”F”,”C”,”S”],<br>[“A”,”D”,”E”,”E”]],<br>word = “ABCB”<br>输出：false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>在我们对任意位置进行深度优先搜索时，我们先标记当前位置为已访问，以避免重复遍历（如防止向右搜索后又向左返回）；在所有的可能都搜索完成后，再回改当前位置为未访问，防止干扰其它位置搜索到当前位置。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="type">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">backtracking</span>(i, j, board, word, find, visited, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="type">bool</span>&amp; find, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j] || find || board[i][j] != word[pos])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(i + <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i - <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j + <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j - <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><a href="https://leetcode.cn/problems/n-queens/">N皇后</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例 1：</p><blockquote><p>输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 1<br>输出：[[“Q”]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>和上一题是类似的，本题也是通过修改状态矩阵来进行回溯。不同的是，我们需要对每一行、列、左斜、右斜建立访问数组，来记录它们是否存在皇后。另外，本题中限制了每一行只有一个皇后，所以不用遍历矩阵中每一个位置，只需遍历每一行即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">column</span><span class="params">(n, <span class="literal">false</span>)</span>, <span class="title">ldiag</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>)</span>, <span class="title">rdiag</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, board, column, ldiag, rdiag, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; &amp;board, vector&lt;<span class="type">bool</span>&gt; &amp;column, vector&lt;<span class="type">bool</span>&gt; &amp;ldiag, vector&lt;<span class="type">bool</span>&gt; &amp;rdiag, <span class="type">int</span> row, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (column[i] || ldiag[n-row+i<span class="number">-1</span>] || rdiag[row+i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        board[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        column[i] = ldiag[n-row+i<span class="number">-1</span>] = rdiag[row+i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(ans, board, column, ldiag, rdiag, row+<span class="number">1</span>, n);</span><br><span class="line">        board[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        column[i] = ldiag[n-row+i<span class="number">-1</span>] = rdiag[row+i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索（breadth-first search，BFS）不同与深度优先搜索，它是一层层进行遍历的，因此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。</p><p>考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“广”的方向前进的策略，队列顶端的元素变化过程为 [1]-&gt;[2-&gt;3]-&gt;[4]，其中方括号代表每一层的元素。</p><p><img src="https://s2.loli.net/2022/08/04/HjNsDCer1JM5nI3.png" alt="示例" style="zoom:100%;" /></p><p>这里要注意，深度优先搜索和广度优先搜索都可以处理可达性问题，即从一个节点开始是否能达到另一个节点。</p><h3 id="最短的桥"><a href="#最短的桥" class="headerlink" title="最短的桥"></a><a href="https://leetcode.cn/problems/shortest-bridge/">最短的桥</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>在给定的二维二进制数组 A 中，存在两座岛（岛是由四面相连的 1 形成的一个最大组）现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。</p><p>返回必须翻转的 0 的最小数目（可以保证答案至少是 1）</p><p>示例 1：</p><blockquote><p>输入：A = [[0,1],[1,0]]<br>输出：1</p></blockquote><p>示例 2：</p><blockquote><p>输入：A = [[0,1,0],[0,0,0],[0,0,1]]<br>输出：2</p></blockquote><p>示例 3：</p><blockquote><p>输入：A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>本题实际上是求两个岛屿间的最短距离，因此我们可以先通过任意搜索方法找到其中一个岛屿，然后利用广度优先搜索，查找其与另一个岛屿的最短距离。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="type">bool</span> flipped = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//DFS找到第一个岛屿，标记为2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flipped) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(points, grid, m, n, i, j);</span><br><span class="line">                flipped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BFS，一层层向外扩展至找到第二个岛屿</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!points.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="comment">//n_points每减一，队列里就排除一个，减到0说明往外扩一层还没有找到，层数加一，继续扩</span></span><br><span class="line">        <span class="type">int</span> n_points = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (n_points--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = points.<span class="built_in">front</span>();</span><br><span class="line">            points.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                x = r + direction[k];</span><br><span class="line">                y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    points.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == m || j == n || grid[i][j] == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将边界一圈一个个压入队列</span></span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        points.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单词接龙II"><a href="#单词接龙II" class="headerlink" title="单词接龙II"></a><a href="https://leetcode.cn/problems/word-ladder-ii/">单词接龙II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的转换序列是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p><ul><li>每对相邻的单词之间仅有单个字母不同。</li><li>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</li><li>sk == endWord</li></ul><p>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的最短转换序列，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p><p>示例 1：</p><blockquote><p>输入：beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出：[[“hit”,”hot”,”dot”,”dog”,”cog”],[“hit”,”hot”,”lot”,”log”,”cog”]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出：[]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>双向BFS构建节点树，再用DFS找出所有通路。</p><p>我们可以把起始字符串、终止字符串、以及单词表里所有的字符串想象成节点。若两个字符串只有一个字符不同，那么它们相连。因为题目需要输出修改次数最少的所有修改方式，因此我们可以使用广度优先搜索，求得起始节点到终止节点的最短距离。</p><p>我们同时还使用了一个小技巧：我们并不是直接从起始节点进行广度优先搜索，直到找到终止节点为止；而是从起始节点和终止节点分别进行广度优先搜索，每次只延展当前层节点数最少的那一端，这样我们可以减少搜索的总结点数。</p><p>在搜索结束后，我们还需要通过回溯法来重建所有可能的路径。</p><p><img src="https://s2.loli.net/2022/08/04/YVpAd2MhqDryFEt.jpg" alt="搜索图示" style="zoom:67%;" /></p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, vector&lt;string&gt;&gt; tree;<span class="comment">//节点图，把所有符合只差一个字符的单词联系起来</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; ans;<span class="comment">//存储结果</span></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt; &amp; wordList) &#123;</span><br><span class="line">    <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(wordList.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="built_in">find</span>(wordList.<span class="built_in">begin</span>(), wordList.<span class="built_in">end</span>(), endWord) == wordList.<span class="built_in">end</span>()) </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//双向BFS</span></span><br><span class="line">    <span class="built_in">swap</span>(beginWord, endWord);<span class="comment">//这里交换是为了建立从尾到头的树</span></span><br><span class="line">    unordered_set&lt;string&gt; bfsFromBegin&#123;beginWord&#125;;<span class="comment">//从上到下BFS</span></span><br><span class="line">    unordered_set&lt;string&gt; bfsFromEnd&#123;endWord&#125;;<span class="comment">//从下到上</span></span><br><span class="line">    <span class="function">unordered_set&lt;string&gt; <span class="title">dirc</span><span class="params">(wordList.begin(), wordList.end())</span></span>;<span class="comment">//从单词目录中取出所有单词，用于标记是否搜索过</span></span><br><span class="line">    <span class="type">bool</span> findFlag = <span class="literal">false</span>, reverseFlag = <span class="literal">false</span>;<span class="comment">//上下是否相交，是否转换搜索方向</span></span><br><span class="line">    <span class="keyword">while</span>(!bfsFromBegin.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        unordered_set&lt;string&gt; next;<span class="comment">//存放下一层的搜索对象</span></span><br><span class="line">        <span class="keyword">for</span>(string s : bfsFromBegin)</span><br><span class="line">            dirc.<span class="built_in">erase</span>(s);<span class="comment">//擦除已经搜索过的</span></span><br><span class="line">        <span class="keyword">for</span>(string s1 : bfsFromBegin)&#123;</span><br><span class="line">            <span class="comment">//寻找只相差一个字符的单词</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                string s2 = s1;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)&#123;</span><br><span class="line">                    s2[i] = c;</span><br><span class="line">                    <span class="keyword">if</span>(dirc.<span class="built_in">count</span>(s2) == <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(bfsFromEnd.<span class="built_in">count</span>(s2))</span><br><span class="line">                        findFlag = <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                        next.<span class="built_in">insert</span>(s2);</span><br><span class="line">                    reverseFlag ? tree[s2].<span class="built_in">push_back</span>(s1) : tree[s1].<span class="built_in">push_back</span>(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfsFromBegin = next;</span><br><span class="line">        <span class="comment">//每次只搜索节点次数少的那端</span></span><br><span class="line">        <span class="keyword">if</span>(bfsFromBegin.<span class="built_in">size</span>() &gt; bfsFromEnd.<span class="built_in">size</span>())&#123;</span><br><span class="line">            reverseFlag = !reverseFlag;</span><br><span class="line">            <span class="built_in">swap</span>(bfsFromBegin, bfsFromEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(findFlag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS寻找所有通路</span></span><br><span class="line">    vector&lt;string&gt; cur = &#123;beginWord&#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(cur, beginWord, endWord);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; cur, string curWord, string endWord)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curWord == endWord)&#123;</span><br><span class="line">        <span class="comment">//搜索方向是反着的，要翻转</span></span><br><span class="line">        <span class="built_in">reverse</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">reverse</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(string s : tree[curWord])&#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">dfs</span>(cur, s, endWord);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：从前向后DFS会超时，所以从后向前DFS，面向数据编程了属于是（</p></blockquote>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a><a href="https://leetcode.cn/problems/surrounded-regions/">被围绕的区域</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个 m x n 的矩阵 board，由若干字符 ‘X’ 和 ‘O’，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例 1：</p><blockquote><p>输入：board =<br>[[“X”,”X”,”X”,”X”],<br>[“X”,”O”,”O”,”X”],<br>[“X”,”X”,”O”,”X”],<br>[“X”,”O”,”X”,”X”]]<br>输出：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：board = [[“X”]]<br>输出：[[“X”]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>主要问题在于如何判断是否是被包围的，可以dfs每一个边界元素，把与之相连的标记为 ‘A’，然后遍历矩阵赋值即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(board, x + <span class="number">1</span>, y);</span><br><span class="line">    <span class="built_in">dfs</span>(board, x - <span class="number">1</span>, y);</span><br><span class="line">    <span class="built_in">dfs</span>(board, x, y + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(board, x, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    n = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(board, i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(board, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">dfs</span>(board, n - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">二叉树的所有路径</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个二叉树的根节点 root，按任意顺序返回所有从根节点到叶子节点的路径。</p><p>叶子节点是指没有子节点的节点。</p><p>示例 1：</p><blockquote><p>输入：<img src="https://s2.loli.net/2022/08/04/4XAMDCpZckfrn1U.jpg" alt="示例" style="zoom:33%;" /></p><p>root = [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：root = [1]<br>输出：[“1”]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>DFS</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct_paths</span><span class="params">(TreeNode* root, string path, vector&lt;string&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            paths.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">construct_paths</span>(root-&gt;left, path, paths);</span><br><span class="line">            <span class="built_in">construct_paths</span>(root-&gt;right, path, paths);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; paths;</span><br><span class="line">    <span class="built_in">construct_paths</span>(root, <span class="string">&quot;&quot;</span>, paths);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a><a href="https://leetcode.cn/problems/permutations-ii/">全排列II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个可包含重复数字的序列 nums，按任意顺序返回所有不重复的全排列。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],[1,2,1],[2,1,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>重复的来源是相同数字的位置可交换，所以只需限制相同数字的相对位置为固定的即可，可以对数组排序，按照数组下标的相对位置。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, <span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//不能取的两种情况，一是取过了，二是相同数字但位置在前的还未被取</span></span><br><span class="line">        <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perm.<span class="built_in">emplace_back</span>(nums[i]);<span class="comment">//比push_back效率高</span></span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">        perm.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; perm;</span><br><span class="line">    vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个候选人编号的集合 candidates 和一个目标数 target，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。</p><p>注意：解集不能包含重复的组合。 </p><p>示例 1:</p><blockquote><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>输出:<br>[[1,1,6],[1,2,5],[1,7],[2,6]]</p></blockquote><p>示例 2:</p><blockquote><p>输入: candidates = [2,5,2,1,2], target = 5,<br>输出:<br>[[1,2,2],[5]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>带重复的回溯 = 排序 + 判断。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; target-candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//避免重复，只需要避免取的数和上一层回溯拿掉的数相等即可</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; index &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">解数独</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>编写一个程序，通过填充空格来解决数独问题。数独的解法需遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</li></ul><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p>示例 1：</p><blockquote><p>输入：<img src="https://s2.loli.net/2022/08/04/XJcAKxvzhyM7r4Z.png" alt="输入示例" style="zoom:50%;" /></p><p>输出：<img src="https://s2.loli.net/2022/08/04/5DTmrFq3nZOBHAk.png" alt="输出示例" style="zoom: 50%;" /></p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>类似 N 皇后，建立数组标记行、列和九宫格内的数字出现情况，然后回溯法填数字即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> line[<span class="number">10</span>][<span class="number">10</span>], column[<span class="number">10</span>][<span class="number">10</span>], block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="type">char</span> temp = board[i][j];</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!line[i][k] &amp;&amp; !column[j][k] &amp;&amp; !block[i/<span class="number">3</span>][j/<span class="number">3</span>][k]) &#123;</span><br><span class="line">                        board[i][j] = k + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        line[i][k] = <span class="literal">true</span>;</span><br><span class="line">                        column[j][k] = <span class="literal">true</span>;</span><br><span class="line">                        block[i / <span class="number">3</span>][j / <span class="number">3</span>][k] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board))</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        line[i][k] = <span class="literal">false</span>;</span><br><span class="line">                        column[j][k] = <span class="literal">false</span>;</span><br><span class="line">                        block[i / <span class="number">3</span>][j / <span class="number">3</span>][k] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(line, <span class="number">0</span>, <span class="built_in">sizeof</span>(line));</span><br><span class="line">    <span class="built_in">memset</span>(column, <span class="number">0</span>, <span class="built_in">sizeof</span>(column));</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="type">char</span> temp = board[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="string">&#x27;.&#x27;</span> - <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                line[i][temp] = <span class="literal">true</span>;</span><br><span class="line">                column[j][temp] = <span class="literal">true</span>;</span><br><span class="line">                block[i / <span class="number">3</span>][j / <span class="number">3</span>][temp] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(board);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a><a href="https://leetcode.cn/problems/minimum-height-trees/">最小高度树</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>树是一个无向图，其中任何两个顶点只通过一条路径连接。换句话说，一个任何没有简单环路的连通图都是一棵树。</p><p>给你一棵包含 n 个节点的树，标记为 0 到 n - 1。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。任意两节点只有一条路径。</p><p>可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h。在所有可能的树中，具有最小高度的树（即，min(h)）被称为最小高度树。</p><p>请你找到所有的最小高度树并按任意顺序返回它们的根节点标签列表。</p><p>树的高度是指根节点和叶子节点之间最长向下路径上边的数量。</p><p>示例 1：</p><blockquote><p>输入：n = 4, edges = [[1,0],[1,2],[1,3]]<br>输出：[1]</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]<br>输出：[3,4]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>暴力解法会超时，这里采用类似拓扑排序（好高级的名词doge)的方法。目标是找到与距离最远的叶节点的距离最小的根节点，如果把树按照最长路径给捋成一条链子，那么很显然应该选取根节点为链子中点的一个或两个节点，如何取到呢，可以BFS逐层删掉叶节点，最后剩下两个或一个时即为所求的根节点。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;   <span class="comment">//每个节点对应的度数</span></span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; m;  <span class="comment">//邻接表</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans; <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> v=edges[i][<span class="number">1</span>];</span><br><span class="line">        degree[u]++;</span><br><span class="line">        degree[v]++;</span><br><span class="line">        m[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        m[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//把叶子节点入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">1</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="comment">//从外向内一层一层剥</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n - k &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sz=q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            degree[t]--;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">//加入t的邻接叶子节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : m[t])&#123;</span><br><span class="line">                degree[j]--;</span><br><span class="line">                <span class="keyword">if</span> (degree[j] == <span class="number">1</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - k; i++) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> DFS,BFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/posts/735e5788/"/>
      <url>/posts/735e5788/</url>
      
        <content type="html"><![CDATA[<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><p>以下是一些最基本的排序算法。虽然在 C++ 里可以通过 std::sort() 快速排序，而且刷题时很少需要自己手写排序算法，但是熟习各种排序算法可以加深自己对算法的基本理解，以及解出由这些排序算法引申出来的题目。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>采用<strong>左闭右开</strong>的二分写法，代码模板如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//特殊情况，没有数或只有一个数，无需排序，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//取区间左端点值为排序对象，目标是比它大的都在右边，比它小的都在左边</span></span><br><span class="line">    <span class="type">int</span> first = l, last = r - <span class="number">1</span>, key = nums[first];</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">        <span class="comment">//寻找比key小的，往前调</span></span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; nums[last] &gt;= key)</span><br><span class="line">            last--;</span><br><span class="line">        nums[first] = nums[last];<span class="comment">//因为nums[first]的值在key中，不会丢失</span></span><br><span class="line">        <span class="comment">//比key大的，往后调</span></span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[first] &lt;= key)</span><br><span class="line">            first++;</span><br><span class="line">        nums[last] = nums[first];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[first] = key;<span class="comment">//key来到了属于它的位置</span></span><br><span class="line">    <span class="comment">//继续排左半区间和右半区间</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, l, first);</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, first + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序主要是采用分而治之的思想，将数组不断分解成多个小数组，然后从排序好的小数组中按大小挑出数填充结果数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//分解</span></span><br><span class="line"><span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line"><span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line">    <span class="comment">//归并原理</span></span><br><span class="line"><span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line">    <span class="comment">//分别从两个小数组开头开始，先挑小的放进结果数组</span></span><br><span class="line"><span class="keyword">while</span> (p &lt; m || q &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q]))</span><br><span class="line">            temp[i++] = nums[p++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[i++] = nums[q++];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//临时的数组赋回原数组</span></span><br><span class="line"><span class="keyword">for</span> (i = l; i &lt; r; i++)</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>先排好小的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j<span class="number">-1</span>]; j--)</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>先排好大的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j+<span class="number">1</span>])</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选定第一个元素为最小元，然后向后比较找真正的最小元，与之交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[min], nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><h3 id="数组中第-k-大的元素"><a href="#数组中第-k-大的元素" class="headerlink" title="数组中第 k 大的元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">数组中第 k 大的元素</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定整数数组 nums 和整数 k，请返回数组中第 k 大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><blockquote><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>快速选择一般用于求解 k-th Element 问题，可以在 O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。快速选择的实现和快速排序相似，首先选定数组第一个值为基准值，将小于它的放在左边，大于它的放在右边，然后根据情况判断继续搜索左区间还是右区间。</p><p><img src="https://s2.loli.net/2022/08/22/VX5flsY1HrxBo8T.jpg" alt="解释手稿" style="zoom: 25%;" /></p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">quickSelection</span>(nums, l, r);</span><br><span class="line">        <span class="keyword">if</span> (mid == target)</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; target)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数 - 快速选择，目标是把数组按大小切成两半，返回的是分界点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r &amp;&amp; nums[i] &lt;= nums[l])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; j &amp;&amp; nums[j] &gt;= nums[l])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="前-k-个高频元素"><a href="#前-k-个高频元素" class="headerlink" title="前 k 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 k 个高频元素</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。</p><p>示例 1:</p><blockquote><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [1], k = 1<br>输出: [1]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属性），然后对桶进行排序。针对样例1来说，我们先通过桶排序得到四个桶 [1,2,3,4]，它们的值分别为 [4,2,1,1]，表示每个数字出现的次数。</p><p>紧接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种<br>排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说，因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [[3,4],[2],[],[1]]，表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num : nums) &#123;</span><br><span class="line">        counts[num]++;</span><br><span class="line">        max_count = <span class="built_in">max</span>(max_count, counts[num]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(max_count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; p : counts)</span><br><span class="line">        buckets[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max_count; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num : buckets[i])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="根据字符出现频率排序"><a href="#根据字符出现频率排序" class="headerlink" title="根据字符出现频率排序"></a><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">根据字符出现频率排序</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个字符串 s，根据字符出现的频率对其进行降序排序。一个字符出现的频率是它出现在字符串中的次数。</p><p>返回已排序的字符串。如果有多个答案，返回其中任何一个。</p><p>示例 1:</p><blockquote><p>输入: s = “tree”<br>输出: “eert”</p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “cccaaa”<br>输出: “cccaaa”</p></blockquote><p>示例 3:</p><blockquote><p>输入: s = “Aabb”<br>输出: “bbAa”</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>即桶排序。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; a : s) &#123;</span><br><span class="line">        counts[a]++;</span><br><span class="line">        max_count = <span class="built_in">max</span>(max_count, counts[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">buckets</span>(max_count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; p : counts)</span><br><span class="line">        buckets[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max_count; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; a : buckets[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">                ans.<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个包含红色、白色和蓝色共 n 个元素的数组 nums，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p>示例 1：</p><blockquote><p>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,0,1]<br>输出：[0,1,2]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>桶排序。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num : nums)</span><br><span class="line">        counts[num]++;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; counts[<span class="number">0</span>]; i++)</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; counts[<span class="number">1</span>] + counts[<span class="number">0</span>]; i++)</span><br><span class="line">        nums[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; counts[<span class="number">2</span>] + counts[<span class="number">1</span>] + counts[<span class="number">0</span>]; i++)</span><br><span class="line">        nums[i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/e8eb0481/"/>
      <url>/posts/e8eb0481/</url>
      
        <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为 O(n) 的数组，二分查找的时间复杂度为 O(log n)。二分查找适用对象必须是排好序的数组。</p><p>具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此有些初学者会容易搞不清楚如何定义区间开闭性。这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在做题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。</p><p>二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。</p><h2 id="求开方"><a href="#求开方" class="headerlink" title="求开方"></a>求开方</h2><h3 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a><a href="https://leetcode.cn/problems/sqrtx/">x 的平方根</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个非负整数 x，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5。</p><p>示例 1：</p><blockquote><p>输入：x = 4<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：x = 8<br>输出：2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>在 [0, x] 区间二分查找。另外还有一个更快的牛顿迭代法 $x_{n+1}=x_n-\frac{f(x_n)}{f^{‘}(x_n)}$</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <p>二分查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = a, mid, sqrt;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        sqrt = a / mid;</span><br><span class="line">        <span class="keyword">if</span> (sqrt == mid) </span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; sqrt)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>牛顿迭代法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="type">long</span> x = a;</span><br><span class="line"><span class="keyword">while</span> (x * x &gt; a)</span><br><span class="line">x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="查找区间"><a href="#查找区间" class="headerlink" title="查找区间"></a>查找区间</h2><h3 id="查找元素始末位置"><a href="#查找元素始末位置" class="headerlink" title="查找元素始末位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">查找元素始末位置</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p>示例 1：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [], target = 0<br>输出：[-1,-1]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>二分查找定位到目标值后向前向后扩大区间即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> mid, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = mid, r = mid;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; nums[l] == target) </span><br><span class="line">        l--;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[r] == target)</span><br><span class="line">        r++;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l+<span class="number">1</span>, r<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">range</span>(nums, mid, target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后（寻找上下边界也使用二分查找）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> lower = <span class="built_in">lower_bound</span>(nums, target);</span><br><span class="line">    <span class="type">int</span> upper = <span class="built_in">upper_bound</span>(nums, target) - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (lower == nums.<span class="built_in">size</span>() || nums[lower] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;lower, upper&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            r = mid; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="旋转数组查找数字"><a href="#旋转数组查找数字" class="headerlink" title="旋转数组查找数字"></a>旋转数组查找数字</h2><h3 id="搜索旋转排序数组II"><a href="#搜索旋转排序数组II" class="headerlink" title="搜索旋转排序数组II"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>已知存在一个按非降序排列的整数数组 nums，数组中的值不必互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了旋转，使数组变为了[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如，[0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4]。</p><p>给你旋转后的数组 nums 和一个整数 target，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target，则返回 true，否则返回 false。</p><p>你必须尽可能减少整个操作步骤。</p><p>示例 1：</p><blockquote><p>输入：nums = [2,5,6,0,0,1,2], target = 0<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,5,6,0,0,1,2], target = 3<br>输出：false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>其实数组即使被旋转过一次，也并不影响二分查找的使用，如果中点值小于右端点，则右半区间为排好序的；若中点值等于右端点，不能确定，尝试右端点左移重新取中点；若中点值大于右端点，则左半区间为排好序的。继续二分查找即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[r]) </span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[r])</span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt;= nums[mid])</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="寻找旋转排序数组的最小值II"><a href="#寻找旋转排序数组的最小值II" class="headerlink" title="寻找旋转排序数组的最小值II"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组的最小值II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次旋转后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p><ul><li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]</li><li>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]</li></ul><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]]。</p><p>给你一个可能存在重复元素值的数组 nums，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素。</p><p>你必须尽可能减少整个过程的操作步骤。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,3,5]<br>输出：1</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,2,2,0,1]<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>别看题目旋转多少次，实际上是上一题的不同表述，同样是一直二分查找至最小值。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[r])</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[r]) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="有序数组中的单一元素"><a href="#有序数组中的单一元素" class="headerlink" title="有序数组中的单一元素"></a><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/">有序数组中的单一元素</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。请你找出并返回只出现一次的那个数。</p><p>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p><p>示例 1:</p><blockquote><p>输入: nums = [1,1,2,3,3,4,4,8,8]<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums =  [3,3,7,7,10,11,11]<br>输出: 10</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                r = mid - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">                l = mid + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p><p>算法的时间复杂度应该为 O(log (m+n))。</p><p>示例 1：</p><blockquote><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1。</p><p>假设两个有序数组分别是 A 和 B。要找到第 k 个元素，我们可以比较 A[k/2-1] 和 B[k/2-1]，有三种情况：</p><ul><li>A[k/2-1] &lt; B[k/2-1]，则可以排除 A[0]~A[k/2-1]</li><li>A[k/2-1] &gt; B[k/2-1]，同理</li><li>A[k/2-1] = B[k/2-1]，可以合并进 1 中</li></ul><p>有以下三种情况需要特殊处理：</p><ul><li>如果 A[k/2-1] 或者 B[k/2-1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k/2。</li><li>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k小的元素。</li><li>如果 k=1，我们只要返回两个数组首元素的最小值即可。</li></ul><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == m)</span><br><span class="line">            <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (index2 == n)</span><br><span class="line">            <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">        <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">        <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">        <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">            k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">            index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">            index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/posts/91a7e4d1/"/>
      <url>/posts/91a7e4d1/</url>
      
        <content type="html"><![CDATA[<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。</p><p>若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。</p><p>若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。</p><p>对于 C++ 语言，指针还可以玩出很多新的花样。一些常见的关于指针的操作如下：</p><h3 id="指针与常量"><a href="#指针与常量" class="headerlink" title="指针与常量"></a>指针与常量</h3><blockquote><p>int x;<br>int *p1 = &x; // 指针可以被修改，值也可以被修改<br>const int *p2 = &x; // 指针可以被修改，值不可以被修改（const int）<br>int *const p3 = &x; // 指针不可以被修改（*const），值可以被修改<br>const int *const p4 = &x; // 指针不可以被修改，值也不可以被修改</p></blockquote><h3 id="指针函数与函数指针"><a href="#指针函数与函数指针" class="headerlink" title="指针函数与函数指针"></a>指针函数与函数指针</h3><blockquote><p>// addition是指针函数，一个返回类型是指针的函数<br>int* addition(int a, int b) {<br>    int *sum = new int(a + b);<br>    return sum;<br>}<br>int subtraction(int a, int b) {<br>    return a - b;<br>}<br>int operation(int x, int y, int (*func)(int, int)) {<br>    return (*func)(x,y);<br>}</p><p>// minus是函数指针，指向函数的指针<br>int (*minus)(int, int) = subtraction;<br>int *m = addition(1, 2);<br>int n = operation(3, *m, minus);</p></blockquote><h2 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h2><h3 id="两数之和II"><a href="#两数之和II" class="headerlink" title="两数之和II"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个下标从 1 开始的整数数组 numbers，该数组已按非递减顺序排列，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2]，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length。</p><p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和index2。</p><p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。</p><p>示例 1：</p><blockquote><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]</p></blockquote><p>示例 2：</p><blockquote><p>输入：numbers = [2,3,4], target = 6<br>输出：[1,3]</p></blockquote><p>示例 3：</p><blockquote><p>输入：numbers = [-1,0], target = -1<br>输出：[1,2]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>采用方向相反的双指针遍历数组，因为已经排好序，所以如果两个数之和小于目标值，则左指针右移，若大于目标值，则右指针左移。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = numbers.<span class="built_in">size</span>() - <span class="number">1</span>, sum;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        sum = numbers[l] + numbers[r];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) </span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="归并有序数组"><a href="#归并有序数组" class="headerlink" title="归并有序数组"></a>归并有序数组</h2><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">合并两个有序数组</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n，分别表示nums1 和 nums2 中的元素数目。</p><p>请你合并 nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0，应忽略。nums2 的长度为 n。</p><p>示例 1：</p><blockquote><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br>输出：[1]<br>注意：因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即 nums1 的 m−1 位和 nums2 的 n−1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。<br>因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针 pos，以便复制。</p><blockquote><p>注意：如果 nums1 的数字已经复制完，不要忘记把 nums2 的数字继续复制；如果 nums2 的数字已经复制完，剩余 nums1 的数字不需要改变，因为它们已经被排好序。</p></blockquote><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[pos--] = nums1[m]&gt;nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[pos--] = nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>链表定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不允许修改链表。</p><p>示例：</p><blockquote><p>输入：<img src="https://s2.loli.net/2022/08/04/oYFjXthiG5B62pS.png" alt="示例" style="zoom:33%;" /><br>head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>对于链表找环路的问题，有一个通用的解法——<strong>快慢指针</strong>（Floyd 判圈法）。给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路；如果 fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fast || !fast-&gt;next) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个字符串 s、一个字符串 t。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “”。s,t只由英文字母组成。</p><blockquote><p>注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><p>示例 1：</p><blockquote><p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “a”, t = “a”<br>输出：”a”</p></blockquote><p>示例 3:</p><blockquote><p>输入: s = “a”, t = “aa”<br>输出: “”</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>本题使用滑动窗口求解，即两个指针 l 和 r 都是从最左端向最右端移动，且 l 的位置一定在 r 的左边或重合。先统计 t 中字符数量，滑动窗口至包含所有字符，l 左移，得到最短子串。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> t : T) &#123;</span><br><span class="line">        flag[t] = <span class="literal">true</span>;</span><br><span class="line">        chars[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, min_l = <span class="number">0</span>, min_size = S.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; S.<span class="built_in">size</span>(); r++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[S[r]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--chars[S[r]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt == T.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l - <span class="number">1</span> &lt; min_size) &#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag[S[l]] &amp;&amp; ++chars[S[l]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_size&gt;S.<span class="built_in">size</span>() ? <span class="string">&quot;&quot;</span> : S.<span class="built_in">substr</span>(min_l, min_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="平方数之和"><a href="#平方数之和" class="headerlink" title="平方数之和"></a><a href="https://leetcode.cn/problems/sum-of-square-numbers/">平方数之和</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2^ + b^2^ = c 。</p><p>示例 1：</p><blockquote><p>输入：c = 5<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：c = 3<br>输出：false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>双指针，一个指向0，另一个指向根号c取整，左指针向右移或者右指针向左移，就可以避免双重循环解决问题。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> l = <span class="number">0</span>, r = <span class="built_in">sqrt</span>(c) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        ans = l * l + r * r;</span><br><span class="line">        <span class="keyword">if</span> (ans == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; c)</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="验证回文字符串II"><a href="#验证回文字符串II" class="headerlink" title="验证回文字符串II"></a><a href="https://leetcode.cn/problems/valid-palindrome-ii/">验证回文字符串II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p>示例 1:</p><blockquote><p>输入: s = “aba”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “abca”<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: s = “abc”<br>输出: false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>双指针，一个在开头，一个在末尾，相向移动，不符合的字符记录下来即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> low , <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = low, j = high; i &lt; j; i++,j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[j]) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[l] == s[r]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">checkPalindrome</span>(s, l+<span class="number">1</span>, r) || <span class="built_in">checkPalindrome</span>(s, l, r<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="删除字母匹配字符串"><a href="#删除字母匹配字符串" class="headerlink" title="删除字母匹配字符串"></a><a href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/">删除字母匹配字符串</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个字符串 s 和一个字符串数组 dictionary，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。均只由小写英文字母组成。</p><p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例 1：</p><blockquote><p>输入：s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>输出：”apple”</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “abpcplea”, dictionary = [“a”,”b”,”c”]<br>输出：”a”</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>双指针，一个用于遍历 s，另一个遍历 d 中的字符串，记录满足题目要求的字符串即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">    string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (string d : dictionary) &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &lt; d.<span class="built_in">size</span>() </span><br><span class="line">            || (ans.<span class="built_in">size</span>() == d.<span class="built_in">size</span>() &amp;&amp; ans.<span class="built_in">compare</span>(d) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (m &lt; s.<span class="built_in">size</span>() &amp;&amp; n &lt; d.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[m] == d[n]) </span><br><span class="line">                    n++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n == d.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ans = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="至多包含-k-个不同字符的最长子串"><a href="#至多包含-k-个不同字符的最长子串" class="headerlink" title="至多包含 k 个不同字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/">至多包含 k 个不同字符的最长子串</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个字符串 s，找出至多包含 k 个不同字符的最长子串 T 的长度。</p><p>示例 1：</p><blockquote><p>输入：s = “eceba”, k = 2<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “aa”, k = 1<br>输出：2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>滑动窗口。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &lt;= k)</span><br><span class="line">            m[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(m.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--m[s[j]] == <span class="number">0</span>)</span><br><span class="line">                m.<span class="built_in">erase</span>(s[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为这题是付费的，所以我并不确定是否完全AC，仅供参考</p></blockquote>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/posts/a4ce31d2/"/>
      <url>/posts/a4ce31d2/</url>
      
        <content type="html"><![CDATA[<h2 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h2><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a></h3><div class="tabs" id="leetcode455"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode455-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode455-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode455-1"><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><blockquote><p>输入: g = [1,2,3], s = [1,1]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: g = [1,2], s = [1,2,3]<br>输出: 2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode455-2"><p>两种角度，一，从小孩角度，先满足胃口小的，把大于且最接近的饼干分配给他；二，从饼干角度，先分配分量大的饼干给胃口小于且最接近的孩子。将两数组分别排序，遍历比较即可实现。</p><blockquote><p>思考：为什么小孩要先满足胃口小的，饼干要先分配大的？试一试。</p></blockquote><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <p>角度一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; children, vector&lt;<span class="type">int</span>&gt;&amp; cookies)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(cookies.<span class="built_in">begin</span>(), cookies.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; children.<span class="built_in">size</span>() &amp;&amp; cookie &lt; cookies.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (children[child] &lt;= cookies[cookie])</span><br><span class="line">            child++;</span><br><span class="line">        cookie++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角度二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; children, vector&lt;<span class="type">int</span>&gt;&amp; cookies)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">sort</span>(cookies.<span class="built_in">begin</span>(), cookies.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; children.<span class="built_in">size</span>() &amp;&amp; cookie &lt; cookies.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cookies[cookie] &gt;= children[child]) </span><br><span class="line">            cookie++;</span><br><span class="line">        child++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode.cn/problems/candy/">分发糖果</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li><li>请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。</li></ul><p>示例 1：</p><blockquote><p>输入：ratings = [1,0,2]<br>输出：5</p></blockquote><p>示例 2：</p><blockquote><p>输入：ratings = [1,2,2]<br>输出：4</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>首先每个孩子分一个，再从左往右遍历一遍，保证每个孩子相对右边相邻孩子糖果数是正确的，再从右向左遍历一遍，保证每个孩子相对左边相邻孩子糖果数正确，最后求和即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = ratings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>])</span><br><span class="line">            num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &lt; ratings[i<span class="number">-1</span>] &amp;&amp; num[i<span class="number">-1</span>] &lt;= num[i])</span><br><span class="line">            num[i<span class="number">-1</span>] = num[i] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给定一个区间的集合 intervals，其中 intervals[i] = [starti, endi]。返回需要移除区间的最小数量，使剩余区间互不重叠。</p><p>示例 1:</p><blockquote><p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: intervals = [ [1,2], [1,2], [1,2] ]<br>输出: 2</p></blockquote><p>示例 3:</p><blockquote><p>输入: intervals = [ [1,2], [2,3] ]<br>输出: 0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>又是一个排序题目，两个角度：一，将区间右端升序排列，从左向右，优先保留右端较小且不重叠的区间；二，将区间左端降序排列，从左向右，优先保留左端较大且不重叠的区间。</p><p>如下图所示：</p><p><img src="https://s2.loli.net/2022/08/04/73un2QPUvOzLmGC.png" alt="区间问题图示" style="zoom: 50%;" /></p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <p>角度一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;);</span><br><span class="line">    <span class="type">int</span> removed = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) &#123;</span><br><span class="line">            removed++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角度二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];&#125;);</span><br><span class="line">    <span class="type">int</span> removed = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; prev) &#123;</span><br><span class="line">            removed++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = intervals[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a><a href="https://leetcode.cn/problems/can-place-flowers/">种花问题</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p><p>示例 1：</p><blockquote><p>输入：flowerbed = [1,0,0,0,1], n = 1<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：flowerbed = [1,0,0,0,1], n = 2<br>输出：false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>问题可以简化为一个基本模型，两端有花，中间空缺，更复杂的情况可以通过切割得到多个简单情况，且互相独立。又因为基本模型中两端的花地位相同，所以直接从左向右遍历，能种则种，即可得到全局最优。</p><p>这里提供另一个想法，虽然与贪心算法无关，但很巧妙，把花坛两端加上0，就可以将两端的特殊情况化为一般，只要有连续的3片空地就能种一朵花。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; flowerbed.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span> </span><br><span class="line">            &amp;&amp; (i == <span class="number">0</span> || flowerbed[i<span class="number">-1</span>] == <span class="number">0</span>) </span><br><span class="line">            &amp;&amp; (i == flowerbed.<span class="built_in">size</span>() - <span class="number">1</span> || flowerbed[i+<span class="number">1</span>] == <span class="number">0</span>)) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里用了 || 符号的短路性，判断过程不会越界</p></blockquote>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend 之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1：</p><blockquote><p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：points = [[1,2],[3,4],[5,6],[7,8]]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：points = [[1,2],[2,3],[3,4],[4,5]]<br>输出：2</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>这题和上面的无重叠区间很相像，本题要求最少的箭头数量，能一块扎爆的是有重叠区间的，所以在一些重叠的区间中留下一个就行，其他的移除，和例题本质上是一样的，目标都是把一组互不重叠的区间全部找出来，稍微修改一下例题的代码即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), </span><br><span class="line">         [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;);</span><br><span class="line">    <span class="type">int</span> removed = <span class="number">0</span>, prev = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= prev) &#123;</span><br><span class="line">            removed++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> points.<span class="built_in">size</span>() - removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：本题中区间边界重合也算重合</p></blockquote>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">划分字母区间</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><blockquote><p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>这题依然可以转化为区间问题，两次遍历得到每个字母的始末位置，然后合并区间即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        last[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last[s[i] - <span class="string">&#x27;a&#x27;</span>] &gt; end)</span><br><span class="line">            end = last[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (end == i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买或出售股票。你在任何时候最多只能持有一股股票。你也可先购买，然后在同一天出售。返回你能获得的最大利润。</p><p>示例 1：</p><blockquote><p>输入：prices = [7,1,5,3,6,4]<br>输出：7</p></blockquote><p>示例 2：</p><blockquote><p>输入：prices = [1,2,3,4,5]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：prices = [7,6,4,3,1]<br>输出：0</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>题目只要求最大利润，所以直接贪心计算差价即可。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>])</span><br><span class="line">            ans += (prices[i+<span class="number">1</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="*根据身高重建队列"></a>*<a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><blockquote><p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>先排序，身高降序排列，然后 k 升序，先将最高的按 k 值升序放入队列中，然后插入个子矮的，也是按 k 值插入即可，不会影响前面已经插入好的。</p><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : people) &#123;</span><br><span class="line">        ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>() + n[<span class="number">1</span>], n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; people.size(); i++)&#123;  </span></span><br><span class="line">    <span class="comment">//res.insert(res.begin()+people[i][1], people[i]);</span></span><br><span class="line">    <span class="comment">//&#125;与上面等价</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="非递减数列"><a href="#非递减数列" class="headerlink" title="非递减数列"></a><a href="https://leetcode.cn/problems/non-decreasing-array/">非递减数列</a></h3><div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#leetcode-1"><i class="fas fa-book"></i>题面</button></li><li class="tab"><button type="button" data-href="#leetcode-2"><i class="fas fa-key"></i>题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="leetcode-1"><p>给你一个长度为 n 的整数数组 nums，请你判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的：对于数组中任意的 i (0&lt;=i&lt;=n-2)，总满足 nums[i] &lt;= nums[i + 1]。</p><p>示例 1:</p><blockquote><p>输入: nums = [4,2,3]<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [4,2,1]<br>输出: false</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="leetcode-2"><p>只要求出最少修改次数，然后与 1 比较即可，对于不符合条件的两个相邻的数，有两种方案，一，修改前面一个，二，修改后面一个，具体采用哪种方案要看修改后是否会影响前面已经符合的部分，比较这两个数的前面一个数和这两个数中后面一个数的大小即可做出判断。</p><blockquote><p>注：应修改至恰好满足，即不符合的变成相等的，这样对其他部分影响小，修改次数也最少</p></blockquote><details class="folding-tag" blue><summary> 代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPossibility</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i+<span class="number">1</span>] &gt;= nums[i<span class="number">-1</span>])</span><br><span class="line">                nums[i] = nums[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i+<span class="number">1</span>] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> c++ </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论如何优雅地写博客</title>
      <link href="/posts/a5649831/"/>
      <url>/posts/a5649831/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花费了零零碎碎将近三天来搭建并美化个人博客网站，不好好写东西都对不起自己😉，本篇介绍如何优雅地写博客，主要内容分为三部分，一是如何发布博客，二是如何优雅地使用latex公式，三是如何优雅地插入图片。</p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><blockquote><p>问：如何发布博客？</p><p>答：将要上传的 md 文档放入/source/_posts中，素质三连 <code>git clean</code>,<code>git g</code>,<code>git d</code> 即可</p></blockquote><p>要上传的 md 文档前面的 front-matter 部分写上 title，categories，tags 等文章信息，具体可以写哪些信息详见上一篇。</p><p>进入源码模式，格式如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 论如何优雅地写博客</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> 使用技巧</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">-</span> Typora</span><br><span class="line"><span class="bullet">-</span> PicGo</span><br><span class="line"><span class="bullet">-</span> SM.MS图床</span><br><span class="line"><span class="bullet">-</span> hexo</span><br><span class="line"><span class="section">- 写博客</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="latex公式"><a href="#latex公式" class="headerlink" title="latex公式"></a>latex公式</h2><p>众所周知，Typora 以其出色的即时预览功能和对 latex 公式的支持广受欢迎，虽然现在付费了，但还是可以想办法白嫖的，<a href="https://github.com/liano3/typora_theme">方法在这</a>，里面还附赠了一套来自 op 的精美主题。</p><p>但是，当我将用 Typora 写的文档放入博客中时，问题出现了！里面的 latex 公式都寄了！下面讲解解决方法：</p><h3 id="更换插件"><a href="#更换插件" class="headerlink" title="更换插件"></a>更换插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><h3 id="更改插件文件"><a href="#更改插件文件" class="headerlink" title="更改插件文件"></a>更改插件文件</h3><p>进入项目更目录下：<code>node_modules\kramed\lib\rules\inline.js</code></p><p>修改这么两行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="attr">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span></span><br><span class="line">+ <span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span></span><br><span class="line">- <span class="attr">em</span>: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span></span><br><span class="line">+ <span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span></span><br></pre></td></tr></table></figure><p>分别在第 11 行和 20 行左右，减号后面是删掉的内容，加号后面是要加上的内容</p><h3 id="配置主题文件"><a href="#配置主题文件" class="headerlink" title="配置主题文件"></a>配置主题文件</h3><p>_config.butterfly.yml 中更改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="更改部分语法"><a href="#更改部分语法" class="headerlink" title="更改部分语法"></a>更改部分语法</h3><p>如果上述操作全部完成，还是不能成功，看看有没有语法问题。</p><p>比如，如果在公式内连续使用两个花括号，必须加上空格。</p><p>如下面的会渲染失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L_p  = (\sum_&#123;i=1&#125;^m |x_i - y_i |^&#123;p&#125;  )^&#123;&#123;\tfrac&#123;1&#125;&#123;p&#125;&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>在连续的花括号之间加上空格即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L_p  = (\sum_&#123;i=1&#125;^m |x_i - y_i |^&#123;p&#125;  )^&#123; &#123;\tfrac&#123;1&#125; &#123;p&#125; &#125; &#125;$$</span><br></pre></td></tr></table></figure><h2 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h2><div class="note warning flat"><p>注意：大概在8月底时，通过picgo.app端已无法上传，推测是被墙了（哭~~刚搞好没用多久就被墙了，部署在vercel上的twikoo也被墙了，我真倒霉😭），因此，请直接在线手动上传。</p></div><p>个人博客不能没有图床，就像西方不能没有耶路撒冷🤣，总之一个图床工具还是非常有用的，首先是无论是 github pages 还是 gitee pages 都是有 1G 的容量限制的，图片传多了就寄了。另外，图床可以实现跨平台跨设备使用同一张图片，分享或上传 md 文档再也不用连带着图片文件夹压缩了。</p><p>本着白嫖精神，并考虑到 github 访问速度慢，gitee 禁止外链，我选择 SM.MS 图床配合 PicGo 工具。SM.MS图床免费用户有 5G 容量（再多点就好了😊)，访问速度还可以。下面介绍如何配置：</p><h3 id="下载PicGo"><a href="#下载PicGo" class="headerlink" title="下载PicGo"></a>下载PicGo</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">网址在这</a>，向下翻，下载 2.3.0 版本，如下图：</p><p><img src="https://s2.loli.net/2022/08/14/7vVblZ2Ijcp5mxO.png" alt="下载picgo" style="zoom: 67%;" /></p><p>下载完成后双击即可安装。</p><h3 id="配置SM-MS"><a href="#配置SM-MS" class="headerlink" title="配置SM.MS"></a>配置SM.MS</h3><p><a href="https://smms.app/">网址在这</a>，注册登录后点击菜单栏的 user -&gt; DashBoard</p><p><img src="https://s2.loli.net/2022/08/14/9x3IEp8Cf1P2biz.png" alt="配置smms" style="zoom:67%;" /></p><p>点击 API Token，复制 Secret Token 的内容，如果为空就点击下面的 Generate</p><p><img src="https://s2.loli.net/2022/08/14/olSEtRNqg6aXhbw.png" alt="获取key" style="zoom:67%;" /></p><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p>打开 PicGo，配置 token，即把刚才复制的内容放进来</p><blockquote><p>注意：PicGo 双击打开可能没反应，实际在任务栏可以看到</p></blockquote><p><img src="https://s2.loli.net/2022/08/14/f2vbSonTrl4JAGt.png" alt="使用key" style="zoom:67%;" /></p><h3 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h3><p>文件 -&gt; 偏好设置 -&gt; 图像，配置如下：</p><p><img src="https://s2.loli.net/2022/08/14/LZhqWcoHMm3iABl.png" alt="配置typora" style="zoom:67%;" /></p><p>重启 Typora，即可优雅地写博客。</p><blockquote><p>注意：最后的验证可能不成功，重启之后新建一个 md 文档试试，如果能上传，就不用管</p></blockquote><p>另外，推荐一个截图工具 snipaste，超级好用！</p><hr><p>优雅的分割线😎 我来更新啦！</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="公式换行"><a href="#公式换行" class="headerlink" title="公式换行"></a>公式换行</h3><p>如果要写多行公式，需要以\\begin{cases},\\end{cases}或者\\begin{align},\\end{align}包裹，否则换行失效。</p><p>例如：</p><p>换行无效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">a=b+c \\</span><br><span class="line">b=c+d</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">a=b+c \\b=c+d</script><p>换行成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">a=b+c \\</span><br><span class="line">b=c+d</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{align}a=b+c \\b=c+d\end{align}</script><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>现有渲染器kramed不支持上下标，可以考虑替换为markdown-it，但这个插件对mathjax的支持不太好，暂时我没找到鱼和熊掌兼得的办法，所以，以后写文章上下标尽量在公式中使用吧</p><h3 id="公式大小"><a href="#公式大小" class="headerlink" title="公式大小"></a>公式大小</h3><p>在根目录中搜索mathjax.pug文件，应该有两个，改代码中scale的值即可</p><h3 id="行距"><a href="#行距" class="headerlink" title="行距"></a>行距</h3><p>插入行内公式后文本行距变窄，暂时没找到方法解决，逼死本强迫症了🤬，有解决办法的大佬请评论告诉我😣</p><hr><p>优雅地分割线，我又来啦！</p><p>找到了一个退而求其次的解决方法，把没有行内公式的正常行距变小，和有公式的保持一致。</p><p>在<code>Blog\themes\butterfly\source\css</code>中新建一个css文件，名称随意，我这里记作mycss.css，写入如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#article-container &#123;</span></span><br><span class="line">line-height: <span class="number">150</span>%<span class="comment">//在我的测试中，150%比较接近，自行调节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主题配置文件_config.butterfly.yml中引入刚刚新建的css文件，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject the css and script (aplayer/meting)</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/mycss.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br></pre></td></tr></table></figure><p>注意别搞错了位置，根据注释可以锁定到正确位置。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> Typora </tag>
            
            <tag> PicGo </tag>
            
            <tag> SM.MS图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客（三）主题配置</title>
      <link href="/posts/476e1d48/"/>
      <url>/posts/476e1d48/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有一个自己的博客还不够优雅，搭配上一个酷炫的主题才能更优雅地书写，本文以 butterfly主题为基础，谈谈博客界面的美化与功能细节的添加</p><h2 id="应用butterfly主题"><a href="#应用butterfly主题" class="headerlink" title="应用butterfly主题"></a>应用butterfly主题</h2><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>在hexo根目录里打开gitbash，输入如下命令：</p><p><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></p><p>成功后如图所示：</p><p><img src="https://s2.loli.net/2022/08/14/8vnQBeaSTY1FKD7.png" alt="安装主题" style="zoom:67%;" /></p><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>然后进入根目录里的_config.yml文件，将主题改为butterfly:</p><p><img src="https://s2.loli.net/2022/08/14/p2FHgXciI1qaeBk.png" alt="使用主题" style="zoom:67%;" /></p><p>更改字体为中文：</p><p><img src="https://s2.loli.net/2022/09/05/NBlIdCpiSOWg4Ry.png" alt="Snipaste_2022-09-05_12-32-27.png" style="zoom: 67%;" /></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p><p><img src="https://s2.loli.net/2022/08/14/GqsVtvJZd9RXhkb.png" alt="安装插件" style="zoom:67%;" /></p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>在根目录创建一个名为 <code>_config.butterfly.yml</code> 的文件，将<strong>butterfly主题目录里的</strong>文件_config.yml内容复制到新建的文件中，以后更改配置时在新建的这个文件里更改，因为解析时新建的这个文件优先级高，这样既可以有效修改配置，又避免升级主题时数据丢失。</p><p><img src="https://s2.loli.net/2022/08/14/i2BdMIhmT9F7gQq.png" style="zoom:67%;" /></p><p>注意：原来的文件不要删除</p><h2 id="网页功能配置"><a href="#网页功能配置" class="headerlink" title="网页功能配置"></a>网页功能配置</h2><h3 id="front-matter"><a href="#front-matter" class="headerlink" title="front-matter"></a>front-matter</h3><p>首先介绍一下 front-matter，顾名思义，是在md文档中最前面，以—-为分界线，用于指定参数或变量的部分</p><h4 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h4><p>相关参数如下表：</p><div class="table-container"><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>[必需]页面标题</td></tr><tr><td>date</td><td>[必需]页面创建日期</td></tr><tr><td>type</td><td>[必需]标签、分类和友链三个页面需要</td></tr><tr><td>updated</td><td>页面更新日期</td></tr><tr><td>comments</td><td>显示评论模块</td></tr><tr><td>top_img</td><td>页面顶部图片</td></tr><tr><td>mathjax</td><td>per_page:false时才需要配置</td></tr></tbody></table></div><h4 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h4><div class="table-container"><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>[必需]文章标题</td></tr><tr><td>date</td><td>[必需]创建日期</td></tr><tr><td>updated</td><td>更新日期</td></tr><tr><td>tags</td><td>标签</td></tr><tr><td>categories</td><td>文章分类</td></tr><tr><td>cover</td><td>文章缩略图</td></tr><tr><td>mathjax</td><td>per_page:false时才需要配置</td></tr></tbody></table></div><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>首先进入主题配置文件_config.butterfly.yml，更改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#菜单栏</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br></pre></td></tr></table></figure><p>根据自己情况，还可以再加，我只创建了这几个页面。</p><p>然后前往你的 Hexo 博客的根目录，输入 <code>hexo new page tags</code>，你会找到source/tags/index.md这个文件，修改这个文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-08-11 19:27:10</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">/img/page.png</span>  <span class="comment">#自己根据你想设置的图片的位置修改</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>分类页操作步骤同上，把命令改为 <code>hexo new page categories</code> 即可</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2><p>东西太多了，写不下去了，关于主题方面的配置，官方文档里写的比我清晰多了，自己看去吧：<a href="https://butterfly.js.org/">地址在这</a> （我好懒🤣</p><p>另外，官方文档的图片显示需要梯子，推荐greenhub，免费好用</p><p>下一篇更如何与typora，picgo，smms图床结合，提升书写体验，敬请期待~</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自建博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客（二）node.js与hexo</title>
      <link href="/posts/fd836635/"/>
      <url>/posts/fd836635/</url>
      
        <content type="html"><![CDATA[<h2 id="node-js与hexo"><a href="#node-js与hexo" class="headerlink" title="node.js与hexo"></a>node.js与hexo</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>这里坑很多，<a href="https://zhuanlan.zhihu.com/p/337663452">参考网址</a></p><blockquote><p>设置好镜像后nvm install 16.17.0，然后nvm use 16.17.0</p><p>若nvm use时出现乱码，是权限不够，本地搜索命令提示符，管理员身份打开，重试即可</p><p>如果之前安装过node，可能会遇到其他乱七八糟的问题，建议运行nvm安装文件夹内的unis000.exe，这样它会删除自己和之前的node，重头再来</p></blockquote><p><strong>测试：</strong></p><p>cmd运行 <code>npm install webpack -g</code>，要耐心等待下载完成</p><p>在<code>E:\nvm\v16.17.0\node_global\node_modules</code>目录中是否有webpack文件夹</p><h3 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h3><p>Hexo就是我们的个人博客网站的框架，在安装之前，我们要先在GitHub上创立一个仓库，名字必须为<code>username.github.io</code>（如果名字里有大写字母，要变成小写）如下图：</p><p><img src="https://s2.loli.net/2022/08/14/ZWbfCiL86hkMdEt.png" alt="创建仓库" style="zoom:67%;" /></p><p>仓库一定要是 public 的</p><p>然后点击 settings -&gt; pages，出现下图所示就对了</p><p><img src="https://s2.loli.net/2022/09/02/OGp4al7AQjsb3ED.png" alt="github-pages" style="zoom: 50%;" /></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>首先新建立一个文件夹 Blog（博客相关东西的本地存放点，设在你想设的位置），点开 Blog 文件夹，在该文件夹内鼠标右键打开 Git Bash Here，输入npm命令 <code>npm install -g hexo-cli</code> 安装Hexo</p><p>安装完成后，输入 <code>hexo init</code> 命令初始化博客</p><blockquote><p>若显示command not found，添加一个Path系统环境变量：<code>E:\Blog\node_modules\.bin</code>（根据自己路径修改</p><p>若出现下图问题，可能是网络不稳定，挂个梯子或者重试几次<img src="https://s2.loli.net/2022/09/02/elSJ7UzucM2VZmN.png" alt="网络问题" style="zoom: 67%;" /></p></blockquote><p>然后输入 <code>hexo g</code> 静态部署</p><p>这时网页已经在本地部署完成，输入 <code>hexo s</code> 命令可以查看：</p><p><img src="https://s2.loli.net/2022/08/14/7XM9paWcfTVDUy8.png" alt="本地预览" style="zoom:67%;" /></p><p>浏览器网址栏输入 <a href="http://localhost:4000">http://localhost:4000</a> 就可以打开新部署的网页</p><p>看完后 ctr+C 停止运行服务器</p><h3 id="将-hexo-部署到-github"><a href="#将-hexo-部署到-github" class="headerlink" title="将 hexo 部署到 github"></a>将 hexo 部署到 github</h3><p>现在回到我们的 Blog 文件夹，用记事本打开 _config.yml 文件，如下图：</p><p><img src="https://s2.loli.net/2022/08/14/DwjKrdA6sOuiZxz.png" alt="博客根目录" style="zoom:67%;" /></p><p>下滑到文件底部，补全为以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/liano3/liano3.github.io.git  #你的仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>然后回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令：<code>npm install hexo-deployer-git --save</code> ，然后分别输入以下三条命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>完成以后，打开浏览器，输入 <a href="https://yourname.github.io">https://yourname.github.io</a> 就可以打开你的网页了</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自建博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客（一）git与github</title>
      <link href="/posts/9b7b26aa/"/>
      <url>/posts/9b7b26aa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问：搭建个人博客需要什么呢？</p><p>答：只需要耐心</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你需要在遇到问题时自己去网上查找答案，有时候一个问题就要查半天，最后还有可能没解决，目前网上的教程大都时间较长远了，操作起来会遇到各种问题，故做此教程以给新手避坑。</p><h2 id="github与git"><a href="#github与git" class="headerlink" title="github与git"></a>github与git</h2><h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><p>很简单，需要一个电子邮箱，注册个人免费版即可，<a href="https://github.com/">网址在这</a>，略</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p><a href="https://git-scm.com/">网址在这</a></p><p>点击 downloads -&gt; 选择系统 -&gt; 下载 -&gt; 一路next(可以更换安装地址) -&gt; 安装成功！</p><p><img src="https://s2.loli.net/2022/08/14/3ZsjkQd7MJcqIhE.png" alt="安装git" style="zoom:67%;" /></p><p><strong>测试：</strong></p><p>右键，点击 Git Bash Here，输入 <code>git</code>，回车</p><p><img src="https://s2.loli.net/2022/08/14/RjNagtnJV8wLfiS.png" alt="测试" style="zoom:67%;" /></p><h3 id="绑定git与github"><a href="#绑定git与github" class="headerlink" title="绑定git与github"></a>绑定git与github</h3><p>首先我们得在 GitHub 上添加 SSH key 配置，要想生成SSH key，就要先安装 SSH，不过我们安装了 Git Bash，其应该自带了 SSH。检验一下是否安装 SSH，我们右键打开 Git Bash，输入 <code>ssh</code>，回车</p><p><img src="https://s2.loli.net/2022/08/14/nhBDEt6f2LbNpiJ.png" alt="SSH" style="zoom:67%;" /></p><p>然后，输入 <code>ssh-keygen -t rsa</code> 命令（注意空格），表示我们指定 RSA 算法生成密钥，然后敲四次回车键，之后就就会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub（<strong>注意：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和 Shift+insert.</strong>）文件的位置在 Git Bash 上面都有显示</p><p>接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。复制公钥 id_rsa.pub 文件里的内容，你可以通过目录找到 id_rsa.pub 文件的位置，用记事本打开文件复制。如果你实在找不到文件也没有关系，按照以下步骤直接在 Git Bash 上打开就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh </span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/14/cTG7hXxdJl9nCqp.png" alt="获取key" style="zoom:67%;" /></p><p>复制是 ctrl+insert 哦，别搞错了</p><p>接下来进入我们的 GitHub 主页，先点击右上角，再点击 settings，然后 SSH and GPG keys，最后 New SSH key，将复制的公钥 id_rsa.pub 的内容粘贴到 key 内，再点击 Add SSH key</p><p><img src="https://s2.loli.net/2022/08/14/OonHgKvaTq3GF8U.png" alt="使用key" style="zoom: 50%;" /></p><p><strong>测试：</strong></p><p>右键打开gitbash，输入 <code>ssh -T git@github.com</code>，回车，可能会出现这种情况，输入 <code>yes</code> 即可</p><p><img src="https://s2.loli.net/2022/08/14/NOBCy9VvIU7FqHS.png" alt="测试" style="zoom:80%;" /></p><p><img src="https://s2.loli.net/2022/08/14/a3OmsiLPvKW42J9.png" alt="测试" style="zoom:80%;" /></p><h3 id="尝试提交文件"><a href="#尝试提交文件" class="headerlink" title="尝试提交文件"></a>尝试提交文件</h3><blockquote><p>这一步只是测试，跟着步骤做完后可以把本地仓库和上传上去的文件删掉</p></blockquote><p>首先通过 github 建立一个仓库，复制仓库地址</p><p><img src="https://s2.loli.net/2022/08/14/tzYluDygFwdUfQs.png" alt="仓库地址" style="zoom: 50%;" /></p><p>在桌面右键打开 gitbash，输入 <code>git clone ...(刚复制的地址)</code>，将远程仓库 clone 到本地</p><p><img src="https://s2.loli.net/2022/08/14/DUIn3odGj7uvEzb.png" alt="拉取仓库" style="zoom: 67%;" /></p><p>现在我们在刚才克隆下来的文件夹里创建一个 text.txt 测试文件，在这个文件夹里右键打开 gitbash，我们使用 <code>git add</code> 命令将文件添加到了「临时缓冲区」，再用 <code>git commit -m &quot;提交信息&quot;</code> 将其提交到本地仓库</p><p><img src="https://s2.loli.net/2022/08/14/4juhNM6YrHTUc7C.png" alt="提交文件" style="zoom:67%;" /></p><p>如果你是第一次提交的话，会让你输入用户名和邮箱：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#你只要再加两行代码就行：</span><br><span class="line">$ git config --global user.name<span class="string">&quot;your name&quot;</span></span><br><span class="line">$ git config --global user.email<span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure><p>现在输入 <code>git push origin main</code> 命令，将本地仓库提交到远程仓库，origin是远程主机的名字：</p><p><img src="https://s2.loli.net/2022/08/14/j9XGc8nNkEyoUvS.png" alt="更新仓库" style="zoom:67%;" /></p><p>第一次上传需要输入密码，上传成功后刷新github远程仓库页面，可以看到被提交上去的test.txt</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自建博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
